-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RAFSO'S SCRIPT - PART 1: CORE SETUP & CONFIG (WORLD 1: STONEWAKE'S CROSS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONSTANTS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local HOVER_HEIGHT = -5
local HOVER_POSITION_2 = Vector3.new(-44.71, -5.12, -273.02)
local SELLER_POSITION = Vector3.new(-113.83, 37.54, -35.20)
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ITEMS BY RARITY (FOR AUTOSELL)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ItemsByRarity = {
	Common = {
		"Stone",
		"Sand Stone",
		"Copper",
		"Iron",
		"Cardboardite"
	},
	Uncommon = {
		"Cobalt",
		"Titanium",
		"Lapis Lazuli",
		"Tin",
		"Silver",
		"Gold",
		"Bananite"
	},
	Rare = {
		"Volcanic Rock",
		"Quartz",
		"Amethyst",
		"Boneite",
		"Dark Boneite",
		"Topaz",
		"Diamond",
		"Sapphire",
		"Mushroomite",
		"Platinum"
	},
	Epic = {
		"Aite",
		"Slimite",
		"Poopite",
		"Cuprite",
		"Obsidian",
		"Emerald",
		"Ruby",
		"Rivalite"
	},
	Legendary = {
		"Uranium",
		"Mythril",
		"Eye Ore",
		"Fireite",
		"Magmaite",
		"Lightite"
	},
	Mythical = {
		"Demonite",
		"Darkryte"
	},
	Rune = {
		"Frost Speck",
		"Venom Crumb",
		"Blast Chip",
		"Miner Shard",
		"Flame Spark",
		"Drain Edge",
		"Briar Notch",
		"Ward Patch",
		"Rot Stich",
		"Chill Dust",
		"Rage Mark"
	}
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFIG SAVE/LOAD SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local CONFIG_FOLDER = "RafsoHubConfigs_World1"
local CONFIG_LIST_FILE = CONFIG_FOLDER .. "/ConfigList.json"
local AUTOLOAD_FILE = CONFIG_FOLDER .. "/AutoLoad.txt"

local configLog = ""

local function addToLog(message)
	configLog = configLog .. message .. "\n"
end

local function clearLog()
	configLog = ""
end

if not isfolder(CONFIG_FOLDER) then
	makefolder(CONFIG_FOLDER)
end

local function saveConfig(configName)
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ’¾ SAVING CONFIG: " .. configName)
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
local configData = {
	enabled = _G.MobFarmConfig.enabled,
	behindDistance = _G.MobFarmConfig.behindDistance,
	verticalDistance = _G.MobFarmConfig.verticalDistance,
	farmDistance = _G.MobFarmConfig.farmDistance,
	hoverSpeed = _G.MobFarmConfig.hoverSpeed,
	lockPosition = _G.MobFarmConfig.lockPosition,
	aboveAngle = _G.MobFarmConfig.aboveAngle,
	belowAngle = _G.MobFarmConfig.belowAngle,
	mobTypes = {},
	miningEnabled = _G.MobFarmConfig.miningEnabled,
	miningVerticalDistance = _G.MobFarmConfig.miningVerticalDistance,
	miningAngle = _G.MobFarmConfig.miningAngle,
	rockTypes = {},
	autoSellEnabled = _G.MobFarmConfig.autoSellEnabled,
	selectedItems = _G.MobFarmConfig.selectedItems,
	autoJoinWorld2Enabled = _G.MobFarmConfig.autoJoinWorld2Enabled, -- ADD THIS LINE
}
	
	addToLog("ğŸ“Š Current settings being saved:")
	addToLog("  Farming Enabled: " .. tostring(configData.enabled))
	addToLog("  Mining Enabled: " .. tostring(configData.miningEnabled))
	addToLog("  AutoSell Enabled: " .. tostring(configData.autoSellEnabled))
	addToLog("  Hover Speed: " .. configData.hoverSpeed)
	addToLog("  Vertical Distance: " .. configData.verticalDistance)
	
	local enabledMobCount = 0
	for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
		table.insert(configData.mobTypes, {
			name = mobData.name,
			enabled = mobData.enabled,
			priority = mobData.priority
		})
		if mobData.enabled then
			addToLog("  âœ… Mob: " .. mobData.name)
			enabledMobCount = enabledMobCount + 1
		end
	end
	addToLog("Total enabled mobs: " .. enabledMobCount)
	
	local enabledRockCount = 0
	for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
		table.insert(configData.rockTypes, {
			name = rockData.name,
			enabled = rockData.enabled,
			priority = rockData.priority
		})
		if rockData.enabled then
			addToLog("  â›ï¸ Rock: " .. rockData.name)
			enabledRockCount = enabledRockCount + 1
		end
	end
	addToLog("Total enabled rocks: " .. enabledRockCount)
	
	addToLog("ğŸ’° AutoSell items:")
	local totalItems = 0
	for rarity, items in pairs(configData.selectedItems) do
		if #items > 0 then
			addToLog("  " .. rarity .. " (" .. #items .. "): " .. table.concat(items, ", "))
			totalItems = totalItems + #items
		end
	end
	addToLog("Total AutoSell items: " .. totalItems)
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	local success, err = pcall(function()
		local jsonData = game:GetService("HttpService"):JSONEncode(configData)
		writefile(configPath, jsonData)
	end)
	
	if not success then
		addToLog("âŒ Failed to write config file: " .. tostring(err))
		setclipboard(configLog)
		return false
	end
	
	addToLog("âœ… Config file written to: " .. configPath)
	
	local configList = {}
	if isfile(CONFIG_LIST_FILE) then
		local listSuccess, listData = pcall(function()
			return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
		end)
		if listSuccess then
			configList = listData
		end
	end
	
	if not table.find(configList, configName) then
		table.insert(configList, configName)
		writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
		addToLog("âœ… Added to config list")
	end
	
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("âœ… CONFIG SAVED SUCCESSFULLY")
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	setclipboard(configLog)
	return true
end

local function loadConfig(configName)
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ“‚ LOADING CONFIG: " .. configName)
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	
	if not isfile(configPath) then
		addToLog("âŒ Config file not found: " .. configPath)
		setclipboard(configLog)
		return false
	end
	
	addToLog("âœ… Config file exists")
	
	local success, configData = pcall(function()
		local fileContent = readfile(configPath)
		return game:GetService("HttpService"):JSONDecode(fileContent)
	end)
	
	if not success then
		addToLog("âŒ Failed to parse config JSON: " .. tostring(configData))
		setclipboard(configLog)
		return false
	end
	
	addToLog("âœ… Config JSON parsed successfully")
	
	_G.MobFarmConfig.enabled = configData.enabled or false
	_G.MobFarmConfig.miningEnabled = configData.miningEnabled or false
	_G.MobFarmConfig.autoSellEnabled = configData.autoSellEnabled or false
	_G.MobFarmConfig.autoJoinWorld2Enabled = configData.autoJoinWorld2Enabled or false
	_G.MobFarmConfig.behindDistance = configData.behindDistance or 8
	_G.MobFarmConfig.verticalDistance = configData.verticalDistance or 8
	_G.MobFarmConfig.farmDistance = configData.farmDistance or 1000
	_G.MobFarmConfig.hoverSpeed = configData.hoverSpeed or 80
	_G.MobFarmConfig.lockPosition = configData.lockPosition or "Below"
	_G.MobFarmConfig.aboveAngle = configData.aboveAngle or 90
	_G.MobFarmConfig.belowAngle = configData.belowAngle or 240
	
	addToLog("ğŸ“Š Settings loaded:")
	addToLog("  Farming Enabled: " .. tostring(_G.MobFarmConfig.enabled))
	addToLog("  Mining Enabled: " .. tostring(_G.MobFarmConfig.miningEnabled))
	addToLog("  AutoSell Enabled: " .. tostring(_G.MobFarmConfig.autoSellEnabled))
	
	local loadedMobCount = 0
	if configData.mobTypes then
		for i, savedMob in ipairs(configData.mobTypes) do
			if _G.MobFarmConfig.mobTypes[i] then
				_G.MobFarmConfig.mobTypes[i].enabled = savedMob.enabled
				if savedMob.enabled then
					addToLog("  âœ… Enabled mob: " .. savedMob.name)
					loadedMobCount = loadedMobCount + 1
				end
			end
		end
	end
	addToLog("Total mobs enabled: " .. loadedMobCount)
	
	_G.MobFarmConfig.miningVerticalDistance = configData.miningVerticalDistance or 6
	_G.MobFarmConfig.miningAngle = configData.miningAngle or 270
	
	local loadedRockCount = 0
	if configData.rockTypes then
		for i, savedRock in ipairs(configData.rockTypes) do
			if _G.MobFarmConfig.rockTypes[i] then
				_G.MobFarmConfig.rockTypes[i].enabled = savedRock.enabled
				if savedRock.enabled then
					addToLog("  âœ… Enabled rock: " .. savedRock.name)
					loadedRockCount = loadedRockCount + 1
				end
			end
		end
	end
	addToLog("Total rocks enabled: " .. loadedRockCount)
	
	if configData.selectedItems then
		_G.MobFarmConfig.selectedItems = configData.selectedItems
		
		addToLog("ğŸ’° AutoSell items loaded:")
		local totalItems = 0
		for rarity, items in pairs(configData.selectedItems) do
			if #items > 0 then
				addToLog("  " .. rarity .. " (" .. #items .. "): " .. table.concat(items, ", "))
				totalItems = totalItems + #items
			end
		end
		addToLog("Total AutoSell items: " .. totalItems)
	end
	
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("âœ… CONFIG LOADED SUCCESSFULLY")
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	setclipboard(configLog)
	return true
end

local function getConfigList()
	if not isfile(CONFIG_LIST_FILE) then
		return {}
	end
	
	local success, configList = pcall(function()
		return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
	end)
	
	if success then
		return configList
	else
		return {}
	end
end

local function deleteConfig(configName)
	clearLog()
	addToLog("ğŸ—‘ï¸ Deleting config: " .. configName)
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	
	if isfile(configPath) then
		delfile(configPath)
		addToLog("âœ… Deleted config file")
	end
	
	local configList = getConfigList()
	for i, name in ipairs(configList) do
		if name == configName then
			table.remove(configList, i)
			writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
			addToLog("âœ… Removed from config list")
			break
		end
	end
	
	if isfile(AUTOLOAD_FILE) and readfile(AUTOLOAD_FILE) == configName then
		delfile(AUTOLOAD_FILE)
		addToLog("âœ… Removed from autoload")
	end
	
	addToLog("âœ… Config deleted successfully")
	setclipboard(configLog)
	return true
end

local function setAutoload(configName)
	clearLog()
	writefile(AUTOLOAD_FILE, configName)
	addToLog("ğŸ”„ Autoload set to: " .. configName)
	setclipboard(configLog)
end

local function getAutoload()
	if isfile(AUTOLOAD_FILE) then
		return readfile(AUTOLOAD_FILE)
	end
	return nil
end

local function debugCurrentConfig()
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ” CURRENT CONFIG STATE")
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("Farming Enabled: " .. tostring(_G.MobFarmConfig.enabled))
	addToLog("Mining Enabled: " .. tostring(_G.MobFarmConfig.miningEnabled))
	addToLog("AutoSell Enabled: " .. tostring(_G.MobFarmConfig.autoSellEnabled))
	
	addToLog("\nEnabled Mobs:")
	local mobCount = 0
	for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
		if mobData.enabled then
			addToLog("  - " .. mobData.name)
			mobCount = mobCount + 1
		end
	end
	if mobCount == 0 then addToLog("  (none)") end
	
	addToLog("\nEnabled Rocks:")
	local rockCount = 0
	for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
		if rockData.enabled then
			addToLog("  - " .. rockData.name)
			rockCount = rockCount + 1
		end
	end
	if rockCount == 0 then addToLog("  (none)") end
	
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	setclipboard(configLog)
end

_G.ConfigFunctions = {
	saveConfig = saveConfig,
	loadConfig = loadConfig,
	getConfigList = getConfigList,
	deleteConfig = deleteConfig,
	setAutoload = setAutoload,
	getAutoload = getAutoload,
	debugCurrentConfig = debugCurrentConfig
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GLOBAL CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_G.MobFarmConfig = {
	enabled = false,
	behindDistance = 8,
	verticalDistance = 8,
	farmDistance = 1000,
	hoverSpeed = 80,
	lockPosition = "Below",
	aboveAngle = 90,
	belowAngle = 240,
	
	hoverSequenceActive = false,
	currentHoverTarget = 1,
	hoverReachedThreshold = 3,
	hoverPosition1 = nil,
	
	weaponRemote = nil,
	lastAttackTime = 0,
	attackCooldown = 0.25,
	lastWeaponCheckTime = 0,
	weaponCheckInterval = 0.5,
	
	currentMob = nil,
	isLockedOn = false,
	bodyVelocity = nil,
	bodyGyro = nil,
	noclipLoop = nil,
	isRespawning = false,
	
	mobTypes = {
		{name = "Brute Zombie", pattern = "^Brute Zombie%d+$", enabled = false, priority = 1},
		{name = "Elite Zombie", pattern = "^Elite Zombie%d+$", enabled = false, priority = 2},
		{name = "Delver Zombie", pattern = "^Delver Zombie%d+$", enabled = false, priority = 3},
		{name = "Zombie", pattern = "^Zombie%d+$", enabled = false, priority = 4},
	},
	
	miningEnabled = false,
	miningVerticalDistance = 6,
	miningAngle = 270,
	currentRock = nil,
	lastMineTime = 0,
	miningCooldown = 0.1,
	lastPickaxeCheckTime = 0,
	pickaxeCheckInterval = 0.5,
	miningBodyVelocity = nil,
	miningBodyGyro = nil,
	
	miningDefenseEnabled = true,
	miningDefenseDistance = 10,
	defendingAgainstMob = nil,
	savedMiningRock = nil,
	weaponEquipped = false,
	lastDefenseAttackTime = 0,
	defenseAttackCooldown = 0.1,
	
	rockDurabilityCheck = 0,
	rockDurabilityCheckInterval = 3,
	lastRockDurability = nil,
	ignoredRocks = {},
	
	rockTypes = {
		{name = "Boulder", enabled = false, priority = 1},
		{name = "Rock", enabled = false, priority = 2},
		{name = "Pebble", enabled = false, priority = 3},
	},
	
	autoJoinWorld2Enabled = false,
	autoSellEnabled = false,
	sellCooldown = 1.5,
	lastSellTime = 0,
	autoClickerActive = false,
	autoClickerLoop = nil,
	selectedItems = {
		Common = {},
		Uncommon = {},
		Rare = {},
		Epic = {},
		Legendary = {},
		Mythical = {},
		Rune = {}
	}
}

local config = _G.MobFarmConfig

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 2: NOCLIP & MOB/ROCK DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startNoclip()
	if config.noclipLoop then return end
	
	config.noclipLoop = RunService.Stepped:Connect(function()
		local isTeleporting = _G.teleportHoverActive == true
		
		if not config.enabled and not config.miningEnabled and not isTeleporting then 
			return 
		end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end)
end

local function stopNoclip()
	if config.noclipLoop then
		config.noclipLoop:Disconnect()
		config.noclipLoop = nil
		
		local character = LocalPlayer.Character
		if character then
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					part.CanCollide = true
				end
			end
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOB DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidMob(mob)
	local humanoid = mob:FindFirstChildOfClass("Humanoid")
	local rootPart = mob:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not rootPart then return false end
	if humanoid.Health <= 0 then return false end
	if Players:GetPlayerFromCharacter(mob) then return false end
	
	return true
end

local function matchesMobPattern(mobName, pattern)
	return string.match(mobName, pattern) ~= nil
end

local function getMobPriority(mob)
	for _, mobData in ipairs(config.mobTypes) do
		if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
			return mobData.priority
		end
	end
	return 999
end

local function getClosestMob()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return nil end
	
	local closestMob = nil
	local closestDistance = config.farmDistance
	local highestPriority = 999
	
	for _, child in pairs(Living:GetChildren()) do
		if isValidMob(child) then
			for _, mobData in pairs(config.mobTypes) do
				if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
					local mobRoot = child:FindFirstChild("HumanoidRootPart")
					if mobRoot then
						local distance = (rootPart.Position - mobRoot.Position).Magnitude
						local priority = getMobPriority(child)
						
						if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
							closestMob = child
							closestDistance = distance
							highestPriority = priority
						end
					end
					break
				end
			end
		end
	end
	
	return closestMob
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ROCK DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidRock(durabilityModel)
	if not durabilityModel:IsA("Model") then return false end
	if not durabilityModel.Parent then return false end
	
	local hasMeshPart = durabilityModel:FindFirstChildOfClass("MeshPart") ~= nil
	
	return hasMeshPart
end

local function isRockIgnored(rock)
	for _, ignoredRock in ipairs(config.ignoredRocks) do
		if ignoredRock == rock then
			return true
		end
	end
	return false
end

local function getRockPriority(rockTypeName)
	for _, rockData in ipairs(config.rockTypes) do
		if rockData.enabled and rockTypeName == rockData.name then
			return rockData.priority
		end
	end
	return 999
end

local function getRockPosition(durabilityModel)
	local rockPart = durabilityModel:FindFirstChild("Rock")
	if rockPart and rockPart:IsA("BasePart") then
		return rockPart
	end
	
	local rockTypeModel = durabilityModel.Parent
	if rockTypeModel then
		local hitbox = rockTypeModel:FindFirstChild("Hitbox")
		if hitbox and hitbox:IsA("BasePart") then
			return hitbox
		end
	end
	
	local meshPart = durabilityModel:FindFirstChildOfClass("MeshPart")
	if meshPart then
		return meshPart
	end
	
	return nil
end

local function getRockDurability(rock)
	if not rock then return nil end
	return tonumber(rock.Name)
end

local function getClosestRock()
	local character = LocalPlayer.Character
	if not character then 
		return nil 
	end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then 
		return nil 
	end
	
	local rocksFolder = workspace:FindFirstChild("Rocks")
	if not rocksFolder then
		return nil
	end
	
	local closestRock = nil
	local closestDistance = config.farmDistance
	local highestPriority = 999
	
	for _, islandFolder in pairs(rocksFolder:GetChildren()) do
		if islandFolder:IsA("Folder") then
			for _, spawnPart in pairs(islandFolder:GetChildren()) do
				if spawnPart:IsA("Part") and spawnPart.Name == "SpawnLocation" then
					for _, rockTypeModel in pairs(spawnPart:GetChildren()) do
						if rockTypeModel:IsA("Model") then
							local rockTypeName = rockTypeModel.Name
							local priority = getRockPriority(rockTypeName)
							
							if priority < 999 then
								for _, durabilityModel in pairs(rockTypeModel:GetChildren()) do
									if durabilityModel:IsA("Model") and tonumber(durabilityModel.Name) then
										if not isRockIgnored(durabilityModel) and isValidRock(durabilityModel) then
											local positionPart = getRockPosition(durabilityModel)
											if positionPart then
												local distance = (rootPart.Position - positionPart.Position).Magnitude
												
												if distance <= config.farmDistance then
													if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
														closestRock = durabilityModel
														closestDistance = distance
														highestPriority = priority
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	
	return closestRock
end

local function makeRockTransparent(rock)
	if not rock then return end
	
	for _, descendant in pairs(rock:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			descendant.Transparency = 0.7
		end
	end
	
	local rockTypeModel = rock.Parent
	if rockTypeModel then
		for _, descendant in pairs(rockTypeModel:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				descendant.Transparency = 0.7
			end
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STORE FUNCTIONS GLOBALLY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_G.FarmFunctions = {
	startNoclip = startNoclip,
	stopNoclip = stopNoclip,
	getClosestMob = getClosestMob,
	getClosestRock = getClosestRock,
	isValidMob = isValidMob,
	isValidRock = isValidRock,
	getRockPosition = getRockPosition,
	getRockDurability = getRockDurability,
	isRockIgnored = isRockIgnored,
	makeRockTransparent = makeRockTransparent,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 3: WEAPON SYSTEM, AUTOSELL & PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local funcs = _G.FarmFunctions

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WEAPON & TOOL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function autoEquipWeapon()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local weaponInChar = character:FindFirstChild("Weapon")
	if weaponInChar and weaponInChar:IsA("Tool") then
		return true
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local weapon = backpack:FindFirstChild("Weapon")
		if weapon and weapon:IsA("Tool") then
			humanoid:EquipTool(weapon)
			task.wait(0.2)
			return true
		end
	end
	
	return false
end

local function autoEquipPickaxe()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local pickaxeInChar = character:FindFirstChild("Pickaxe")
	if pickaxeInChar and pickaxeInChar:IsA("Tool") then
		return true
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local pickaxe = backpack:FindFirstChild("Pickaxe")
		if pickaxe and pickaxe:IsA("Tool") then
			humanoid:EquipTool(pickaxe)
			task.wait(0.2)
			return true
		end
	end
	
	return false
end

local function clickMouse()
	local success = pcall(function()
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		task.wait(0.01)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end)
	return success
end

local function performAttack()
	if not config.isLockedOn or not config.currentMob or config.hoverSequenceActive then
		return
	end
	
	local currentTime = tick()
	if currentTime - config.lastAttackTime < config.attackCooldown then
		return
	end
	
	config.lastAttackTime = currentTime
	clickMouse()
end

local function performMine()
	if not config.currentRock then return end
	if not config.miningEnabled then return end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local pickaxe = character:FindFirstChild("Pickaxe")
	if not pickaxe then
		autoEquipPickaxe()
		return
	end
	
	local currentTime = tick()
	if currentTime - config.lastMineTime < config.miningCooldown then
		return
	end
	
	config.lastMineTime = currentTime
	clickMouse()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local originalPosition = nil

local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

local function startAutoClickerAt(x, y, duration)
	if config.autoClickerActive then return end
	
	config.autoClickerActive = true
	
	config.autoClickerLoop = task.spawn(function()
		local startTime = tick()
		while config.autoClickerActive and (tick() - startTime) < duration do
			VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
			task.wait(0.01)
			VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
			task.wait(0.05)
		end
		config.autoClickerActive = false
	end)
end

local function stopAutoClicker()
	config.autoClickerActive = false
	if config.autoClickerLoop then
		task.cancel(config.autoClickerLoop)
		config.autoClickerLoop = nil
	end
end

local function closeChat()
	task.wait(0.3)
	startAutoClickerAt(NO_BUTTON_X, NO_BUTTON_Y, 3)
	task.wait(0.3)
	stopAutoClicker()
end

local function talkToSeller()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	originalPosition = rootPart.CFrame
	
	rootPart.CFrame = CFrame.new(SELLER_POSITION)
	task.wait(0.5)
	
	if SELLER_PROXIMITY then
		fireproximityprompt(SELLER_PROXIMITY)
		task.wait(0.5)
		closeChat()
		task.wait(0)
		
		if originalPosition then
			rootPart.CFrame = originalPosition
		end
		
		return true
	end
	
	return false
end

local function getItemQuantity(itemName)
	local success, quantity = pcall(function()
		local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
		if not playerGui then return 0 end
		
		local menu = playerGui:FindFirstChild("Menu")
		if not menu then return 0 end
		
		local stash = menu:FindFirstChild("Frame", true)
		if stash then
			stash = stash:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Menus", true)
				if stash then
					stash = stash:FindFirstChild("Stash", true)
					if stash then
						stash = stash:FindFirstChild("Background", true)
						if stash then
							for _, itemFolder in pairs(stash:GetChildren()) do
								if itemFolder:IsA("Folder") or itemFolder:IsA("Frame") then
									local main = itemFolder:FindFirstChild("Main")
									if main then
										if itemFolder.Name == itemName then
											local quantityLabel = main:FindFirstChild("Quantity")
											if quantityLabel and quantityLabel:IsA("TextLabel") then
												local quantityText = quantityLabel.Text
												local number = tonumber(string.match(quantityText, "%d+"))
												return number or 0
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		
		return 0
	end)
	
	if success then
		return quantity
	else
		return 0
	end
end

local function sellItems()
	if not config.autoSellEnabled then return end
	
	local currentTime = tick()
	if currentTime - config.lastSellTime < config.sellCooldown then
		return
	end
	
	local itemsToSell = {}
	
	for rarity, items in pairs(config.selectedItems) do
		if rarity ~= "Rune" then
			for _, itemName in ipairs(items) do
				local quantity = getItemQuantity(itemName)
				
				if quantity > 0 then
					itemsToSell[itemName] = quantity
				end
			end
		end
	end
	
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
	if playerGui then
		local menu = playerGui:FindFirstChild("Menu")
		if menu then
			local stash = menu:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Frame", true)
				if stash then
					stash = stash:FindFirstChild("Menus", true)
					if stash then
						stash = stash:FindFirstChild("Stash", true)
						if stash then
							stash = stash:FindFirstChild("Background", true)
							if stash then
								for _, itemFolder in pairs(stash:GetChildren()) do
									local main = itemFolder:FindFirstChild("Main")
									if main then
										local itemNameLabel = main:FindFirstChild("ItemName")
										if itemNameLabel and itemNameLabel:IsA("TextLabel") then
											local itemName = itemNameLabel.Text
											
											for _, selectedRuneName in ipairs(config.selectedItems.Rune) do
												if itemName == selectedRuneName then
													itemsToSell[itemFolder.Name] = 1
													break
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	
	if next(itemsToSell) == nil then
		return
	end
	
	local success, err = pcall(function()
		RunCommand:InvokeServer("SellConfirm", {Basket = itemsToSell})
	end)
	
	if success then
		config.lastSellTime = currentTime
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function setupPhysicsMovement()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	if config.bodyVelocity then
		config.bodyVelocity:Destroy()
	end
	if config.bodyGyro then
		config.bodyGyro:Destroy()
	end
	
	local bv = Instance.new("BodyVelocity")
	bv.Name = "FarmVelocity"
	bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	bv.Velocity = Vector3.new(0, 0, 0)
	bv.P = 1250
	bv.Parent = rootPart
	config.bodyVelocity = bv
	
	local bg = Instance.new("BodyGyro")
	bg.Name = "FarmGyro"
	bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
	bg.P = 30000
	bg.D = 1000
	bg.Parent = rootPart
	config.bodyGyro = bg
	
	rootPart.Anchored = false
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	end
	
	return true
end

local function cleanupPhysicsMovement()
	if config.bodyVelocity then
		config.bodyVelocity:Destroy()
		config.bodyVelocity = nil
	end
	if config.bodyGyro then
		config.bodyGyro:Destroy()
		config.bodyGyro = nil
	end
	
	local character = LocalPlayer.Character
	if character then
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if rootPart then
			rootPart.Anchored = false
			rootPart.Velocity = Vector3.new(0, 0, 0)
		end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
			task.wait(0.1)
			humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
		end
	end
	
	config.isLockedOn = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ADD TO GLOBAL FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

funcs.autoEquipWeapon = autoEquipWeapon
funcs.autoEquipPickaxe = autoEquipPickaxe
funcs.performAttack = performAttack
funcs.performMine = performMine
funcs.setupPhysicsMovement = setupPhysicsMovement
funcs.cleanupPhysicsMovement = cleanupPhysicsMovement
funcs.talkToSeller = talkToSeller
funcs.sellItems = sellItems

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 4: MOVEMENT LOGIC & HOVERING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- POSITION CALCULATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getLockPosition(mob)
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	if not mobRoot then return nil end
	
	local distance = config.behindDistance
	local verticalDist = config.verticalDistance
	local mobPos = mobRoot.Position
	local targetPos
	
	if config.lockPosition == "Back" then
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	elseif config.lockPosition == "Front" then
		local frontOffset = mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + frontOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	elseif config.lockPosition == "Above" then
		targetPos = mobPos + Vector3.new(0, verticalDist, 0)
	elseif config.lockPosition == "Below" then
		targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
	else
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	end
	
	return targetPos
end

local function getMiningPosition(rock)
	if not rock then return nil end
	
	local positionPart = funcs.getRockPosition(rock)
	if not positionPart then 
		return nil 
	end
	
	local rockPos = positionPart.Position
	local targetPos = rockPos + Vector3.new(0, -config.miningVerticalDistance, 0)
	
	return targetPos
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function hoverToPosition(targetPos, lookAtPos)
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return false
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < config.hoverReachedThreshold then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		return true
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	
	local desiredVelocity = direction.Unit * targetSpeed
	local currentVelocity = config.bodyVelocity.Velocity
	local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	if lookAtPos then
		local lookCFrame = CFrame.new(currentPos, lookAtPos)
		config.bodyGyro.CFrame = lookCFrame
	end
	
	return false
end

local function hoverToMob(targetPos, mob)
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
		return
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	config.isLockedOn = distance < 12
	
	if (config.lockPosition == "Above" or config.lockPosition == "Below") then
		if distance < 5 then
			local followSpeed = math.max(5, distance * 2)
			local desiredVelocity = direction.Unit * followSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.3)
		else
			local targetSpeed = config.hoverSpeed * math.min(distance / 10, 1)
			local desiredVelocity = direction.Unit * targetSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.4)
		end
		
		if config.lockPosition == "Above" then
			local angle = math.rad(config.aboveAngle)
			local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(downCFrame, 0.7)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 60000
			config.bodyGyro.D = 2000
		else
			local angle = math.rad(config.belowAngle)
			local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(upCFrame, 0.7)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 60000
			config.bodyGyro.D = 2000
		end
		return
	end
	
	local targetSpeed
	if distance < 3 then
		targetSpeed = 3
	elseif distance < 8 then
		targetSpeed = 12
	else
		targetSpeed = config.hoverSpeed * math.min(distance / 8, 1)
	end
	
	local desiredVelocity = direction.Unit * targetSpeed
	
	local lerpSpeed
	if distance < 3 then
		lerpSpeed = 0.15
	elseif distance < 8 then
		lerpSpeed = 0.4
	else
		lerpSpeed = 0.3
	end
	
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, lerpSpeed)
	config.bodyVelocity.Velocity = newVelocity
	
	local mobVelocity = mobRoot.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
	local predictedPos = mobRoot.Position + (mobVelocity * 0.1)
	local lookCFrame = CFrame.new(currentPos, predictedPos)
	
	if distance < 8 then
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.8)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 80000
		config.bodyGyro.D = 2500
	else
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.5)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 50000
		config.bodyGyro.D = 1500
	end
end

local function hoverToRock(targetPos, rock)
	if not targetPos then 
		return 
	end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < 3 then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		
		local angle = math.rad(config.miningAngle)
		local lookCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
		config.bodyGyro.CFrame = lookCFrame
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 50000
		return
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	local desiredVelocity = direction.Unit * targetSpeed
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	local positionPart = funcs.getRockPosition(rock)
	if positionPart then
		local lookCFrame = CFrame.new(currentPos, positionPart.Position)
		config.bodyGyro.CFrame = lookCFrame
		config.bodyGyro.P = 10000
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ADD TO GLOBAL FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

funcs.getLockPosition = getLockPosition
funcs.getMiningPosition = getMiningPosition
funcs.hoverToPosition = hoverToPosition
funcs.hoverToMob = hoverToMob
funcs.hoverToRock = hoverToRock

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 5: UI SETUP & TELEPORT SYSTEM (ERROR PROTECTED)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT POSITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local teleportAreas = {
	["Forge"] = Vector3.new(-192.64, 29.57, 163.72),
	["Cave 1"] = Vector3.new(26.77, -5.54, -92.99),
	["Cave 2"] = Vector3.new(228.51, -13.58, -228.31),
	["Cave 3"] = Vector3.new(-30.18, -5.65, -277.74),
	["Cave 4"] = Vector3.new(-27.87, -14.86, -497.32),
	["Cave 5 (Needs Unlocking)"] = Vector3.new(254.87, -13.89, -265.18),
	["Pickaxes"] = Vector3.new(-91.92, 27.53, 90.57),
	["Potions"] = Vector3.new(-154.15, 27.92, 115.68),
	["Stonewake's Pickaxe $3.333"] = Vector3.new(-29.40, -3.17, -269.23),
	["Arcane Pickaxe (Needs Unlocking)"] = Vector3.new(235.67, -14.31, -336.06),
}

local teleportNPCs = {
	["Buyer"] = Vector3.new(-113.83, 37.54, -35.20),
	["Tomo the Explorist"] = Vector3.new(-106.44, 49.49, -106.58),
	["Weapon Buyer"] = Vector3.new(-178.52, 27.67, 14.79),
	["Bard"] = Vector3.new(-132.60, 27.79, 107.79),
	["Sensei Moro"] = Vector3.new(-199.38, 29.44, 156.12),
	["Runemaker"] = Vector3.new(-272.62, 20.32, 144.82),
	["Enhancer"] = Vector3.new(-259.79, 19.76, 27.66),
	["Nord"] = Vector3.new(38.92, -5.63, -102.73),
	["Umut The Brave"] = Vector3.new(15.41, -5.87, -117.16),
	["Undead"] = Vector3.new(-45.73, -26.69, -60.67),
	["Wizard"] = Vector3.new(-22.93, 80.88, -356.81),
	["Suspicious Fisher"] = Vector3.new(-295.87, 23.82, -91.61),
	["Injured Miner"] = Vector3.new(80.57, -14.63, -364.49),
}

local selectedArea = nil
local selectedNPC = nil

_G.teleportHoverActive = false
local teleportHoverTarget = nil
local teleportHoverLoop = nil
local teleportNoclipEnabled = false

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WORLD 2 TELEPORT SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FORGOTTEN_KINGDOM_SPAWN = Vector3.new(-260.62, 17.75, 100.27)
local FORGOTTEN_KINGDOM_FRONT = Vector3.new(-260.62, 17.75, 93.27)
local FORGOTTEN_KINGDOM_GUI_X = 602
local FORGOTTEN_KINGDOM_GUI_Y = 459
local TELEPORT_BUTTON_X = 1124
local TELEPORT_BUTTON_Y = 682

local world2AutoJoinActive = false
local world2AutoJoinLoop = nil

local function clickAt(x, y)
	VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
	task.wait(0.01)
	VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
end

local function pressK()
	VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.K, false, game)
	task.wait(0.05)
	VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.K, false, game)
end

local function checkForPortalTool()
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack and backpack:FindFirstChild("PortalTool") then
		return true
	end
	
	local character = LocalPlayer.Character
	if character and character:FindFirstChild("PortalTool") then
		return true
	end
	
	return false
end

local function teleportToWorld2()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	
	if not rootPart or not humanoid then return false end
	
	local spawnPosition = FORGOTTEN_KINGDOM_SPAWN
	
	local startTime = tick()
	while tick() - startTime < 1 do
		rootPart.CFrame = CFrame.new(spawnPosition)
		task.wait(0.05)
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not backpack then return false end
	
	local portalTool = backpack:FindFirstChild("PortalTool")
	if not portalTool then return false end
	
	humanoid:EquipTool(portalTool)
	task.wait(0.3)
	
	if not character:FindFirstChild("PortalTool") then return false end
	
	clickAt(0, 0)
	task.wait(1)
	
	local proximityPrompt = nil
	
	for attempt = 1, 10 do
		local debris = workspace:FindFirstChild("Debris")
		if debris then
			local portalForge = debris:FindFirstChild("PortalTheForge")
			if portalForge then
				local proximityContainer = portalForge:FindFirstChild("ProximityContainer")
				if proximityContainer then
					proximityPrompt = proximityContainer:FindFirstChild("ProximityPrompt")
					if proximityPrompt then
						break
					end
				end
			end
		end
		task.wait(0.2)
	end
	
	if not proximityPrompt then return false end
	
	local frontPosition = FORGOTTEN_KINGDOM_FRONT
	
	local lockStart = tick()
	while tick() - lockStart < 1.5 do
		rootPart.CFrame = CFrame.new(frontPosition)
		task.wait(0.05)
	end
	
	local targetPart = proximityPrompt.Parent
	if targetPart and targetPart:IsA("BasePart") then
		pcall(function()
			proximityPrompt:InputHoldBegin()
			proximityPrompt:InputHoldEnd()
		end)
	end
	
	task.wait(0.5)
	
	clickAt(FORGOTTEN_KINGDOM_GUI_X, FORGOTTEN_KINGDOM_GUI_Y)
	task.wait(0.3)
	
	task.wait(0.5)
	
	for i = 1, 5 do
		clickAt(TELEPORT_BUTTON_X, TELEPORT_BUTTON_Y)
		task.wait(0.15)
	end
	
	return true
end

local function startWorld2AutoJoin()
	if world2AutoJoinActive then
		return
	end
	
	if not checkForPortalTool() then
		return false
	end
	
	world2AutoJoinActive = true
	
	world2AutoJoinLoop = task.spawn(function()
		while world2AutoJoinActive do
			teleportToWorld2()
			task.wait(300)
		end
	end)
	
	return true
end

local function stopWorld2AutoJoin()
	world2AutoJoinActive = false
	if world2AutoJoinLoop then
		task.cancel(world2AutoJoinLoop)
		world2AutoJoinLoop = nil
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- LOAD LINORIA UI LIBRARY (WITH COMPREHENSIVE ERROR HANDLING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ Loading Linoria UI Library...")

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library, ThemeManager

-- Retry mechanism for library loading
local maxRetries = 3
local retryDelay = 2

for attempt = 1, maxRetries do
	print("ğŸ“¥ Attempt " .. attempt .. " of " .. maxRetries .. "...")
	
	local librarySuccess = pcall(function()
		Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
		ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
	end)
	
	if librarySuccess and Library then
		print("âœ… Linoria UI Library loaded successfully")
		break
	else
		warn("âŒ Failed to load Linoria UI Library (Attempt " .. attempt .. ")")
		
		if attempt < maxRetries then
			print("â³ Retrying in " .. retryDelay .. " seconds...")
			task.wait(retryDelay)
		else
			error("âŒ Failed to load Linoria UI Library after " .. maxRetries .. " attempts!")
			return
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CREATE WINDOW (WITH ERROR PROTECTION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Window

local windowSuccess = pcall(function()
	Window = Library:CreateWindow({
		Title = "The Forge by Rafso | Stonewake's Cross",
		Center = true,
		AutoShow = true,
		TabPadding = 8,
		MenuFadeTime = 0.2
	})
end)

if not windowSuccess or not Window then
	error("âŒ Failed to create window!")
	return
end

print("âœ… Window created")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INITIALIZE GLOBAL REFERENCES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

getgenv().Toggles = getgenv().Toggles or {}
getgenv().Options = getgenv().Options or {}

_G.UIReferences = {
	Window = Window,
	Library = Library,
	Tabs = {},
	Toggles = getgenv().Toggles,
	Options = getgenv().Options,
}

local Tabs = _G.UIReferences.Tabs
local Toggles = getgenv().Toggles
local Options = getgenv().Options

print("âœ… Global references initialized")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT HOVER FUNCTION (NEEDS UI REFERENCE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function hoverToTeleportPosition(targetPos)
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return false
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < 3 then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		return true
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	
	local desiredVelocity = direction.Unit * targetSpeed
	local currentVelocity = config.bodyVelocity.Velocity
	local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	local lookCFrame = CFrame.new(currentPos, targetPos)
	config.bodyGyro.CFrame = lookCFrame
	
	return false
end

local function startTeleportHover(position, locationName)
	if _G.teleportHoverActive then
		Library:Notify("Already traveling to a location!", 2)
		return
	end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		task.wait(0.1)
	end
	
	_G.teleportHoverActive = true
	
	if not config.noclipLoop then
		funcs.startNoclip()
		teleportNoclipEnabled = true
	end
	
	teleportHoverTarget = position
	
	Library:Notify("Traveling to " .. locationName .. "...", 2)
	
	teleportHoverLoop = RunService.Heartbeat:Connect(function()
		if not _G.teleportHoverActive then
			if teleportHoverLoop then
				teleportHoverLoop:Disconnect()
				teleportHoverLoop = nil
			end
			return
		end
		
		local reached = hoverToTeleportPosition(teleportHoverTarget)
		
		if reached then
			_G.teleportHoverActive = false
			
			if teleportHoverLoop then
				teleportHoverLoop:Disconnect()
				teleportHoverLoop = nil
			end
			
			Library:Notify("Arrived at " .. locationName .. "!", 2)
			
			if not config.enabled and not config.miningEnabled then
				task.wait(0.5)
				
				if teleportNoclipEnabled then
					funcs.stopNoclip()
					teleportNoclipEnabled = false
				end
				
				funcs.cleanupPhysicsMovement()
			end
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 6: AUTO-LOOPS & TAB CREATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOOPS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local attackLoop = nil
local mineLoop = nil
local weaponCheckLoop = nil
local pickaxeCheckLoop = nil
local sellLoop = nil

local function startAutoAttack()
	if attackLoop then return end
	
	task.spawn(function()
		task.wait(0.5)
		funcs.autoEquipWeapon()
	end)
	
	attackLoop = RunService.Heartbeat:Connect(function()
		if not config.enabled then return end
		funcs.performAttack()
	end)
	
	if not weaponCheckLoop then
		weaponCheckLoop = RunService.Heartbeat:Connect(function()
			if not config.enabled then return end
			local currentTime = tick()
			if currentTime - config.lastWeaponCheckTime >= config.weaponCheckInterval then
				config.lastWeaponCheckTime = currentTime
				funcs.autoEquipWeapon()
			end
		end)
	end
end

local function stopAutoAttack()
	if attackLoop then
		attackLoop:Disconnect()
		attackLoop = nil
	end
	if weaponCheckLoop then
		weaponCheckLoop:Disconnect()
		weaponCheckLoop = nil
	end
end

local function startAutoMine()
	if mineLoop then return end
	
	task.spawn(function()
		task.wait(0.3)
		funcs.autoEquipPickaxe()
	end)
	
	mineLoop = RunService.Heartbeat:Connect(function()
		if not config.miningEnabled then return end
		funcs.performMine()
	end)
	
	if not pickaxeCheckLoop then
		pickaxeCheckLoop = RunService.Heartbeat:Connect(function()
			if not config.miningEnabled then return end
			local currentTime = tick()
			if currentTime - config.lastPickaxeCheckTime >= config.pickaxeCheckInterval then
				config.lastPickaxeCheckTime = currentTime
				funcs.autoEquipPickaxe()
			end
		end)
	end
end

local function stopAutoMine()
	if mineLoop then
		mineLoop:Disconnect()
		mineLoop = nil
	end
	if pickaxeCheckLoop then
		pickaxeCheckLoop:Disconnect()
		pickaxeCheckLoop = nil
	end
end

local function startAutoSell()
	if sellLoop then return end
	
	sellLoop = RunService.Heartbeat:Connect(function()
		if not config.autoSellEnabled then return end
		funcs.sellItems()
	end)
end

local function stopAutoSell()
	if sellLoop then
		sellLoop:Disconnect()
		sellLoop = nil
	end
end

_G.AutoLoopFunctions = {
	startAutoAttack = startAutoAttack,
	stopAutoAttack = stopAutoAttack,
	startAutoMine = startAutoMine,
	stopAutoMine = stopAutoMine,
	startAutoSell = startAutoSell,
	stopAutoSell = stopAutoSell,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CREATE TABS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Tabs.Info = Window:AddTab('Info')
Tabs.Farming = Window:AddTab('Mobs')
Tabs.Mining = Window:AddTab('Mine')
Tabs.AutoSell = Window:AddTab('Sell')
Tabs.Teleport = Window:AddTab('Teleport')
Tabs.Settings = Window:AddTab('Settings')
Tabs.Configs = Window:AddTab('Config')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INFO TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local InfoLeftBox = Tabs.Info:AddLeftGroupbox('Script Information')

InfoLeftBox:AddLabel("World 1: Stonewake's Cross")
InfoLeftBox:AddLabel('Tested on Xeno')
InfoLeftBox:AddLabel('Created by Rafso [literalh]')
InfoLeftBox:AddDivider()
InfoLeftBox:AddLabel('Script Features:')
InfoLeftBox:AddLabel('â€¢ Auto-Farm ')
InfoLeftBox:AddLabel('â€¢ Auto-Mine')
InfoLeftBox:AddLabel('â€¢ Auto-Sell')
InfoLeftBox:AddLabel('â€¢ Teleports')
InfoLeftBox:AddLabel('â€¢ Config System')

local InfoRightBox = Tabs.Info:AddRightGroupbox('Tips')

InfoRightBox:AddLabel('Important Tips:')
InfoRightBox:AddLabel('â€¢ Press F1 to toggle farming')
InfoRightBox:AddLabel('â€¢ Press F2 to toggle mining')
InfoRightBox:AddLabel('â€¢ Manually press Talk to Buyer')
InfoRightBox:AddLabel('  if not automatically done')
InfoRightBox:AddLabel('â€¢ Script is in BETA')
InfoRightBox:AddLabel('â€¢ Do not hesitate sending a DM')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FARMING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FarmingGroupBox = Tabs.Farming:AddLeftGroupbox('Mob Farming')

Toggles.FarmToggle = FarmingGroupBox:AddToggle('FarmToggle', {
	Text = 'Enable Mob Farming (F1)',
	Default = false,
	Tooltip = 'Toggle mob farming on/off',
	Callback = function(Value)
		config.enabled = Value
		
		if config.enabled then
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
					config.hoverSequenceActive = true
					config.currentHoverTarget = 1
				end
			end
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			startAutoAttack()
		else
			task.wait(0.1)
			
			config.hoverSequenceActive = false
			config.currentMob = nil
			stopAutoAttack()
			funcs.stopNoclip()
			funcs.cleanupPhysicsMovement()
		end
	end
})

FarmingGroupBox:AddDivider()

Options.LockPosition = FarmingGroupBox:AddDropdown('LockPosition', {
	Values = {'Back', 'Front', 'Above', 'Below'},
	Default = 4,
	Multi = false,
	Text = 'Lock Position',
	Tooltip = 'Choose where to position yourself relative to the mob',
	Callback = function(Value)
		config.lockPosition = Value
	end
})

FarmingGroupBox:AddDivider()

local mobOptions = {}
for i, mobData in ipairs(config.mobTypes) do
	table.insert(mobOptions, mobData.name)
end

FarmingGroupBox:AddLabel('Select Mobs to Farm:')

Options.MobSelection = FarmingGroupBox:AddDropdown('MobSelection', {
	Values = mobOptions,
	Default = 1,
	Multi = true,
	Text = 'Select Mobs',
	Tooltip = 'Choose which mobs to farm',
	Callback = function(Value)
		for i, mobData in ipairs(config.mobTypes) do
			config.mobTypes[i].enabled = false
		end
		
		for mobName, isEnabled in pairs(Value) do
			if isEnabled then
				for i, mobData in ipairs(config.mobTypes) do
					if mobData.name == mobName then
						config.mobTypes[i].enabled = true
						break
					end
				end
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MiningGroupBox = Tabs.Mining:AddLeftGroupbox('Mining')

Toggles.MineToggle = MiningGroupBox:AddToggle('MineToggle', {
	Text = 'Enable Mining (F2)',
	Default = false,
	Tooltip = 'Toggle mining on/off',
	Callback = function(Value)
		config.miningEnabled = Value
		
		if config.miningEnabled then
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.rockDurabilityCheck = tick()
			config.currentRock = nil
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
					config.hoverSequenceActive = true
					config.currentHoverTarget = 1
				end
			end
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			startAutoMine()
		else
			task.wait(0.1)
			
			config.hoverSequenceActive = false
			config.currentHoverTarget = 1
			config.currentRock = nil
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.isLockedOn = false
			
			stopAutoMine()
			funcs.stopNoclip()
			funcs.cleanupPhysicsMovement()
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					rootPart.Velocity = Vector3.new(0, 0, 0)
					rootPart.Anchored = false
				end
			end
		end
	end
})

MiningGroupBox:AddDivider()

local rockOptions = {}
for i, rockData in ipairs(config.rockTypes) do
	table.insert(rockOptions, rockData.name)
end

MiningGroupBox:AddLabel('Select Rocks to Mine:')

Options.RockSelection = MiningGroupBox:AddDropdown('RockSelection', {
	Values = rockOptions,
	Default = 1,
	Multi = true,
	Text = 'Select Rocks',
	Tooltip = 'Choose which rocks to mine',
	Callback = function(Value)
		for i, rockData in ipairs(config.rockTypes) do
			config.rockTypes[i].enabled = false
		end
		
		for rockName, isEnabled in pairs(Value) do
			if isEnabled then
				for i, rockData in ipairs(config.rockTypes) do
					if rockData.name == rockName then
						config.rockTypes[i].enabled = true
						break
					end
				end
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AutoSellGroupBox = Tabs.AutoSell:AddLeftGroupbox('Auto Sell')

Toggles.AutoSellToggle = AutoSellGroupBox:AddToggle('AutoSellToggle', {
	Text = 'Enable Auto Sell',
	Default = false,
	Tooltip = 'Automatically sell selected items',
	Callback = function(Value)
		config.autoSellEnabled = Value
		
		if config.autoSellEnabled then
			_G.AutoLoopFunctions.startAutoSell()
		else
			_G.AutoLoopFunctions.stopAutoSell()
		end
	end
})

AutoSellGroupBox:AddDivider()

AutoSellGroupBox:AddButton({
	Text = 'Talk to Buyer',
	Func = function()
		local success = funcs.talkToSeller()
		
		if success then
			Library:Notify("Successfully talked to buyer!", 3)
		else
			Library:Notify("Failed to talk to buyer!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Teleport to buyer and open dialogue'
})

local ItemSelectionGroupBox = Tabs.AutoSell:AddRightGroupbox('Item Selection')

Options.CommonItems = ItemSelectionGroupBox:AddDropdown('CommonItems', {
	Values = ItemsByRarity.Common,
	Default = 1,
	Multi = true,
	Text = 'Common Items',
	Tooltip = 'Select common items to sell',
	Callback = function(Value)
		config.selectedItems.Common = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Common, itemName)
			end
		end
	end
})

Options.UncommonItems = ItemSelectionGroupBox:AddDropdown('UncommonItems', {
	Values = ItemsByRarity.Uncommon,
	Default = 1,
	Multi = true,
	Text = 'Uncommon Items',
	Tooltip = 'Select uncommon items to sell',
	Callback = function(Value)
		config.selectedItems.Uncommon = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Uncommon, itemName)
			end
		end
	end
})

Options.RareItems = ItemSelectionGroupBox:AddDropdown('RareItems', {
	Values = ItemsByRarity.Rare,
	Default = 1,
	Multi = true,
	Text = 'Rare Items',
	Tooltip = 'Select rare items to sell',
	Callback = function(Value)
		config.selectedItems.Rare = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Rare, itemName)
			end
		end
	end
})

Options.EpicItems = ItemSelectionGroupBox:AddDropdown('EpicItems', {
	Values = ItemsByRarity.Epic,
	Default = 1,
	Multi = true,
	Text = 'Epic Items',
	Tooltip = 'Select epic items to sell',
	Callback = function(Value)
		config.selectedItems.Epic = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Epic, itemName)
			end
		end
	end
})

Options.LegendaryItems = ItemSelectionGroupBox:AddDropdown('LegendaryItems', {
	Values = ItemsByRarity.Legendary,
	Default = 1,
	Multi = true,
	Text = 'Legendary Items',
	Tooltip = 'Select legendary items to sell',
	Callback = function(Value)
		config.selectedItems.Legendary = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Legendary, itemName)
			end
		end
	end
})

Options.MythicalItems = ItemSelectionGroupBox:AddDropdown('MythicalItems', {
	Values = ItemsByRarity.Mythical,
	Default = 1,
	Multi = true,
	Text = 'Mythical Items',
	Tooltip = 'Select mythical items to sell',
	Callback = function(Value)
		config.selectedItems.Mythical = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Mythical, itemName)
			end
		end
	end
})

Options.RuneItems = ItemSelectionGroupBox:AddDropdown('RuneItems', {
	Values = ItemsByRarity.Rune,
	Default = 1,
	Multi = true,
	Text = 'Rune Items',
	Tooltip = 'Select rune items to sell',
	Callback = function(Value)
		config.selectedItems.Rune = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Rune, itemName)
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 7: TELEPORT & SETTINGS TABS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TeleportAreasBox = Tabs.Teleport:AddLeftGroupbox('Areas')

local areaOptions = {}
for areaName, _ in pairs(teleportAreas) do
	table.insert(areaOptions, areaName)
end
table.sort(areaOptions)

TeleportAreasBox:AddLabel('Select an Area:')

Options.AreaSelection = TeleportAreasBox:AddDropdown('AreaSelection', {
	Values = areaOptions,
	Default = 1,
	Multi = false,
	Tooltip = 'Choose an area to teleport to',
	Callback = function(Value)
		selectedArea = Value
	end
})

TeleportAreasBox:AddDivider()

TeleportAreasBox:AddButton({
	Text = 'Travel to Area',
	Func = function()
		if not selectedArea or selectedArea == "" then
			Library:Notify("Please select an area first!", 3)
			return
		end
		
		local position = teleportAreas[selectedArea]
		if position then
			startTeleportHover(position, selectedArea)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Hover travel to the selected area'
})

TeleportAreasBox:AddDivider()
TeleportAreasBox:AddLabel('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
TeleportAreasBox:AddLabel('NPCs:')

local npcOptions = {}
for npcName, _ in pairs(teleportNPCs) do
	table.insert(npcOptions, npcName)
end
table.sort(npcOptions)

Options.NPCSelection = TeleportAreasBox:AddDropdown('NPCSelection', {
	Values = npcOptions,
	Default = 1,
	Multi = false,
	Tooltip = 'Choose an NPC to teleport to',
	Callback = function(Value)
		selectedNPC = Value
	end
})

TeleportAreasBox:AddDivider()

TeleportAreasBox:AddButton({
	Text = 'Travel to NPC',
	Func = function()
		if not selectedNPC or selectedNPC == "" then
			Library:Notify("Please select an NPC first!", 3)
			return
		end
		
		local position = teleportNPCs[selectedNPC]
		if position then
			startTeleportHover(position, selectedNPC)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Hover travel to the selected NPC'
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WORLD 2 BOX
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local World2Box = Tabs.Teleport:AddRightGroupbox('World 2: Forgotten Kingdom')

Toggles.AutoJoinWorld2 = World2Box:AddToggle('AutoJoinWorld2', {
	Text = 'Auto-Join Forgotten Kingdom',
	Default = false,
	Tooltip = 'Automatically join Forgotten Kingdom every 5 minutes',
	Callback = function(Value)
		config.autoJoinWorld2Enabled = Value -- ADD THIS LINE AT START
		
		if Value then
			if not checkForPortalTool() then
				Library:Notify("You must unlock the Portal first!", 3)
				Toggles.AutoJoinWorld2:SetValue(false)
				config.autoJoinWorld2Enabled = false -- ADD THIS LINE
				return
			end
			
			Library:Notify("Starting in 5 seconds...", 3)
			
			task.delay(4.5, function()
				pressK()
			end)
			
			task.wait(5)
			
			if Toggles.AutoJoinWorld2.Value then
				local success = startWorld2AutoJoin()
				if not success then
					Toggles.AutoJoinWorld2:SetValue(false)
					config.autoJoinWorld2Enabled = false -- ADD THIS LINE
					pressK()
				else
					Library:Notify("World 2 Auto-Join started!", 3)
				end
			else
				pressK()
			end
		else
			stopWorld2AutoJoin()
			Library:Notify("World 2 Auto-Join stopped!", 3)
			pressK()
		end
	end
})

World2Box:AddDivider()

World2Box:AddButton({
	Text = 'Join Forgotten Kingdom',
	Func = function()
		if not checkForPortalTool() then
			Library:Notify("You must unlock the Portal first!", 3)
			return
		end
		
		Library:Notify("Teleporting to Forgotten Kingdom...", 3)
		
		pressK()
		
		task.wait(0.5)
		
		local success = teleportToWorld2()
		
		if success then
			Library:Notify("Successfully joined Forgotten Kingdom!", 3)
		else
			Library:Notify("Failed to join Forgotten Kingdom!", 3)
			task.wait(2)
			pressK()
		end
	end,
	DoubleClick = false,
	Tooltip = 'Instantly teleport to Forgotten Kingdom'
})

World2Box:AddLabel('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
World2Box:AddLabel('[Stay near Spawn]')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'K', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

MenuGroup:AddDivider()

MenuGroup:AddButton({
	Text = 'Destroy GUI',
	Func = function()
		if Toggles.FarmToggle then
			Toggles.FarmToggle:SetValue(false)
		end
		if Toggles.MineToggle then
			Toggles.MineToggle:SetValue(false)
		end
		if Toggles.AutoSellToggle then
			Toggles.AutoSellToggle:SetValue(false)
		end
		if Toggles.AutoJoinWorld2 then
			Toggles.AutoJoinWorld2:SetValue(false)
		end
		
		task.wait(0.5)
		
		if _G.KeybindConnection then
			_G.KeybindConnection:Disconnect()
			_G.KeybindConnection = nil
		end
		
		_G.AutoLoopFunctions.stopAutoAttack()
		_G.AutoLoopFunctions.stopAutoMine()
		_G.AutoLoopFunctions.stopAutoSell()
		stopWorld2AutoJoin()
		
		funcs.stopNoclip()
		funcs.cleanupPhysicsMovement()
		
		_G.MobFarmConfig = nil
		_G.FarmFunctions = nil
		_G.AutoLoopFunctions = nil
		_G.ConfigFunctions = nil
		_G.UIReferences = nil
		
		Library:Unload()
	end,
	DoubleClick = false,
	Tooltip = 'Close and destroy the GUI'
})

local GeneralSettingsBox = Tabs.Settings:AddRightGroupbox('General Settings')

Options.HoverSpeed = GeneralSettingsBox:AddSlider('HoverSpeed', {
	Text = 'Hover Speed',
	Default = 80,
	Min = 20,
	Max = 140,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.hoverSpeed = Value
	end
})

local FarmSettingsBox = Tabs.Settings:AddRightGroupbox('Farm Settings')

Options.VerticalDistance = FarmSettingsBox:AddSlider('VerticalDistance', {
	Text = 'Vertical Distance',
	Default = 8,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.verticalDistance = Value
	end
})

local MiningSettingsBox = Tabs.Settings:AddRightGroupbox('Mining Settings')

Options.MiningVerticalDistance = MiningSettingsBox:AddSlider('MiningVerticalDistance', {
	Text = 'Mining Vertical Distance',
	Default = 6,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.miningVerticalDistance = Value
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 8: CONFIG MANAGEMENT TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local configFuncs = _G.ConfigFunctions

local ConfigManagementBox = Tabs.Configs:AddLeftGroupbox('Config Management')

local selectedConfig = nil

Options.ConfigName = ConfigManagementBox:AddInput('ConfigName', {
	Default = '',
	Numeric = false,
	Finished = false,
	Text = 'Config Name',
	Tooltip = 'Enter a name for your config',
	Placeholder = 'Enter config name...',
})

Options.ConfigSelector = ConfigManagementBox:AddDropdown('ConfigSelector', {
	Values = configFuncs.getConfigList(),
	Default = 1,
	Multi = false,
	Text = 'Select Config',
	Tooltip = 'Choose a config to load/delete',
	Callback = function(Value)
		selectedConfig = Value
	end
})

ConfigManagementBox:AddDivider()

ConfigManagementBox:AddButton({
	Text = 'Refresh Configs',
	Func = function()
		local configList = configFuncs.getConfigList()
		Options.ConfigSelector:SetValues(configList)
		Library:Notify("Found " .. #configList .. " config(s)", 2)
	end,
	DoubleClick = false,
	Tooltip = 'Refresh the config list'
})

ConfigManagementBox:AddButton({
	Text = 'Create Config',
	Func = function()
		local configName = Options.ConfigName.Value
		
		if configName == "" or configName == nil then
			Library:Notify("Please enter a config name!", 3)
			return
		end
		
		configName = configName:gsub("%s+", "_")
		
		local success = configFuncs.saveConfig(configName)
		
		if success then
			Library:Notify("Config '" .. configName .. "' created!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			Options.ConfigSelector:SetValue(configName)
			selectedConfig = configName
			
			Options.ConfigName:SetValue("")
		else
			Library:Notify("Failed to create config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Create a new config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Load Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.loadConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' loaded!", 3)
			
			task.wait(0.3)
			
			if Toggles.FarmToggle then Toggles.FarmToggle:SetValue(config.enabled) end
			if Toggles.MineToggle then Toggles.MineToggle:SetValue(config.miningEnabled) end
			if Toggles.AutoSellToggle then Toggles.AutoSellToggle:SetValue(config.autoSellEnabled) end
			if Toggles.AutoJoinWorld2 then Toggles.AutoJoinWorld2:SetValue(config.autoJoinWorld2Enabled) end
			if Options.HoverSpeed then Options.HoverSpeed:SetValue(config.hoverSpeed) end
			if Options.VerticalDistance then Options.VerticalDistance:SetValue(config.verticalDistance) end
			if Options.MiningVerticalDistance then Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance) end
			if Options.LockPosition then Options.LockPosition:SetValue(config.lockPosition) end
			
			if Options.MobSelection then
				local enabledMobs = {}
				for _, mobData in ipairs(config.mobTypes) do
					if mobData.enabled then
						enabledMobs[mobData.name] = true
					end
				end
				Options.MobSelection:SetValue(enabledMobs)
			end
			
			if Options.RockSelection then
				local enabledRocks = {}
				for _, rockData in ipairs(config.rockTypes) do
					if rockData.enabled then
						enabledRocks[rockData.name] = true
					end
				end
				Options.RockSelection:SetValue(enabledRocks)
			end
			
			if Options.CommonItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Common or {}) do items[item] = true end
				Options.CommonItems:SetValue(items)
			end
			
			if Options.UncommonItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Uncommon or {}) do items[item] = true end
				Options.UncommonItems:SetValue(items)
			end
			
			if Options.RareItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Rare or {}) do items[item] = true end
				Options.RareItems:SetValue(items)
			end
			
			if Options.EpicItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Epic or {}) do items[item] = true end
				Options.EpicItems:SetValue(items)
			end
			
			if Options.LegendaryItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Legendary or {}) do items[item] = true end
				Options.LegendaryItems:SetValue(items)
			end
			
			if Options.MythicalItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Mythical or {}) do items[item] = true end
				Options.MythicalItems:SetValue(items)
			end
			
			if Options.RuneItems then
				local items = {}
				for _, item in ipairs(config.selectedItems.Rune or {}) do items[item] = true end
				Options.RuneItems:SetValue(items)
			end
			
			Library:Notify("All settings applied!", 2)
		else
			Library:Notify("Failed to load config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Load the selected config'
})

ConfigManagementBox:AddButton({
	Text = 'Overwrite Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.saveConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' overwritten!", 3)
		else
			Library:Notify("Failed to overwrite config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Overwrite selected config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Set as Autoload',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		configFuncs.setAutoload(selectedConfig)
		Library:Notify("Config '" .. selectedConfig .. "' set as autoload!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'This config will load automatically on startup'
})

ConfigManagementBox:AddButton({
	Text = 'Destroy Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local configToDelete = selectedConfig
		local success = configFuncs.deleteConfig(configToDelete)
		
		if success then
			Library:Notify("Config '" .. configToDelete .. "' deleted!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			selectedConfig = nil
		else
			Library:Notify("Failed to delete config!", 3)
		end
	end,
	DoubleClick = true,
	Tooltip = 'Double-click to delete the selected config'
})

local DebugBox = Tabs.Configs:AddRightGroupbox('Debug')

DebugBox:AddButton({
	Text = 'Print Current Config',
	Func = function()
		configFuncs.debugCurrentConfig()
		Library:Notify("Config info copied to clipboard!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'Copy current config state to clipboard'
})

local autoloadConfig = configFuncs.getAutoload()
if autoloadConfig then
	DebugBox:AddLabel('Autoload: ' .. autoloadConfig)
else
	DebugBox:AddLabel('Autoload: None')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOAD CONFIG ON STARTUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(0)
	
	local autoloadName = configFuncs.getAutoload()
	if autoloadName then
		print("ğŸ”„ Autoloading: " .. autoloadName)
		
		local success = configFuncs.loadConfig(autoloadName)
		
if success then
	task.wait(0.5)
	
	if Toggles.FarmToggle then Toggles.FarmToggle:SetValue(config.enabled) end
	if Toggles.MineToggle then Toggles.MineToggle:SetValue(config.miningEnabled) end
	if Toggles.AutoSellToggle then Toggles.AutoSellToggle:SetValue(config.autoSellEnabled) end
	if Toggles.AutoJoinWorld2 then Toggles.AutoJoinWorld2:SetValue(config.autoJoinWorld2Enabled) end -- ADD THIS LINE
	if Options.HoverSpeed then Options.HoverSpeed:SetValue(config.hoverSpeed) end
			if Options.VerticalDistance then Options.VerticalDistance:SetValue(config.verticalDistance) end
			if Options.MiningVerticalDistance then Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance) end
			if Options.LockPosition then Options.LockPosition:SetValue(config.lockPosition) end
			
			if Options.MobSelection then
				local enabledMobs = {}
				for _, mobData in ipairs(config.mobTypes) do
					if mobData.enabled then enabledMobs[mobData.name] = true end
				end
				Options.MobSelection:SetValue(enabledMobs)
			end
			
			if Options.RockSelection then
				local enabledRocks = {}
				for _, rockData in ipairs(config.rockTypes) do
					if rockData.enabled then enabledRocks[rockData.name] = true end
				end
				Options.RockSelection:SetValue(enabledRocks)
			end
			
			for rarity, optionName in pairs({
				Common = "CommonItems",
				Uncommon = "UncommonItems",
				Rare = "RareItems",
				Epic = "EpicItems",
				Legendary = "LegendaryItems",
				Mythical = "MythicalItems",
				Rune = "RuneItems"
			}) do
				if Options[optionName] then
					local items = {}
					for _, item in ipairs(config.selectedItems[rarity] or {}) do
						items[item] = true
					end
					Options[optionName]:SetValue(items)
				end
			end
			
			Library:Notify("Autoload '" .. autoloadName .. "' loaded!", 4)
			print("âœ… Autoload complete!")
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 9: KEYBINDS, MAIN LOOPS & FINALIZATION (ULTRA DEBUG VERSION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- KEYBIND SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Library:OnUnload(function()
	Library.Unloaded = true
	if _G.KeybindConnection then
		_G.KeybindConnection:Disconnect()
		_G.KeybindConnection = nil
	end
end)

task.spawn(function()
	task.wait(2)
	
	print("ğŸ® Setting up keybinds...")
	
	_G.KeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if input.KeyCode == Enum.KeyCode.F1 then
			if Toggles.FarmToggle then
				local newValue = not config.enabled
				Toggles.FarmToggle:SetValue(newValue)
				Library:Notify("Farming: " .. (newValue and "ON" or "OFF"), 2)
				print("ğŸ® F1 pressed - Farming: " .. (newValue and "ON" or "OFF"))
			end
			
		elseif input.KeyCode == Enum.KeyCode.F2 then
			if Toggles.MineToggle then
				local newValue = not config.miningEnabled
				Toggles.MineToggle:SetValue(newValue)
				Library:Notify("Mining: " .. (newValue and "ON" or "OFF"), 2)
				print("ğŸ® F2 pressed - Mining: " .. (newValue and "ON" or "OFF"))
			end
		end
	end)
	
	print("âœ… Keybinds ready: F1 = Farm | F2 = Mine")
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THEME MANAGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder('RafsoHub')
ThemeManager:ApplyToTab(Tabs.Settings)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ROCK OCCUPATION DETECTION SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local lastMessageTime = 0
local MESSAGE_COOLDOWN = 0.5

local function switchToNewRock(reason)
	if config.currentRock and config.miningEnabled then
		print("ğŸ”„ " .. reason)
		table.insert(config.ignoredRocks, config.currentRock)
		
		config.currentRock = nil
		config.lastRockDurability = nil
		config.isLockedOn = false
		
		local character = LocalPlayer.Character
		if character then
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if rootPart and config.bodyVelocity then
				config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			end
		end
	end
end

local function setupTextLabelMonitoring()
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
	if not playerGui then return end
	
	local function monitorTextLabel(textLabel)
		if not textLabel:IsA("TextLabel") then return end
		
		textLabel:GetPropertyChangedSignal("Text"):Connect(function()
			if (tick() - lastMessageTime) < MESSAGE_COOLDOWN then return end
			
			local text = textLabel.Text:lower()
			
			if text:find("someone else is already mining this rock.") or 
			   text:find("someone else") or 
			   text:find("being mined") or
			   text:find("another player") then
				
				lastMessageTime = tick()
				switchToNewRock("âš ï¸ Rock occupied by another player!")
			end
		end)
	end
	
	for _, gui in pairs(playerGui:GetDescendants()) do
		monitorTextLabel(gui)
	end
	
	playerGui.DescendantAdded:Connect(function(descendant)
		task.wait(0.05)
		monitorTextLabel(descendant)
	end)
end

task.spawn(function()
	task.wait(1)
	setupTextLabelMonitoring()
	print("âœ… Rock occupation detection active")
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEFENSE ATTACK FUNCTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function clickMouseForDefense()
	pcall(function()
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		task.wait(0.01)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN FARMING LOOP (ULTRA DEBUG VERSION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ”§ Initializing farming loop...")

local farmLoop = RunService.Heartbeat:Connect(function()
	if not config.enabled then return end
	
	if config.isRespawning then 
		print("â¸ï¸ Farming paused - respawning")
		return 
	end
	
	if not config.bodyVelocity or not config.bodyGyro then
		print("âš™ï¸ Setting up physics movement...")
		funcs.setupPhysicsMovement()
		return
	end
	
	-- Skip hover sequence
	config.hoverSequenceActive = false
	
	local needNewMob = not config.currentMob or not config.currentMob.Parent or not funcs.isValidMob(config.currentMob)
	
	if needNewMob then
		config.currentMob = funcs.getClosestMob()
		if config.currentMob then
			print("ğŸ¯ Locked onto: " .. config.currentMob.Name)
		else
			-- DEBUG: Check why no mobs found
			local character = LocalPlayer.Character
			if not character then
				print("âŒ No character found")
				return
			end
			
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if not rootPart then
				print("âŒ No HumanoidRootPart found")
				return
			end
			
			print("âš ï¸ No valid mobs found. Checking Living folder...")
			local mobCount = 0
			for _, child in pairs(Living:GetChildren()) do
				if funcs.isValidMob(child) then
					mobCount = mobCount + 1
				end
			end
			print("   Found " .. mobCount .. " valid mobs in Living folder")
			
			-- Check if any mob types are enabled
			local enabledCount = 0
			for _, mobData in ipairs(config.mobTypes) do
				if mobData.enabled then
					enabledCount = enabledCount + 1
					print("   âœ… " .. mobData.name .. " is enabled")
				end
			end
			if enabledCount == 0 then
				print("   âŒ No mob types are enabled! Enable them in the Mobs tab.")
			end
		end
		return
	end
	
	if config.currentMob then
		local lockPos = funcs.getLockPosition(config.currentMob)
		if lockPos then
			funcs.hoverToMob(lockPos, config.currentMob)
		else
			print("âŒ Failed to get lock position for mob")
		end
	end
end)

print("âœ… Farming loop active")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN MINING LOOP (ULTRA DEBUG VERSION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ”§ Initializing mining loop...")

local miningLoop = RunService.Heartbeat:Connect(function()
	if not config.miningEnabled then 
		if config.currentRock then
			config.currentRock = nil
			config.lastRockDurability = nil
			config.isLockedOn = false
		end
		if config.defendingAgainstMob then
			config.defendingAgainstMob = nil
			config.savedMiningRock = nil
			config.weaponEquipped = false
		end
		return 
	end
	
	if config.isRespawning then
		print("â¸ï¸ Mining paused - respawning")
		return
	end
	
	if not config.bodyVelocity or not config.bodyGyro then
		print("âš™ï¸ Setting up physics movement...")
		funcs.setupPhysicsMovement()
		return
	end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end
	
	-- Skip hover sequence
	config.hoverSequenceActive = false
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MINING DEFENSE SYSTEM
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	if config.miningDefenseEnabled then
		local closestThreat = nil
		local closestDistance = config.miningDefenseDistance
		
		for _, child in pairs(Living:GetChildren()) do
			if funcs.isValidMob(child) then
				local mobRoot = child:FindFirstChild("HumanoidRootPart")
				if mobRoot then
					local distance = (rootPart.Position - mobRoot.Position).Magnitude
					if distance < closestDistance then
						closestThreat = child
						closestDistance = distance
					end
				end
			end
		end
		
		if closestThreat and not config.defendingAgainstMob then
			print("ğŸ›¡ï¸ DEFENSE MODE: Attacking " .. closestThreat.Name)
			config.defendingAgainstMob = closestThreat
			config.savedMiningRock = config.currentRock
			config.currentRock = nil
			config.isLockedOn = false
			config.weaponEquipped = false
			
			if pickaxeCheckLoop then
				pickaxeCheckLoop:Disconnect()
				pickaxeCheckLoop = nil
			end
			
			return
		end
		
		if closestThreat and config.defendingAgainstMob then
			config.defendingAgainstMob = closestThreat
		end
	end
	
	if config.defendingAgainstMob then
		if not config.defendingAgainstMob.Parent or not funcs.isValidMob(config.defendingAgainstMob) then
			print("âœ… Threat eliminated - resuming mining")
			config.defendingAgainstMob = nil
			config.weaponEquipped = false
			config.isLockedOn = false
			
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid:UnequipTools()
				task.wait(0.2)
			end
			
			config.currentRock = config.savedMiningRock
			config.savedMiningRock = nil
			
			_G.AutoLoopFunctions.startAutoMine()
			
			return
		end
		
		if not config.weaponEquipped then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid:UnequipTools()
				task.wait(0.2)
			end
			
			local backpack = LocalPlayer:FindFirstChild("Backpack")
			if backpack then
				local weapon = backpack:FindFirstChild("Weapon")
				if weapon and weapon:IsA("Tool") then
					humanoid:EquipTool(weapon)
					task.wait(0.3)
					config.weaponEquipped = true
				end
			end
			return
		end
		
		local lockPos = funcs.getLockPosition(config.defendingAgainstMob)
		if lockPos then
			local distance = (rootPart.Position - lockPos).Magnitude
			
			funcs.hoverToMob(lockPos, config.defendingAgainstMob)
			
			if distance < 3 then
				config.isLockedOn = true
				
				local currentTime = tick()
				if currentTime - config.lastDefenseAttackTime >= config.defenseAttackCooldown then
					config.lastDefenseAttackTime = currentTime
					clickMouseForDefense()
				end
			end
		end
		
		return
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- NORMAL MINING MODE
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	if config.currentRock and (not config.currentRock.Parent or not funcs.isValidRock(config.currentRock)) then
		print("âš ï¸ Rock destroyed or invalid")
		config.currentRock = nil
		config.lastRockDurability = nil
		return
	end
	
	if not config.currentRock then
		config.currentRock = funcs.getClosestRock()
		
		if config.currentRock then
			print("â›ï¸ Locked onto rock: " .. config.currentRock.Name)
			config.lastRockDurability = funcs.getRockDurability(config.currentRock)
			config.rockDurabilityCheck = tick()
			funcs.makeRockTransparent(config.currentRock)
		else
			-- DEBUG: Check why no rocks found
			print("âš ï¸ No valid rocks found. Checking Rocks folder...")
			
			local rocksFolder = workspace:FindFirstChild("Rocks")
			if not rocksFolder then
				print("   âŒ Rocks folder not found in workspace!")
				return
			end
			
			-- Check if any rock types are enabled
			local enabledCount = 0
			for _, rockData in ipairs(config.rockTypes) do
				if rockData.enabled then
					enabledCount = enabledCount + 1
					print("   âœ… " .. rockData.name .. " is enabled")
				end
			end
			if enabledCount == 0 then
				print("   âŒ No rock types are enabled! Enable them in the Mine tab.")
			end
		end
		return
	end
	
	if config.currentRock then
		local rockPos = funcs.getMiningPosition(config.currentRock)
		if rockPos then
			funcs.hoverToRock(rockPos, config.currentRock)
		else
			print("âŒ Failed to get mining position for rock")
		end
	end
end)

print("âœ… Mining loop active")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CHARACTER RESPAWN HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LocalPlayer.CharacterAdded:Connect(function(character)
	print("ğŸ’€ Character respawned - resetting state")
	
	config.currentMob = nil
	config.currentRock = nil
	config.isLockedOn = false
	config.isRespawning = true
	config.hoverSequenceActive = false
	config.defendingAgainstMob = nil
	config.savedMiningRock = nil
	config.weaponEquipped = false
	
	funcs.cleanupPhysicsMovement()
	funcs.stopNoclip()
	
	local wasFarming = config.enabled
	local wasMining = config.miningEnabled
	
	if wasFarming or wasMining then
		character:WaitForChild("HumanoidRootPart", 10)
		task.wait(2)
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if rootPart then
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			
			if wasFarming then 
				funcs.autoEquipWeapon()
				print("ğŸ—¡ï¸ Weapon equipped")
			end
			if wasMining then 
				funcs.autoEquipPickaxe()
				config.ignoredRocks = {}
				config.lastRockDurability = nil
				config.rockDurabilityCheck = tick()
				print("â›ï¸ Pickaxe equipped")
			end
		end
		
		config.isRespawning = false
	else
		config.isRespawning = false
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(0.5)
	funcs.talkToSeller()
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FINAL CHECKS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.wait(1)

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("âœ… SCRIPT FULLY LOADED!")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("ğŸ® Controls:")
print("   F1 = Toggle Farming")
print("   F2 = Toggle Mining")
print("   K  = Toggle Menu")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("âš ï¸ IMPORTANT:")
print("   1. Select mobs in the 'Mobs' tab")
print("   2. Select rocks in the 'Mine' tab")
print("   3. Then press F1/F2 to start!")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
