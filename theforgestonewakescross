-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RAFSO'S SCRIPT - PART 1: CORE SETUP & CONFIG (WORLD 1: STONEWAKE'S CROSS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER POSITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Vector3.new(-44.71, -5.12, -273.02)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_POSITION = Vector3.new(-113.83, 37.54, -35.20)
local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498

local originalPosition = nil

-- Remote for selling
local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ITEMS BY RARITY (FOR AUTOSELL)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ItemsByRarity = {
	Common = {
		"Stone",
		"Sand Stone",
		"Copper",
		"Iron",
		"Cardboardite"
	},
	Uncommon = {
		"Cobalt",
		"Titanium",
		"Lapis Lazuli",
		"Tin",
		"Silver",
		"Gold",
		"Bananite"
	},
	Rare = {
		"Volcanic Rock",
		"Quartz",
		"Amethyst",
		"Boneite",
		"Dark Boneite",
		"Topaz",
		"Diamond",
		"Sapphire",
		"Mushroomite",
		"Platinum"
	},
	Epic = {
		"Aite",
		"Slimite",
		"Poopite",
		"Cuprite",
		"Obsidian",
		"Emerald",
		"Ruby",
		"Rivalite"
	},
	Legendary = {
		"Uranium",
		"Mythril",
		"Eye Ore",
		"Fireite",
		"Magmaite",
		"Lightite"
	},
	Mythical = {
		"Demonite",
		"Darkryte"
	},
	Rune = {
		"Frost Speck",
		"Venom Crumb",
		"Blast Chip",
		"Miner Shard",
		"Flame Spark",
		"Drain Edge",
		"Briar Notch",
		"Ward Patch",
		"Rot Stich",
		"Chill Dust",
		"Rage Mark"
	}
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFIG SAVE/LOAD SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local CONFIG_FOLDER = "RafsoHubConfigs_World1"
local CONFIG_LIST_FILE = CONFIG_FOLDER .. "/ConfigList.json"
local AUTOLOAD_FILE = CONFIG_FOLDER .. "/AutoLoad.txt"

-- Config log storage
local configLog = ""

local function addToLog(message)
	configLog = configLog .. message .. "\n"
end

local function clearLog()
	configLog = ""
end

-- Ensure config folder exists
if not isfolder(CONFIG_FOLDER) then
	makefolder(CONFIG_FOLDER)
end

-- Save configuration
local function saveConfig(configName)
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ’¾ SAVING CONFIG: " .. configName)
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Capture current state
	local configData = {
		-- Farming settings
		enabled = _G.MobFarmConfig.enabled,
		behindDistance = _G.MobFarmConfig.behindDistance,
		verticalDistance = _G.MobFarmConfig.verticalDistance,
		farmDistance = _G.MobFarmConfig.farmDistance,
		hoverSpeed = _G.MobFarmConfig.hoverSpeed,
		lockPosition = _G.MobFarmConfig.lockPosition,
		aboveAngle = _G.MobFarmConfig.aboveAngle,
		belowAngle = _G.MobFarmConfig.belowAngle,
		
		-- Mob types
		mobTypes = {},
		
		-- Mining settings
		miningEnabled = _G.MobFarmConfig.miningEnabled,
		miningVerticalDistance = _G.MobFarmConfig.miningVerticalDistance,
		miningAngle = _G.MobFarmConfig.miningAngle,
		
		-- Rock types
		rockTypes = {},
		
		-- AutoSell settings
		autoSellEnabled = _G.MobFarmConfig.autoSellEnabled,
		selectedItems = _G.MobFarmConfig.selectedItems,
	}
	
	addToLog("ğŸ“Š Current settings being saved:")
	addToLog("  Farming Enabled: " .. tostring(configData.enabled))
	addToLog("  Mining Enabled: " .. tostring(configData.miningEnabled))
	addToLog("  AutoSell Enabled: " .. tostring(configData.autoSellEnabled))
	addToLog("  Hover Speed: " .. configData.hoverSpeed)
	addToLog("  Vertical Distance: " .. configData.verticalDistance)
	addToLog("  Mining Vertical Distance: " .. configData.miningVerticalDistance)
	addToLog("  Lock Position: " .. configData.lockPosition)
	
	-- Save mob types
	local enabledMobCount = 0
	for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
		table.insert(configData.mobTypes, {
			name = mobData.name,
			enabled = mobData.enabled,
			priority = mobData.priority
		})
		if mobData.enabled then
			addToLog("  âœ… Mob: " .. mobData.name)
			enabledMobCount = enabledMobCount + 1
		end
	end
	addToLog("Total enabled mobs: " .. enabledMobCount)
	
	-- Save rock types
	local enabledRockCount = 0
	for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
		table.insert(configData.rockTypes, {
			name = rockData.name,
			enabled = rockData.enabled,
			priority = rockData.priority
		})
		if rockData.enabled then
			addToLog("  â›ï¸ Rock: " .. rockData.name)
			enabledRockCount = enabledRockCount + 1
		end
	end
	addToLog("Total enabled rocks: " .. enabledRockCount)
	
	-- Config: Print AutoSell items
	addToLog("ğŸ’° AutoSell items:")
	local totalItems = 0
	for rarity, items in pairs(configData.selectedItems) do
		if #items > 0 then
			addToLog("  " .. rarity .. " (" .. #items .. "): " .. table.concat(items, ", "))
			totalItems = totalItems + #items
		end
	end
	addToLog("Total AutoSell items: " .. totalItems)
	
	-- Write to file
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	local success, err = pcall(function()
		local jsonData = game:GetService("HttpService"):JSONEncode(configData)
		writefile(configPath, jsonData)
	end)
	
	if not success then
		addToLog("âŒ Failed to write config file: " .. tostring(err))
		setclipboard(configLog)
		return false
	end
	
	addToLog("âœ… Config file written to: " .. configPath)
	
	-- Update config list
	local configList = {}
	if isfile(CONFIG_LIST_FILE) then
		local listSuccess, listData = pcall(function()
			return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
		end)
		if listSuccess then
			configList = listData
		end
	end
	
	if not table.find(configList, configName) then
		table.insert(configList, configName)
		writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
		addToLog("âœ… Added to config list")
	end
	
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("âœ… CONFIG SAVED SUCCESSFULLY")
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	setclipboard(configLog)
	return true
end

-- Load configuration
local function loadConfig(configName)
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ“‚ LOADING CONFIG: " .. configName)
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	
	if not isfile(configPath) then
		addToLog("âŒ Config file not found: " .. configPath)
		setclipboard(configLog)
		return false
	end
	
	addToLog("âœ… Config file exists")
	
	local success, configData = pcall(function()
		local fileContent = readfile(configPath)
		return game:GetService("HttpService"):JSONDecode(fileContent)
	end)
	
	if not success then
		addToLog("âŒ Failed to parse config JSON: " .. tostring(configData))
		setclipboard(configLog)
		return false
	end
	
	addToLog("âœ… Config JSON parsed successfully")
	
	-- Apply basic settings
	_G.MobFarmConfig.enabled = configData.enabled or false
	_G.MobFarmConfig.miningEnabled = configData.miningEnabled or false
	_G.MobFarmConfig.autoSellEnabled = configData.autoSellEnabled or false
	_G.MobFarmConfig.behindDistance = configData.behindDistance or 8
	_G.MobFarmConfig.verticalDistance = configData.verticalDistance or 8
	_G.MobFarmConfig.farmDistance = configData.farmDistance or 1000
	_G.MobFarmConfig.hoverSpeed = configData.hoverSpeed or 80
	_G.MobFarmConfig.lockPosition = configData.lockPosition or "Below"
	_G.MobFarmConfig.aboveAngle = configData.aboveAngle or 90
	_G.MobFarmConfig.belowAngle = configData.belowAngle or 240
	
	addToLog("ğŸ“Š Settings loaded:")
	addToLog("  Farming Enabled: " .. tostring(_G.MobFarmConfig.enabled))
	addToLog("  Mining Enabled: " .. tostring(_G.MobFarmConfig.miningEnabled))
	addToLog("  AutoSell Enabled: " .. tostring(_G.MobFarmConfig.autoSellEnabled))
	addToLog("  Hover Speed: " .. _G.MobFarmConfig.hoverSpeed)
	addToLog("  Vertical Distance: " .. _G.MobFarmConfig.verticalDistance)
	addToLog("  Lock Position: " .. _G.MobFarmConfig.lockPosition)
	
	-- Apply mob types
	local loadedMobCount = 0
	if configData.mobTypes then
		for i, savedMob in ipairs(configData.mobTypes) do
			if _G.MobFarmConfig.mobTypes[i] then
				_G.MobFarmConfig.mobTypes[i].enabled = savedMob.enabled
				if savedMob.enabled then
					addToLog("  âœ… Enabled mob: " .. savedMob.name)
					loadedMobCount = loadedMobCount + 1
				end
			end
		end
	end
	addToLog("Total mobs enabled: " .. loadedMobCount)
	
	-- Apply mining settings
	_G.MobFarmConfig.miningVerticalDistance = configData.miningVerticalDistance or 6
	_G.MobFarmConfig.miningAngle = configData.miningAngle or 270
	
	addToLog("â›ï¸ Mining settings loaded:")
	addToLog("  Mining Vertical Distance: " .. _G.MobFarmConfig.miningVerticalDistance)
	
	-- Apply rock types
	local loadedRockCount = 0
	if configData.rockTypes then
		for i, savedRock in ipairs(configData.rockTypes) do
			if _G.MobFarmConfig.rockTypes[i] then
				_G.MobFarmConfig.rockTypes[i].enabled = savedRock.enabled
				if savedRock.enabled then
					addToLog("  âœ… Enabled rock: " .. savedRock.name)
					loadedRockCount = loadedRockCount + 1
				end
			end
		end
	end
	addToLog("Total rocks enabled: " .. loadedRockCount)
	
	-- Apply autosell items
	if configData.selectedItems then
		_G.MobFarmConfig.selectedItems = configData.selectedItems
		
		addToLog("ğŸ’° AutoSell items loaded:")
		local totalItems = 0
		for rarity, items in pairs(configData.selectedItems) do
			if #items > 0 then
				addToLog("  " .. rarity .. " (" .. #items .. "): " .. table.concat(items, ", "))
				totalItems = totalItems + #items
			end
		end
		addToLog("Total AutoSell items: " .. totalItems)
	end
	
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("âœ… CONFIG LOADED SUCCESSFULLY")
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	setclipboard(configLog)
	return true
end

-- Get list of saved configs
local function getConfigList()
	if not isfile(CONFIG_LIST_FILE) then
		return {}
	end
	
	local success, configList = pcall(function()
		return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
	end)
	
	if success then
		return configList
	else
		return {}
	end
end

-- Delete configuration
local function deleteConfig(configName)
	clearLog()
	addToLog("ğŸ—‘ï¸ Deleting config: " .. configName)
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	
	if isfile(configPath) then
		delfile(configPath)
		addToLog("âœ… Deleted config file")
	end
	
	-- Update config list
	local configList = getConfigList()
	for i, name in ipairs(configList) do
		if name == configName then
			table.remove(configList, i)
			writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
			addToLog("âœ… Removed from config list")
			break
		end
	end
	
	-- Remove autoload if it was this config
	if isfile(AUTOLOAD_FILE) and readfile(AUTOLOAD_FILE) == configName then
		delfile(AUTOLOAD_FILE)
		addToLog("âœ… Removed from autoload")
	end
	
	addToLog("âœ… Config deleted successfully")
	setclipboard(configLog)
	return true
end

-- Set autoload config
local function setAutoload(configName)
	clearLog()
	writefile(AUTOLOAD_FILE, configName)
	addToLog("ğŸ”„ Autoload set to: " .. configName)
	addToLog("ğŸ“ Written to: " .. AUTOLOAD_FILE)
	setclipboard(configLog)
end

-- Get autoload config
local function getAutoload()
	if isfile(AUTOLOAD_FILE) then
		local autoloadName = readfile(AUTOLOAD_FILE)
		return autoloadName
	end
	return nil
end

-- Config function to print current config state
local function debugCurrentConfig()
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ” CURRENT CONFIG STATE")
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("Farming Enabled: " .. tostring(_G.MobFarmConfig.enabled))
	addToLog("Mining Enabled: " .. tostring(_G.MobFarmConfig.miningEnabled))
	addToLog("AutoSell Enabled: " .. tostring(_G.MobFarmConfig.autoSellEnabled))
	addToLog("Hover Speed: " .. _G.MobFarmConfig.hoverSpeed)
	addToLog("Vertical Distance: " .. _G.MobFarmConfig.verticalDistance)
	addToLog("Mining Vertical Distance: " .. _G.MobFarmConfig.miningVerticalDistance)
	addToLog("Lock Position: " .. _G.MobFarmConfig.lockPosition)
	
	addToLog("\nEnabled Mobs:")
	local mobCount = 0
	for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
		if mobData.enabled then
			addToLog("  - " .. mobData.name)
			mobCount = mobCount + 1
		end
	end
	if mobCount == 0 then
		addToLog("  (none)")
	end
	
	addToLog("\nEnabled Rocks:")
	local rockCount = 0
	for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
		if rockData.enabled then
			addToLog("  - " .. rockData.name)
			rockCount = rockCount + 1
		end
	end
	if rockCount == 0 then
		addToLog("  (none)")
	end
	
	addToLog("\nAutoSell Items:")
	local itemCount = 0
	for rarity, items in pairs(_G.MobFarmConfig.selectedItems) do
		if #items > 0 then
			addToLog("  " .. rarity .. ": " .. table.concat(items, ", "))
			itemCount = itemCount + #items
		end
	end
	if itemCount == 0 then
		addToLog("  (none)")
	end
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	setclipboard(configLog)
end

-- Store config functions globally
_G.ConfigFunctions = {
	saveConfig = saveConfig,
	loadConfig = loadConfig,
	getConfigList = getConfigList,
	deleteConfig = deleteConfig,
	setAutoload = setAutoload,
	getAutoload = getAutoload,
	debugCurrentConfig = debugCurrentConfig
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GLOBAL CONFIG (WITH MINING DEFENSE VARIABLES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
_G.MobFarmConfig = {
	-- Farming settings
	enabled = false,
	behindDistance = 8,
	verticalDistance = 8,
	farmDistance = 1000,
	hoverSpeed = 80,
	lockPosition = "Below",
	aboveAngle = 90,
	belowAngle = 240,
	
	-- Hover sequence
	hoverSequenceActive = false,
	currentHoverTarget = 1,
	hoverReachedThreshold = 3,
	hoverPosition1 = nil,
	
	-- Attack settings
	weaponRemote = nil,
	lastAttackTime = 0,
	attackCooldown = 0.25,
	lastWeaponCheckTime = 0,
	weaponCheckInterval = 0.5,
	
	-- State
	currentMob = nil,
	isLockedOn = false,
	bodyVelocity = nil,
	bodyGyro = nil,
	noclipLoop = nil,
	isRespawning = false,
	
	-- Mob types (World 1: Stonewake's Cross)
	mobTypes = {
		{name = "Brute Zombie", pattern = "^Brute Zombie%d+$", enabled = false, priority = 1},
		{name = "Elite Zombie", pattern = "^Elite Zombie%d+$", enabled = false, priority = 2},
		{name = "Delver Zombie", pattern = "^Delver Zombie%d+$", enabled = false, priority = 3},
		{name = "Zombie", pattern = "^Zombie%d+$", enabled = false, priority = 4},
	},
	
	-- Mining system
	miningEnabled = false,
	miningVerticalDistance = 6,
	miningAngle = 270,
	currentRock = nil,
	lastMineTime = 0,
	miningCooldown = 0.1,
	lastPickaxeCheckTime = 0,
	pickaxeCheckInterval = 0.5,
	miningBodyVelocity = nil,
	miningBodyGyro = nil,
	
	-- Mining defense system (NEW - CRITICAL FOR DEFENSE TO WORK)
	miningDefenseEnabled = true,
	miningDefenseDistance = 10,
	defendingAgainstMob = nil,
	savedMiningRock = nil,
	weaponEquipped = false,
	lastDefenseAttackTime = 0,
	defenseAttackCooldown = 0.1,
	
	-- Rock damage tracking
	rockDurabilityCheck = 0,
	rockDurabilityCheckInterval = 3,
	lastRockDurability = nil,
	ignoredRocks = {},
	
	-- Rock types (World 1: Stonewake's Cross)
	rockTypes = {
		{name = "Boulder", enabled = false, priority = 1},
		{name = "Rock", enabled = false, priority = 2},
		{name = "Pebble", enabled = false, priority = 3},
	},
	
	-- AutoSell settings
	autoSellEnabled = false,
	sellCooldown = 1.5,
	lastSellTime = 0,
	autoClickerActive = false,
	autoClickerLoop = nil,
	selectedItems = {
		Common = {},
		Uncommon = {},
		Rare = {},
		Epic = {},
		Legendary = {},
		Mythical = {},
		Rune = {}
	}
}

local config = _G.MobFarmConfig

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 2: NOCLIP & MOB/ROCK DETECTION (COMPLETE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")
local config = _G.MobFarmConfig

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startNoclip()
	if config.noclipLoop then return end
	
	config.noclipLoop = RunService.Stepped:Connect(function()
		local isTeleporting = _G.teleportHoverActive == true
		
		if not config.enabled and not config.miningEnabled and not isTeleporting then 
			return 
		end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end)
end

local function stopNoclip()
	if config.noclipLoop then
		config.noclipLoop:Disconnect()
		config.noclipLoop = nil
		
		local character = LocalPlayer.Character
		if character then
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					part.CanCollide = true
				end
			end
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOB DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidMob(mob)
	local humanoid = mob:FindFirstChildOfClass("Humanoid")
	local rootPart = mob:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not rootPart then return false end
	if humanoid.Health <= 0 then return false end
	if Players:GetPlayerFromCharacter(mob) then return false end
	
	return true
end

local function matchesMobPattern(mobName, pattern)
	return string.match(mobName, pattern) ~= nil
end

local function getMobPriority(mob)
	for _, mobData in ipairs(config.mobTypes) do
		if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
			return mobData.priority
		end
	end
	return 999
end

local function getClosestMob()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return nil end
	
	local closestMob = nil
	local closestDistance = config.farmDistance
	local highestPriority = 999
	
	for _, child in pairs(Living:GetChildren()) do
		if isValidMob(child) then
			for _, mobData in pairs(config.mobTypes) do
				if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
					local mobRoot = child:FindFirstChild("HumanoidRootPart")
					if mobRoot then
						local distance = (rootPart.Position - mobRoot.Position).Magnitude
						local priority = getMobPriority(child)
						
						if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
							closestMob = child
							closestDistance = distance
							highestPriority = priority
						end
					end
					break
				end
			end
		end
	end
	
	return closestMob
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ROCK DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidRock(durabilityModel)
	if not durabilityModel:IsA("Model") then return false end
	if not durabilityModel.Parent then return false end
	
	local hasMeshPart = durabilityModel:FindFirstChildOfClass("MeshPart") ~= nil
	
	return hasMeshPart
end

local function isRockIgnored(rock)
	for _, ignoredRock in ipairs(config.ignoredRocks) do
		if ignoredRock == rock then
			return true
		end
	end
	return false
end

local function getRockPriority(rockTypeName)
	for _, rockData in ipairs(config.rockTypes) do
		if rockData.enabled and rockTypeName == rockData.name then
			return rockData.priority
		end
	end
	return 999
end

local function getRockPosition(durabilityModel)
	local rockPart = durabilityModel:FindFirstChild("Rock")
	if rockPart and rockPart:IsA("BasePart") then
		return rockPart
	end
	
	local rockTypeModel = durabilityModel.Parent
	if rockTypeModel then
		local hitbox = rockTypeModel:FindFirstChild("Hitbox")
		if hitbox and hitbox:IsA("BasePart") then
			return hitbox
		end
	end
	
	local meshPart = durabilityModel:FindFirstChildOfClass("MeshPart")
	if meshPart then
		return meshPart
	end
	
	return nil
end

local function getRockDurability(rock)
	if not rock then return nil end
	return tonumber(rock.Name)
end

local function getClosestRock()
	local character = LocalPlayer.Character
	if not character then 
		return nil 
	end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then 
		return nil 
	end
	
	local rocksFolder = workspace:FindFirstChild("Rocks")
	if not rocksFolder then
		return nil
	end
	
	local closestRock = nil
	local closestDistance = config.farmDistance
	local highestPriority = 999
	
	for _, islandFolder in pairs(rocksFolder:GetChildren()) do
		if islandFolder:IsA("Folder") then
			for _, spawnPart in pairs(islandFolder:GetChildren()) do
				if spawnPart:IsA("Part") and spawnPart.Name == "SpawnLocation" then
					for _, rockTypeModel in pairs(spawnPart:GetChildren()) do
						if rockTypeModel:IsA("Model") then
							local rockTypeName = rockTypeModel.Name
							local priority = getRockPriority(rockTypeName)
							
							if priority < 999 then
								for _, durabilityModel in pairs(rockTypeModel:GetChildren()) do
									if durabilityModel:IsA("Model") and tonumber(durabilityModel.Name) then
										if not isRockIgnored(durabilityModel) and isValidRock(durabilityModel) then
											local positionPart = getRockPosition(durabilityModel)
											if positionPart then
												local distance = (rootPart.Position - positionPart.Position).Magnitude
												
												if distance <= config.farmDistance then
													if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
														closestRock = durabilityModel
														closestDistance = distance
														highestPriority = priority
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	
	return closestRock
end

local function makeRockTransparent(rock)
	if not rock then return end
	
	for _, descendant in pairs(rock:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			descendant.Transparency = 0.7
		end
	end
	
	local rockTypeModel = rock.Parent
	if rockTypeModel then
		for _, descendant in pairs(rockTypeModel:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				descendant.Transparency = 0.7
			end
		end
	end
end

-- Store functions globally
_G.FarmFunctions = {
	startNoclip = startNoclip,
	stopNoclip = stopNoclip,
	getClosestMob = getClosestMob,
	getClosestRock = getClosestRock,
	isValidMob = isValidMob,
	isValidRock = isValidRock,
	getRockPosition = getRockPosition,
	getRockDurability = getRockDurability,
	isRockIgnored = isRockIgnored,
	makeRockTransparent = makeRockTransparent,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 3: WEAPON SYSTEM, AUTOSELL & PHYSICS MOVEMENT (COMPLETE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WEAPON & TOOL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function autoEquipWeapon()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local weaponInChar = character:FindFirstChild("Weapon")
	if weaponInChar and weaponInChar:IsA("Tool") then
		return true
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local weapon = backpack:FindFirstChild("Weapon")
		if weapon and weapon:IsA("Tool") then
			humanoid:EquipTool(weapon)
			task.wait(0.2)
			return true
		end
	end
	
	return false
end

local function autoEquipPickaxe()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local pickaxeInChar = character:FindFirstChild("Pickaxe")
	if pickaxeInChar and pickaxeInChar:IsA("Tool") then
		return true
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local pickaxe = backpack:FindFirstChild("Pickaxe")
		if pickaxe and pickaxe:IsA("Tool") then
			humanoid:EquipTool(pickaxe)
			task.wait(0.2)
			return true
		end
	end
	
	return false
end

local function clickMouse()
	local success = pcall(function()
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		task.wait(0.01)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end)
	return success
end

local function performAttack()
	if not config.isLockedOn or not config.currentMob or config.hoverSequenceActive then
		return
	end
	
	local currentTime = tick()
	if currentTime - config.lastAttackTime < config.attackCooldown then
		return
	end
	
	config.lastAttackTime = currentTime
	clickMouse()
end

local function performMine()
	if not config.currentRock then return end
	if not config.miningEnabled then return end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local pickaxe = character:FindFirstChild("Pickaxe")
	if not pickaxe then
		autoEquipPickaxe()
		return
	end
	
	local currentTime = tick()
	if currentTime - config.lastMineTime < config.miningCooldown then
		return
	end
	
	config.lastMineTime = currentTime
	clickMouse()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_POSITION = Vector3.new(-113.83, 37.54, -35.20)
local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498
local originalPosition = nil

local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

local function startAutoClickerAt(x, y, duration)
	if config.autoClickerActive then return end
	
	config.autoClickerActive = true
	
	config.autoClickerLoop = task.spawn(function()
		local startTime = tick()
		local clicks = 0
		while config.autoClickerActive and (tick() - startTime) < duration do
			VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
			task.wait(0.01)
			VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
			clicks = clicks + 1
			task.wait(0.05)
		end
		config.autoClickerActive = false
	end)
end

local function stopAutoClicker()
	config.autoClickerActive = false
	if config.autoClickerLoop then
		task.cancel(config.autoClickerLoop)
		config.autoClickerLoop = nil
	end
end

local function closeChat()
	task.wait(0.3)
	startAutoClickerAt(NO_BUTTON_X, NO_BUTTON_Y, 3)
	task.wait(0.3)
	stopAutoClicker()
end

local function talkToSeller()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	originalPosition = rootPart.CFrame
	
	rootPart.CFrame = CFrame.new(SELLER_POSITION)
	task.wait(0.5)
	
	if SELLER_PROXIMITY then
		fireproximityprompt(SELLER_PROXIMITY)
		task.wait(0.5)
		closeChat()
		task.wait(0)
		
		if originalPosition then
			rootPart.CFrame = originalPosition
		end
		
		return true
	end
	
	return false
end

local function getItemQuantity(itemName)
	local success, quantity = pcall(function()
		local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
		if not playerGui then return 0 end
		
		local menu = playerGui:FindFirstChild("Menu")
		if not menu then return 0 end
		
		local stash = menu:FindFirstChild("Frame", true)
		if stash then
			stash = stash:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Menus", true)
				if stash then
					stash = stash:FindFirstChild("Stash", true)
					if stash then
						stash = stash:FindFirstChild("Background", true)
						if stash then
							for _, itemFolder in pairs(stash:GetChildren()) do
								if itemFolder:IsA("Folder") or itemFolder:IsA("Frame") then
									local main = itemFolder:FindFirstChild("Main")
									if main then
										if itemFolder.Name == itemName then
											local quantityLabel = main:FindFirstChild("Quantity")
											if quantityLabel and quantityLabel:IsA("TextLabel") then
												local quantityText = quantityLabel.Text
												local number = tonumber(string.match(quantityText, "%d+"))
												return number or 0
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		
		return 0
	end)
	
	if success then
		return quantity
	else
		return 0
	end
end

local function sellItems()
	if not config.autoSellEnabled then return end
	
	local currentTime = tick()
	if currentTime - config.lastSellTime < config.sellCooldown then
		return
	end
	
	local itemsToSell = {}
	
	for rarity, items in pairs(config.selectedItems) do
		if rarity ~= "Rune" then
			for _, itemName in ipairs(items) do
				local quantity = getItemQuantity(itemName)
				
				if quantity > 0 then
					itemsToSell[itemName] = quantity
				end
			end
		end
	end
	
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
	if playerGui then
		local menu = playerGui:FindFirstChild("Menu")
		if menu then
			local stash = menu:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Frame", true)
				if stash then
					stash = stash:FindFirstChild("Menus", true)
					if stash then
						stash = stash:FindFirstChild("Stash", true)
						if stash then
							stash = stash:FindFirstChild("Background", true)
							if stash then
								for _, itemFolder in pairs(stash:GetChildren()) do
									local main = itemFolder:FindFirstChild("Main")
									if main then
										local itemNameLabel = main:FindFirstChild("ItemName")
										if itemNameLabel and itemNameLabel:IsA("TextLabel") then
											local itemName = itemNameLabel.Text
											
											for _, selectedRuneName in ipairs(config.selectedItems.Rune) do
												if itemName == selectedRuneName then
													itemsToSell[itemFolder.Name] = 1
													break
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	
	if next(itemsToSell) == nil then
		return
	end
	
	local success, err = pcall(function()
		RunCommand:InvokeServer("SellConfirm", {Basket = itemsToSell})
	end)
	
	if success then
		config.lastSellTime = currentTime
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function setupPhysicsMovement()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	if config.bodyVelocity then
		config.bodyVelocity:Destroy()
	end
	if config.bodyGyro then
		config.bodyGyro:Destroy()
	end
	
	local bv = Instance.new("BodyVelocity")
	bv.Name = "FarmVelocity"
	bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	bv.Velocity = Vector3.new(0, 0, 0)
	bv.P = 1250
	bv.Parent = rootPart
	config.bodyVelocity = bv
	
	local bg = Instance.new("BodyGyro")
	bg.Name = "FarmGyro"
	bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
	bg.P = 30000
	bg.D = 1000
	bg.Parent = rootPart
	config.bodyGyro = bg
	
	rootPart.Anchored = false
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	end
	
	return true
end

local function cleanupPhysicsMovement()
	if config.bodyVelocity then
		config.bodyVelocity:Destroy()
		config.bodyVelocity = nil
	end
	if config.bodyGyro then
		config.bodyGyro:Destroy()
		config.bodyGyro = nil
	end
	
	local character = LocalPlayer.Character
	if character then
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if rootPart then
			rootPart.Anchored = false
			rootPart.Velocity = Vector3.new(0, 0, 0)
		end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
			task.wait(0.1)
			humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
		end
	end
	
	config.isLockedOn = false
end

-- Add to global functions
funcs.autoEquipWeapon = autoEquipWeapon
funcs.autoEquipPickaxe = autoEquipPickaxe
funcs.performAttack = performAttack
funcs.performMine = performMine
funcs.setupPhysicsMovement = setupPhysicsMovement
funcs.cleanupPhysicsMovement = cleanupPhysicsMovement
funcs.talkToSeller = talkToSeller
funcs.sellItems = sellItems

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 4: MOVEMENT LOGIC & HOVERING (COMPLETE WITH FIXES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_POSITION_2 = Vector3.new(-44.71, -5.12, -273.02)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- POSITION CALCULATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getLockPosition(mob)
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	if not mobRoot then return nil end
	
	local distance = config.behindDistance
	local verticalDist = config.verticalDistance
	local mobPos = mobRoot.Position
	local targetPos
	
	if config.lockPosition == "Back" then
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	elseif config.lockPosition == "Front" then
		local frontOffset = mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + frontOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	elseif config.lockPosition == "Above" then
		targetPos = mobPos + Vector3.new(0, verticalDist, 0)
	elseif config.lockPosition == "Below" then
		targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
	else
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	end
	
	return targetPos
end

local function getMiningPosition(rock)
	if not rock then return nil end
	
	local positionPart = funcs.getRockPosition(rock)
	if not positionPart then 
		return nil 
	end
	
	local rockPos = positionPart.Position
	local targetPos = rockPos + Vector3.new(0, -config.miningVerticalDistance, 0)
	
	return targetPos
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function hoverToPosition(targetPos, lookAtPos)
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return false
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < config.hoverReachedThreshold then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		return true
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	
	local desiredVelocity = direction.Unit * targetSpeed
	local currentVelocity = config.bodyVelocity.Velocity
	local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	if lookAtPos then
		local lookCFrame = CFrame.new(currentPos, lookAtPos)
		config.bodyGyro.CFrame = lookCFrame
	end
	
	return false
end

local function hoverToMob(targetPos, mob)
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
		return
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	-- FIXED: More aggressive lock-on threshold
	config.isLockedOn = distance < 12
	
	-- Handle Above/Below positions with improved stability
	if (config.lockPosition == "Above" or config.lockPosition == "Below") then
		if distance < 5 then
			-- FIXED: Smoother follow movement
			local followSpeed = math.max(5, distance * 2)
			local desiredVelocity = direction.Unit * followSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.3)
		else
			-- Approach position
			local targetSpeed = config.hoverSpeed * math.min(distance / 10, 1)
			local desiredVelocity = direction.Unit * targetSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.4)
		end
		
		if config.lockPosition == "Above" then
			local angle = math.rad(config.aboveAngle)
			local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(downCFrame, 0.7)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 60000
			config.bodyGyro.D = 2000
		else
			local angle = math.rad(config.belowAngle)
			local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(upCFrame, 0.7)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 60000
			config.bodyGyro.D = 2000
		end
		return
	end
	
	-- FIXED: Improved Back/Front positioning
	local targetSpeed
	if distance < 3 then
		-- Very close - minimal movement
		targetSpeed = 3
	elseif distance < 8 then
		-- Close range - smooth tracking
		targetSpeed = 12
	else
		-- Far range - fast approach
		targetSpeed = config.hoverSpeed * math.min(distance / 8, 1)
	end
	
	local desiredVelocity = direction.Unit * targetSpeed
	
	-- FIXED: Better lerp speed based on distance
	local lerpSpeed
	if distance < 3 then
		lerpSpeed = 0.15
	elseif distance < 8 then
		lerpSpeed = 0.4
	else
		lerpSpeed = 0.3
	end
	
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, lerpSpeed)
	config.bodyVelocity.Velocity = newVelocity
	
	-- FIXED: Improved camera lock with predictive aiming
	local mobVelocity = mobRoot.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
	local predictedPos = mobRoot.Position + (mobVelocity * 0.1)
	local lookCFrame = CFrame.new(currentPos, predictedPos)
	
	if distance < 8 then
		-- Close range - tight lock
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.8)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 80000
		config.bodyGyro.D = 2500
	else
		-- Far range - smoother tracking
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.5)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 50000
		config.bodyGyro.D = 1500
	end
end

local function hoverToRock(targetPos, rock)
	if not targetPos then 
		return 
	end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < 3 then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		
		local angle = math.rad(config.miningAngle)
		local lookCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
		config.bodyGyro.CFrame = lookCFrame
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 50000
		return
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	local desiredVelocity = direction.Unit * targetSpeed
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	local positionPart = funcs.getRockPosition(rock)
	if positionPart then
		local lookCFrame = CFrame.new(currentPos, positionPart.Position)
		config.bodyGyro.CFrame = lookCFrame
		config.bodyGyro.P = 10000
	end
end

-- Add to global functions
funcs.getLockPosition = getLockPosition
funcs.getMiningPosition = getMiningPosition
funcs.hoverToPosition = hoverToPosition
funcs.hoverToMob = hoverToMob
funcs.hoverToRock = hoverToRock

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 4.5: LINORIA UI SETUP & BASIC TABS (FIXED KEYBINDS & CONFIGS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")
local HOVER_HEIGHT = -5
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_POSITION_2 = Vector3.new(-44.71, -5.12, -273.02)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT POSITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local teleportAreas = {
    ["Forge"] = Vector3.new(-192.64, 29.57, 163.72),
	["Cave 1"] = Vector3.new(26.77, -5.54, -92.99),
	["Cave 2"] = Vector3.new(228.51, -13.58, -228.31),
	["Cave 3"] = Vector3.new(-30.18, -5.65, -277.74),
	["Cave 4"] = Vector3.new(-27.87, -14.86, -497.32),
	["Cave 5 (Needs Unlocking)"] = Vector3.new(254.87, -13.89, -265.18),
	["Pickaxes"] = Vector3.new(-91.92, 27.53, 90.57),
	["Potions"] = Vector3.new(-154.15, 27.92, 115.68),
	["Stonewake's Pickaxe $3.333"] = Vector3.new(-29.40, -3.17, -269.23),
	["Arcane Pickaxe (Needs Unlocking)"] = Vector3.new(235.67, -14.31, -336.06),
}

local teleportNPCs = {
	["Buyer"] = Vector3.new(-113.83, 37.54, -35.20),
	["Tomo the Explorist"] = Vector3.new(-106.44, 49.49, -106.58),
	["Weapon Buyer"] = Vector3.new(-178.52, 27.67, 14.79),
	["Bard"] = Vector3.new(-132.60, 27.79, 107.79),
	["Sensei Moro"] = Vector3.new(-199.38, 29.44, 156.12),
	["Runemaker"] = Vector3.new(-272.62, 20.32, 144.82),
	["Enhancer"] = Vector3.new(-259.79, 19.76, 27.66),
	["Nord"] = Vector3.new(38.92, -5.63, -102.73),
	["Umut The Brave"] = Vector3.new(15.41, -5.87, -117.16),
	["Undead"] = Vector3.new(-45.73, -26.69, -60.67),
	["Wizard"] = Vector3.new(-22.93, 80.88, -356.81),
	["Suspicious Fisher"] = Vector3.new(-295.87, 23.82, -91.61),
	["Injured Miner"] = Vector3.new(80.57, -14.63, -364.49),
}

local selectedArea = nil
local selectedNPC = nil

_G.teleportHoverActive = false
local teleportHoverTarget = nil
local teleportHoverLoop = nil
local teleportNoclipEnabled = false

local function hoverToTeleportPosition(targetPos)
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return false
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < 3 then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		return true
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	
	local desiredVelocity = direction.Unit * targetSpeed
	local currentVelocity = config.bodyVelocity.Velocity
	local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	local lookCFrame = CFrame.new(currentPos, targetPos)
	config.bodyGyro.CFrame = lookCFrame
	
	return false
end

local function startTeleportHover(position, locationName)
	if _G.teleportHoverActive then
		_G.UIReferences.Library:Notify("Already traveling to a location!", 2)
		return
	end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		task.wait(0.1)
	end
	
	_G.teleportHoverActive = true
	
	if not config.noclipLoop then
		funcs.startNoclip()
		teleportNoclipEnabled = true
	end
	
	teleportHoverTarget = position
	
	_G.UIReferences.Library:Notify("Traveling to " .. locationName .. "...", 2)
	
	teleportHoverLoop = RunService.Heartbeat:Connect(function()
		if not _G.teleportHoverActive then
			if teleportHoverLoop then
				teleportHoverLoop:Disconnect()
				teleportHoverLoop = nil
			end
			return
		end
		
		local reached = hoverToTeleportPosition(teleportHoverTarget)
		
		if reached then
			_G.teleportHoverActive = false
			
			if teleportHoverLoop then
				teleportHoverLoop:Disconnect()
				teleportHoverLoop = nil
			end
			
			_G.UIReferences.Library:Notify("Arrived at " .. locationName .. "!", 2)
			
			if not config.enabled and not config.miningEnabled then
				task.wait(0.5)
				
				if teleportNoclipEnabled then
					funcs.stopNoclip()
					teleportNoclipEnabled = false
				end
				
				funcs.cleanupPhysicsMovement()
			end
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- LOAD LINORIA UI LIBRARY (WITH ERROR HANDLING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library, ThemeManager, SaveManager

local success, err = pcall(function()
	Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
	ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
	SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
end)

if not success or not Library then
	error("Failed to load Linoria library: " .. tostring(err))
	return
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CREATE WINDOW (WITH VALIDATION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Window = Library:CreateWindow({
	Title = "The Forge by Rafso | Stonewake's Cross",
	Center = true,
	AutoShow = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})

if not Window then
	error("Failed to create window!")
	return
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STORE UI REFERENCES GLOBALLY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_G.UIReferences = {
	Window = Window,
	Library = Library,
	Tabs = {},
	Toggles = {},
	Options = {},
}

local Tabs = _G.UIReferences.Tabs

-- âœ… FIX: Store Toggles and Options in both places
local Toggles = _G.UIReferences.Toggles
local Options = _G.UIReferences.Options

-- Make them globally accessible
getgenv().Toggles = Toggles
getgenv().Options = Options

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOOPS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local attackLoop = nil
local mineLoop = nil
local weaponCheckLoop = nil
local pickaxeCheckLoop = nil
local sellLoop = nil

local function startAutoAttack()
	if attackLoop then return end
	
	task.spawn(function()
		task.wait(0.5)
		funcs.autoEquipWeapon()
	end)
	
	attackLoop = RunService.Heartbeat:Connect(function()
		if not config.enabled then return end
		funcs.performAttack()
	end)
	
	if not weaponCheckLoop then
		weaponCheckLoop = RunService.Heartbeat:Connect(function()
			if not config.enabled then return end
			local currentTime = tick()
			if currentTime - config.lastWeaponCheckTime >= config.weaponCheckInterval then
				config.lastWeaponCheckTime = currentTime
				funcs.autoEquipWeapon()
			end
		end)
	end
end

local function stopAutoAttack()
	if attackLoop then
		attackLoop:Disconnect()
		attackLoop = nil
	end
	if weaponCheckLoop then
		weaponCheckLoop:Disconnect()
		weaponCheckLoop = nil
	end
end

local function startAutoMine()
	if mineLoop then return end
	
	task.spawn(function()
		task.wait(0.3)
		funcs.autoEquipPickaxe()
	end)
	
	mineLoop = RunService.Heartbeat:Connect(function()
		if not config.miningEnabled then return end
		funcs.performMine()
	end)
	
	if not pickaxeCheckLoop then
		pickaxeCheckLoop = RunService.Heartbeat:Connect(function()
			if not config.miningEnabled then return end
			local currentTime = tick()
			if currentTime - config.lastPickaxeCheckTime >= config.pickaxeCheckInterval then
				config.lastPickaxeCheckTime = currentTime
				funcs.autoEquipPickaxe()
			end
		end)
	end
end

local function stopAutoMine()
	if mineLoop then
		mineLoop:Disconnect()
		mineLoop = nil
	end
	if pickaxeCheckLoop then
		pickaxeCheckLoop:Disconnect()
		pickaxeCheckLoop = nil
	end
end

local function startAutoSell()
	if sellLoop then return end
	
	sellLoop = RunService.Heartbeat:Connect(function()
		if not config.autoSellEnabled then return end
		funcs.sellItems()
	end)
end

local function stopAutoSell()
	if sellLoop then
		sellLoop:Disconnect()
		sellLoop = nil
	end
end

_G.AutoLoopFunctions = {
	startAutoAttack = startAutoAttack,
	stopAutoAttack = stopAutoAttack,
	startAutoMine = startAutoMine,
	stopAutoMine = stopAutoMine,
	startAutoSell = startAutoSell,
	stopAutoSell = stopAutoSell,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CREATE TABS (WITH VALIDATION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Tabs.Info = Window:AddTab('Info')
Tabs.Farming = Window:AddTab('Mobs')
Tabs.Mining = Window:AddTab('Mine')
Tabs.AutoSell = Window:AddTab('Sell')
Tabs.Teleport = Window:AddTab('Teleport')
Tabs.Settings = Window:AddTab('Settings')
Tabs.Configs = Window:AddTab('Config')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INFO TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local InfoLeftBox = Tabs.Info:AddLeftGroupbox('Script Information')

InfoLeftBox:AddLabel("World 1: Stonewake's Cross")
InfoLeftBox:AddLabel('Tested on Xeno')
InfoLeftBox:AddLabel('Created by Rafso [literalh]')
InfoLeftBox:AddDivider()

InfoLeftBox:AddLabel('Script Features:')
InfoLeftBox:AddLabel('â€¢ Auto-Farm ')
InfoLeftBox:AddLabel('â€¢ Auto-Mine')
InfoLeftBox:AddLabel('â€¢ Auto-Sell')
InfoLeftBox:AddLabel('â€¢ Teleports')
InfoLeftBox:AddLabel('â€¢ Config System')

local InfoRightBox = Tabs.Info:AddRightGroupbox('Tips')

InfoRightBox:AddLabel('Important Tips:')
InfoRightBox:AddLabel('â€¢ Manually press Talk to Buyer')
InfoRightBox:AddLabel('if not automatically done')
InfoRightBox:AddLabel('This Script is in BETA')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FARMING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FarmingGroupBox = Tabs.Farming:AddLeftGroupbox('Mob Farming')

-- âœ… FIX: Store toggle with proper reference
Toggles.FarmToggle = FarmingGroupBox:AddToggle('FarmToggle', {
	Text = 'Enable Mob Farming (F1)',
	Default = false,
	Tooltip = 'Toggle mob farming on/off',
	Callback = function(Value)
		config.enabled = Value
		
		if config.enabled then
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
					config.hoverSequenceActive = true
					config.currentHoverTarget = 1
				end
			end
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			startAutoAttack()
		else
			task.wait(0.1)
			
			config.hoverSequenceActive = false
			config.currentMob = nil
			stopAutoAttack()
			funcs.stopNoclip()
			funcs.cleanupPhysicsMovement()
		end
	end
})

FarmingGroupBox:AddDivider()

Options.LockPosition = FarmingGroupBox:AddDropdown('LockPosition', {
	Values = {'Back', 'Front', 'Above', 'Below'},
	Default = 4,
	Multi = false,
	Text = 'Lock Position',
	Tooltip = 'Choose where to position yourself relative to the mob',
	Callback = function(Value)
		config.lockPosition = Value
	end
})

FarmingGroupBox:AddDivider()

local mobOptions = {}
for i, mobData in ipairs(config.mobTypes) do
	table.insert(mobOptions, mobData.name)
end

FarmingGroupBox:AddLabel('Select Mobs to Farm:')

Options.MobSelection = FarmingGroupBox:AddDropdown('MobSelection', {
	Values = mobOptions,
	Default = 1,
	Multi = true,
	Text = 'Select Mobs',
	Tooltip = 'Choose which mobs to farm',
	Callback = function(Value)
		for i, mobData in ipairs(config.mobTypes) do
			config.mobTypes[i].enabled = false
		end
		
		for mobName, isEnabled in pairs(Value) do
			if isEnabled then
				for i, mobData in ipairs(config.mobTypes) do
					if mobData.name == mobName then
						config.mobTypes[i].enabled = true
						break
					end
				end
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MiningGroupBox = Tabs.Mining:AddLeftGroupbox('Mining')

-- âœ… FIX: Store toggle with proper reference
Toggles.MineToggle = MiningGroupBox:AddToggle('MineToggle', {
	Text = 'Enable Mining (F2)',
	Default = false,
	Tooltip = 'Toggle mining on/off',
	Callback = function(Value)
		config.miningEnabled = Value
		
		if config.miningEnabled then
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.rockDurabilityCheck = tick()
			config.currentRock = nil
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
					config.hoverSequenceActive = true
					config.currentHoverTarget = 1
				end
			end
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			startAutoMine()
		else
			task.wait(0.1)
			
			config.hoverSequenceActive = false
			config.currentHoverTarget = 1
			config.currentRock = nil
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.isLockedOn = false
			
			stopAutoMine()
			funcs.stopNoclip()
			funcs.cleanupPhysicsMovement()
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					rootPart.Velocity = Vector3.new(0, 0, 0)
					rootPart.Anchored = false
				end
			end
		end
	end
})

MiningGroupBox:AddDivider()

local rockOptions = {}
for i, rockData in ipairs(config.rockTypes) do
	table.insert(rockOptions, rockData.name)
end

MiningGroupBox:AddLabel('Select Rocks to Mine:')

Options.RockSelection = MiningGroupBox:AddDropdown('RockSelection', {
	Values = rockOptions,
	Default = 1,
	Multi = true,
	Text = 'Select Rocks',
	Tooltip = 'Choose which rocks to mine',
	Callback = function(Value)
		for i, rockData in ipairs(config.rockTypes) do
			config.rockTypes[i].enabled = false
		end
		
		for rockName, isEnabled in pairs(Value) do
			if isEnabled then
				for i, rockData in ipairs(config.rockTypes) do
					if rockData.name == rockName then
						config.rockTypes[i].enabled = true
						break
					end
				end
			end
		end
	end
})

-- âœ… FIX: Store all options globally after creation
_G.UIReferences.mobOptions = mobOptions
_G.UIReferences.rockOptions = rockOptions

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 5: AUTOSELL, TELEPORT, SETTINGS & CONFIG TABS (FIXED)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WORLD 2 TELEPORT SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local VirtualInputManager = game:GetService("VirtualInputManager")

local FORGOTTEN_KINGDOM_SPAWN = Vector3.new(-260.62, 17.75, 100.27)
local FORGOTTEN_KINGDOM_FRONT = Vector3.new(-260.62, 17.75, 93.27)
local FORGOTTEN_KINGDOM_GUI_X = 602
local FORGOTTEN_KINGDOM_GUI_Y = 459
local TELEPORT_BUTTON_X = 1124
local TELEPORT_BUTTON_Y = 682

local world2AutoJoinActive = false
local world2AutoJoinLoop = nil

local function clickAt(x, y)
	VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
	task.wait(0.01)
	VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
end

local function pressK()
	VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.K, false, game)
	task.wait(0.05)
	VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.K, false, game)
end

local function checkForPortalTool()
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack and backpack:FindFirstChild("PortalTool") then
		return true
	end
	
	local character = LocalPlayer.Character
	if character and character:FindFirstChild("PortalTool") then
		return true
	end
	
	return false
end

local function teleportToWorld2()
	local character = LocalPlayer.Character
	if not character then
		warn("âŒ Character not found!")
		return false
	end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	
	if not rootPart or not humanoid then
		warn("âŒ Character components not found!")
		return false
	end
	
	print("\n" .. string.rep("â•", 60))
	print("ğŸŒŸ STARTING WORLD 2 TELEPORT")
	print(string.rep("â•", 60))
	
	-- Step 1: Teleport to spawn portal position and LOCK
	print("ğŸ“ Step 1: Teleporting to spawn portal...")
	local spawnPosition = FORGOTTEN_KINGDOM_SPAWN
	
	local startTime = tick()
	while tick() - startTime < 1 do
		rootPart.CFrame = CFrame.new(spawnPosition)
		task.wait(0.05)
	end
	print("âœ… At spawn position")
	
	-- Step 2: Get PortalTool
	print("ğŸ’ Step 2: Getting PortalTool...")
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if not backpack then
		warn("âŒ Backpack not found!")
		return false
	end
	
	local portalTool = backpack:FindFirstChild("PortalTool")
	if not portalTool then
		warn("âŒ PortalTool not found!")
		return false
	end
	print("âœ… Found PortalTool")
	
	-- Step 3: Equip PortalTool
	print("âš™ï¸ Step 3: Equipping...")
	humanoid:EquipTool(portalTool)
	task.wait(0.3)
	
	if not character:FindFirstChild("PortalTool") then
		warn("âŒ Failed to equip!")
		return false
	end
	print("âœ… Equipped")
	
	-- Step 4: Place portal
	print("ğŸ”¨ Step 4: Placing portal...")
	clickAt(0, 0)
	task.wait(1)
	print("âœ… Portal placed")
	
	-- Step 5: Find proximity prompt
	print("ğŸ” Step 5: Finding prompt...")
	local proximityPrompt = nil
	
	for attempt = 1, 10 do
		local debris = workspace:FindFirstChild("Debris")
		if debris then
			local portalForge = debris:FindFirstChild("PortalTheForge")
			if portalForge then
				local proximityContainer = portalForge:FindFirstChild("ProximityContainer")
				if proximityContainer then
					proximityPrompt = proximityContainer:FindFirstChild("ProximityPrompt")
					if proximityPrompt then
						print("âœ… Found prompt (attempt " .. attempt .. ")")
						break
					end
				end
			end
		end
		task.wait(0.2)
	end
	
	if not proximityPrompt then
		warn("âŒ Prompt not found!")
		return false
	end
	
	-- Step 6: Teleport to front of portal and LOCK position
	print("ğŸš¶ Step 6: Moving to front of portal...")
	local frontPosition = FORGOTTEN_KINGDOM_FRONT
	
	local lockStart = tick()
	while tick() - lockStart < 1.5 do
		rootPart.CFrame = CFrame.new(frontPosition)
		task.wait(0.05)
	end
	print("âœ… Position locked at front")
	
	-- Step 7: Press proximity prompt
	print("ğŸ”“ Step 7: Pressing prompt...")
	
	local targetPart = proximityPrompt.Parent
	if targetPart and targetPart:IsA("BasePart") then
		local distance = (targetPart.Position - rootPart.Position).Magnitude
		local maxDist = proximityPrompt.MaxActivationDistance
		
		print("  Distance: " .. string.format("%.2f", distance) .. " / " .. maxDist)
		
		if distance <= maxDist then
			local success = pcall(function()
				proximityPrompt:InputHoldBegin()
				proximityPrompt:InputHoldEnd()
			end)
			
			if success then
				print("âœ… Pressed successfully")
			else
				warn("âŒ Press failed!")
				return false
			end
		else
			print("  âš ï¸ Too far! Moving closer...")
			rootPart.CFrame = CFrame.new(targetPart.Position + Vector3.new(0, 3, 0))
			task.wait(0.2)
			
			pcall(function()
				proximityPrompt:InputHoldBegin()
				proximityPrompt:InputHoldEnd()
			end)
			print("âœ… Pressed (retry)")
		end
	end
	
	task.wait(0.5)
	
	-- Step 8: Click Forgotten Kingdom
	print("ğŸ° Step 8: Clicking Forgotten Kingdom...")
	print("  Position: X=" .. FORGOTTEN_KINGDOM_GUI_X .. ", Y=" .. FORGOTTEN_KINGDOM_GUI_Y)
	clickAt(FORGOTTEN_KINGDOM_GUI_X, FORGOTTEN_KINGDOM_GUI_Y)
	task.wait(0.3)
	print("âœ… Clicked Forgotten Kingdom")
	
	-- Step 9: Click Teleport button
	print("ğŸš€ Step 9: Clicking Teleport button...")
	print("  Position: X=" .. TELEPORT_BUTTON_X .. ", Y=" .. TELEPORT_BUTTON_Y)
	task.wait(0.5)
	
	for i = 1, 5 do
		clickAt(TELEPORT_BUTTON_X, TELEPORT_BUTTON_Y)
		task.wait(0.15)
	end
	
	print("âœ… Clicked Teleport (5 times)")
	
	print(string.rep("â•", 60))
	print("âœ… WORLD 2 TELEPORT COMPLETE!")
	print(string.rep("â•", 60) .. "\n")
	
	return true
end

local function startWorld2AutoJoin()
	if world2AutoJoinActive then
		Library:Notify("World 2 Auto-Join is already active!", 3)
		return
	end
	
	if not checkForPortalTool() then
		Library:Notify("You must unlock the Portal first!", 3)
		return false
	end
	
	world2AutoJoinActive = true
	
	world2AutoJoinLoop = task.spawn(function()
		while world2AutoJoinActive do
			local success = teleportToWorld2()
			
			if success then
				Library:Notify("Successfully joined Forgotten Kingdom!", 3)
			else
				Library:Notify("Failed to join Forgotten Kingdom!", 3)
			end
			
			task.wait(300)
		end
	end)
	
	return true
end

local function stopWorld2AutoJoin()
	world2AutoJoinActive = false
	if world2AutoJoinLoop then
		task.cancel(world2AutoJoinLoop)
		world2AutoJoinLoop = nil
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AutoSellGroupBox = Tabs.AutoSell:AddLeftGroupbox('Auto Sell')

Toggles.AutoSellToggle = AutoSellGroupBox:AddToggle('AutoSellToggle', {
	Text = 'Enable Auto Sell',
	Default = false,
	Tooltip = 'Automatically sell selected items',
	Callback = function(Value)
		config.autoSellEnabled = Value
		
		if config.autoSellEnabled then
			_G.AutoLoopFunctions.startAutoSell()
		else
			_G.AutoLoopFunctions.stopAutoSell()
		end
	end
})

AutoSellGroupBox:AddDivider()

AutoSellGroupBox:AddButton({
	Text = 'Talk to Buyer',
	Func = function()
		local success = funcs.talkToSeller()
		
		if success then
			Library:Notify("Successfully talked to buyer!", 3)
		else
			Library:Notify("Failed to talk to buyer!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Teleport to buyer and open dialogue'
})

local ItemSelectionGroupBox = Tabs.AutoSell:AddRightGroupbox('Item Selection')

ItemSelectionGroupBox:AddLabel('Select Items to Auto Sell:')

Options.CommonItems = ItemSelectionGroupBox:AddDropdown('CommonItems', {
	Values = ItemsByRarity.Common,
	Default = 1,
	Multi = true,
	Text = 'Common Items',
	Tooltip = 'Select common items to sell',
	Callback = function(Value)
		config.selectedItems.Common = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Common, itemName)
			end
		end
	end
})

Options.UncommonItems = ItemSelectionGroupBox:AddDropdown('UncommonItems', {
	Values = ItemsByRarity.Uncommon,
	Default = 1,
	Multi = true,
	Text = 'Uncommon Items',
	Tooltip = 'Select uncommon items to sell',
	Callback = function(Value)
		config.selectedItems.Uncommon = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Uncommon, itemName)
			end
		end
	end
})

Options.RareItems = ItemSelectionGroupBox:AddDropdown('RareItems', {
	Values = ItemsByRarity.Rare,
	Default = 1,
	Multi = true,
	Text = 'Rare Items',
	Tooltip = 'Select rare items to sell',
	Callback = function(Value)
		config.selectedItems.Rare = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Rare, itemName)
			end
		end
	end
})

Options.EpicItems = ItemSelectionGroupBox:AddDropdown('EpicItems', {
	Values = ItemsByRarity.Epic,
	Default = 1,
	Multi = true,
	Text = 'Epic Items',
	Tooltip = 'Select epic items to sell',
	Callback = function(Value)
		config.selectedItems.Epic = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Epic, itemName)
			end
		end
	end
})

Options.LegendaryItems = ItemSelectionGroupBox:AddDropdown('LegendaryItems', {
	Values = ItemsByRarity.Legendary,
	Default = 1,
	Multi = true,
	Text = 'Legendary Items',
	Tooltip = 'Select legendary items to sell',
	Callback = function(Value)
		config.selectedItems.Legendary = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Legendary, itemName)
			end
		end
	end
})

Options.MythicalItems = ItemSelectionGroupBox:AddDropdown('MythicalItems', {
	Values = ItemsByRarity.Mythical,
	Default = 1,
	Multi = true,
	Text = 'Mythical Items',
	Tooltip = 'Select mythical items to sell',
	Callback = function(Value)
		config.selectedItems.Mythical = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Mythical, itemName)
			end
		end
	end
})

Options.RuneItems = ItemSelectionGroupBox:AddDropdown('RuneItems', {
	Values = ItemsByRarity.Rune,
	Default = 1,
	Multi = true,
	Text = 'Rune Items',
	Tooltip = 'Select rune items to sell',
	Callback = function(Value)
		config.selectedItems.Rune = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Rune, itemName)
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT TAB (UPDATED WITH WORLD 2)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TeleportAreasBox = Tabs.Teleport:AddLeftGroupbox('Areas')

local areaOptions = {}
for areaName, _ in pairs(teleportAreas) do
	table.insert(areaOptions, areaName)
end
table.sort(areaOptions)

TeleportAreasBox:AddLabel('Select an Area:')

Options.AreaSelection = TeleportAreasBox:AddDropdown('AreaSelection', {
	Values = areaOptions,
	Default = 1,
	Multi = false,
	Tooltip = 'Choose an area to teleport to',
	Callback = function(Value)
		selectedArea = Value
	end
})

TeleportAreasBox:AddDivider()

TeleportAreasBox:AddButton({
	Text = 'Travel to Area',
	Func = function()
		if not selectedArea or selectedArea == "" then
			Library:Notify("Please select an area first!", 3)
			return
		end
		
		local position = teleportAreas[selectedArea]
		if position then
			startTeleportHover(position, selectedArea)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Hover travel to the selected area'
})

TeleportAreasBox:AddDivider()

-- NPCs Section (below Areas)
TeleportAreasBox:AddLabel('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
TeleportAreasBox:AddLabel('NPCs:')

local npcOptions = {}
for npcName, _ in pairs(teleportNPCs) do
	table.insert(npcOptions, npcName)
end
table.sort(npcOptions)

Options.NPCSelection = TeleportAreasBox:AddDropdown('NPCSelection', {
	Values = npcOptions,
	Default = 1,
	Multi = false,
	Tooltip = 'Choose an NPC to teleport to',
	Callback = function(Value)
		selectedNPC = Value
	end
})

TeleportAreasBox:AddDivider()

TeleportAreasBox:AddButton({
	Text = 'Travel to NPC',
	Func = function()
		if not selectedNPC or selectedNPC == "" then
			Library:Notify("Please select an NPC first!", 3)
			return
		end
		
		local position = teleportNPCs[selectedNPC]
		if position then
			startTeleportHover(position, selectedNPC)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Hover travel to the selected NPC'
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WORLD 2 FORGOTTEN KINGDOM (RIGHT SIDE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local World2Box = Tabs.Teleport:AddRightGroupbox('World 2: Forgotten Kingdom')

Toggles.AutoJoinWorld2 = World2Box:AddToggle('AutoJoinWorld2', {
	Text = 'Auto-Join Forgotten Kingdom',
	Default = false,
	Tooltip = 'Automatically join Forgotten Kingdom every 5 minutes',
	Callback = function(Value)
		if Value then
			if not checkForPortalTool() then
				Library:Notify("You must unlock the Portal first!", 3)
				Toggles.AutoJoinWorld2:SetValue(false)
				return
			end
			
			Library:Notify("Starting in 5 seconds...", 3)
			
			-- Press K to hide GUI after 4.5 seconds
			task.delay(4.5, function()
				pressK()
			end)
			
			task.wait(5)
			
			if Toggles.AutoJoinWorld2.Value then
				local success = startWorld2AutoJoin()
				if not success then
					Toggles.AutoJoinWorld2:SetValue(false)
					-- Press K again to show GUI if failed
					pressK()
				else
					Library:Notify("World 2 Auto-Join started!", 3)
				end
			else
				-- Press K to show GUI if cancelled during countdown
				pressK()
			end
		else
			stopWorld2AutoJoin()
			Library:Notify("World 2 Auto-Join stopped!", 3)
			-- Press K to show GUI when stopped
			pressK()
		end
	end
})

World2Box:AddDivider()

World2Box:AddButton({
	Text = 'Join Forgotten Kingdom',
	Func = function()
		if not checkForPortalTool() then
			Library:Notify("You must unlock the Portal first!", 3)
			return
		end
		
		Library:Notify("Teleporting to Forgotten Kingdom...", 3)
		
		-- Press K to hide GUI immediately
		pressK()
		
		task.wait(0.5)
		
		local success = teleportToWorld2()
		
		if success then
			Library:Notify("Successfully joined Forgotten Kingdom!", 3)
		else
			Library:Notify("Failed to join Forgotten Kingdom!", 3)
			-- Press K to show GUI again if failed
			task.wait(2)
			pressK()
		end
	end,
	DoubleClick = false,
	Tooltip = 'Instantly teleport to Forgotten Kingdom'
})

World2Box:AddLabel('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
World2Box:AddLabel('Requires Portal Tool unlocked')
World2Box:AddLabel('from The Forge questline')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'K', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

MenuGroup:AddDivider()

MenuGroup:AddButton({
	Text = 'Destroy GUI',
	Func = function()
		if Toggles.FarmToggle then
			Toggles.FarmToggle:SetValue(false)
		end
		if Toggles.MineToggle then
			Toggles.MineToggle:SetValue(false)
		end
		if Toggles.AutoSellToggle then
			Toggles.AutoSellToggle:SetValue(false)
		end
		if Toggles.AutoJoinWorld2 then
			Toggles.AutoJoinWorld2:SetValue(false)
		end
		
		task.wait(0.5)
		
		if _G.KeybindConnection then
			_G.KeybindConnection:Disconnect()
			_G.KeybindConnection = nil
		end
		
		_G.AutoLoopFunctions.stopAutoAttack()
		_G.AutoLoopFunctions.stopAutoMine()
		_G.AutoLoopFunctions.stopAutoSell()
		stopWorld2AutoJoin()
		
		funcs.stopNoclip()
		funcs.cleanupPhysicsMovement()
		
		_G.MobFarmConfig = nil
		_G.FarmFunctions = nil
		_G.AutoLoopFunctions = nil
		_G.ConfigFunctions = nil
		_G.UIReferences = nil
		
		Library:Unload()
	end,
	DoubleClick = false,
	Tooltip = 'Close and destroy the GUI'
})

local GeneralSettingsBox = Tabs.Settings:AddRightGroupbox('General Settings')

Options.HoverSpeed = GeneralSettingsBox:AddSlider('HoverSpeed', {
	Text = 'Hover Speed',
	Default = 80,
	Min = 20,
	Max = 140,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.hoverSpeed = Value
	end
})

local FarmSettingsBox = Tabs.Settings:AddRightGroupbox('Farm Settings')

Options.VerticalDistance = FarmSettingsBox:AddSlider('VerticalDistance', {
	Text = 'Vertical Distance',
	Default = 8,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.verticalDistance = Value
	end
})

local MiningSettingsBox = Tabs.Settings:AddRightGroupbox('Mining Settings')

Options.MiningVerticalDistance = MiningSettingsBox:AddSlider('MiningVerticalDistance', {
	Text = 'Mining Vertical Distance',
	Default = 6,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.miningVerticalDistance = Value
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFIG MANAGEMENT TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local configFuncs = _G.ConfigFunctions

local ConfigManagementBox = Tabs.Configs:AddLeftGroupbox('Config Management')

local selectedConfig = nil

Options.ConfigName = ConfigManagementBox:AddInput('ConfigName', {
	Default = '',
	Numeric = false,
	Finished = false,
	Text = 'Config Name',
	Tooltip = 'Enter a name for your config',
	Placeholder = 'Enter config name...',
})

Options.ConfigSelector = ConfigManagementBox:AddDropdown('ConfigSelector', {
	Values = configFuncs.getConfigList(),
	Default = 1,
	Multi = false,
	Text = 'Select Config',
	Tooltip = 'Choose a config to load/delete',
	Callback = function(Value)
		selectedConfig = Value
	end
})

ConfigManagementBox:AddDivider()

ConfigManagementBox:AddButton({
	Text = 'Refresh Configs',
	Func = function()
		local configList = configFuncs.getConfigList()
		Options.ConfigSelector:SetValues(configList)
		Library:Notify("Found " .. #configList .. " config(s)", 2)
	end,
	DoubleClick = false,
	Tooltip = 'Refresh the config list'
})

ConfigManagementBox:AddButton({
	Text = 'Create Config',
	Func = function()
		local configName = Options.ConfigName.Value
		
		if configName == "" or configName == nil then
			Library:Notify("Please enter a config name!", 3)
			return
		end
		
		configName = configName:gsub("%s+", "_")
		
		local success = configFuncs.saveConfig(configName)
		
		if success then
			Library:Notify("Config '" .. configName .. "' created!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			Options.ConfigSelector:SetValue(configName)
			selectedConfig = configName
			
			Options.ConfigName:SetValue("")
		else
			Library:Notify("Failed to create config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Create a new config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Load Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.loadConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' loaded!", 3)
			
			-- âœ… FIX: Wait for config to fully load
			task.wait(0.3)
			
			-- Apply all settings to UI
			if Toggles.FarmToggle then
				Toggles.FarmToggle:SetValue(config.enabled)
			end
			
			if Toggles.MineToggle then
				Toggles.MineToggle:SetValue(config.miningEnabled)
			end
			
			if Toggles.AutoSellToggle then
				Toggles.AutoSellToggle:SetValue(config.autoSellEnabled)
			end
			
			if Options.HoverSpeed then
				Options.HoverSpeed:SetValue(config.hoverSpeed)
			end
			
			if Options.VerticalDistance then
				Options.VerticalDistance:SetValue(config.verticalDistance)
			end
			
			if Options.MiningVerticalDistance then
				Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
			end
			
			if Options.LockPosition then
				Options.LockPosition:SetValue(config.lockPosition)
			end
			
			-- Apply mob selection
			if Options.MobSelection then
				local enabledMobs = {}
				for _, mobData in ipairs(config.mobTypes) do
					if mobData.enabled then
						enabledMobs[mobData.name] = true
					end
				end
				Options.MobSelection:SetValue(enabledMobs)
			end
			
			-- Apply rock selection
			if Options.RockSelection then
				local enabledRocks = {}
				for _, rockData in ipairs(config.rockTypes) do
					if rockData.enabled then
						enabledRocks[rockData.name] = true
					end
				end
				Options.RockSelection:SetValue(enabledRocks)
			end
			
			-- Apply autosell items
			if Options.CommonItems then
				local commonItems = {}
				for _, item in ipairs(config.selectedItems.Common or {}) do
					commonItems[item] = true
				end
				Options.CommonItems:SetValue(commonItems)
			end
			
			if Options.UncommonItems then
				local uncommonItems = {}
				for _, item in ipairs(config.selectedItems.Uncommon or {}) do
					uncommonItems[item] = true
				end
				Options.UncommonItems:SetValue(uncommonItems)
			end
			
			if Options.RareItems then
				local rareItems = {}
				for _, item in ipairs(config.selectedItems.Rare or {}) do
					rareItems[item] = true
				end
				Options.RareItems:SetValue(rareItems)
			end
			
			if Options.EpicItems then
				local epicItems = {}
				for _, item in ipairs(config.selectedItems.Epic or {}) do
					epicItems[item] = true
				end
				Options.EpicItems:SetValue(epicItems)
			end
			
			if Options.LegendaryItems then
				local legendaryItems = {}
				for _, item in ipairs(config.selectedItems.Legendary or {}) do
					legendaryItems[item] = true
				end
				Options.LegendaryItems:SetValue(legendaryItems)
			end
			
			if Options.MythicalItems then
				local mythicalItems = {}
				for _, item in ipairs(config.selectedItems.Mythical or {}) do
					mythicalItems[item] = true
				end
				Options.MythicalItems:SetValue(mythicalItems)
			end
			
			if Options.RuneItems then
				local runeItems = {}
				for _, item in ipairs(config.selectedItems.Rune or {}) do
					runeItems[item] = true
				end
				Options.RuneItems:SetValue(runeItems)
			end
			
			Library:Notify("All settings applied!", 2)
		else
			Library:Notify("Failed to load config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Load the selected config'
})

ConfigManagementBox:AddButton({
	Text = 'Overwrite Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.saveConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' overwritten!", 3)
		else
			Library:Notify("Failed to overwrite config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Overwrite selected config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Set as Autoload',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		configFuncs.setAutoload(selectedConfig)
		Library:Notify("Config '" .. selectedConfig .. "' set as autoload!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'This config will load automatically on startup'
})

ConfigManagementBox:AddButton({
	Text = 'Destroy Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local configToDelete = selectedConfig
		local success = configFuncs.deleteConfig(configToDelete)
		
		if success then
			Library:Notify("Config '" .. configToDelete .. "' deleted!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			selectedConfig = nil
		else
			Library:Notify("Failed to delete config!", 3)
		end
	end,
	DoubleClick = true,
	Tooltip = 'Double-click to delete the selected config'
})

local DebugBox = Tabs.Configs:AddRightGroupbox('Debug')

DebugBox:AddButton({
	Text = 'Print Current Config',
	Func = function()
		configFuncs.debugCurrentConfig()
		Library:Notify("Config info copied to clipboard!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'Copy current config state to clipboard'
})

local autoloadConfig = configFuncs.getAutoload()
if autoloadConfig then
	DebugBox:AddLabel('Autoload: ' .. autoloadConfig)
else
	DebugBox:AddLabel('Autoload: None')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOAD CONFIG ON STARTUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(2)
	
	local autoloadName = configFuncs.getAutoload()
	if autoloadName then
		print("ğŸ”„ Loading autoload config: " .. autoloadName)
		
		local success = configFuncs.loadConfig(autoloadName)
		
		if success then
			task.wait(0.5)
			
			-- Apply all settings (same as manual load)
			if Toggles.FarmToggle then
				Toggles.FarmToggle:SetValue(config.enabled)
			end
			
			if Toggles.MineToggle then
				Toggles.MineToggle:SetValue(config.miningEnabled)
			end
			
			if Toggles.AutoSellToggle then
				Toggles.AutoSellToggle:SetValue(config.autoSellEnabled)
			end
			
			if Options.HoverSpeed then
				Options.HoverSpeed:SetValue(config.hoverSpeed)
			end
			
			if Options.VerticalDistance then
				Options.VerticalDistance:SetValue(config.verticalDistance)
			end
			
			if Options.MiningVerticalDistance then
				Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
			end
			
			if Options.LockPosition then
				Options.LockPosition:SetValue(config.lockPosition)
			end
			
			if Options.MobSelection then
				local enabledMobs = {}
				for _, mobData in ipairs(config.mobTypes) do
					if mobData.enabled then
						enabledMobs[mobData.name] = true
					end
				end
				Options.MobSelection:SetValue(enabledMobs)
			end
			
			if Options.RockSelection then
				local enabledRocks = {}
				for _, rockData in ipairs(config.rockTypes) do
					if rockData.enabled then
						enabledRocks[rockData.name] = true
					end
				end
				Options.RockSelection:SetValue(enabledRocks)
			end
			
			if Options.CommonItems then
				local commonItems = {}
				for _, item in ipairs(config.selectedItems.Common or {}) do
					commonItems[item] = true
				end
				Options.CommonItems:SetValue(commonItems)
			end
			
			if Options.UncommonItems then
				local uncommonItems = {}
				for _, item in ipairs(config.selectedItems.Uncommon or {}) do
					uncommonItems[item] = true
				end
				Options.UncommonItems:SetValue(uncommonItems)
			end
			
			if Options.RareItems then
				local rareItems = {}
				for _, item in ipairs(config.selectedItems.Rare or {}) do
					rareItems[item] = true
				end
				Options.RareItems:SetValue(rareItems)
			end
			
			if Options.EpicItems then
				local epicItems = {}
				for _, item in ipairs(config.selectedItems.Epic or {}) do
					epicItems[item] = true
				end
				Options.EpicItems:SetValue(epicItems)
			end
			
			if Options.LegendaryItems then
				local legendaryItems = {}
				for _, item in ipairs(config.selectedItems.Legendary or {}) do
					legendaryItems[item] = true
				end
				Options.LegendaryItems:SetValue(legendaryItems)
			end
			
			if Options.MythicalItems then
				local mythicalItems = {}
				for _, item in ipairs(config.selectedItems.Mythical or {}) do
					mythicalItems[item] = true
				end
				Options.MythicalItems:SetValue(mythicalItems)
			end
			
			if Options.RuneItems then
				local runeItems = {}
				for _, item in ipairs(config.selectedItems.Rune or {}) do
					runeItems[item] = true
				end
				Options.RuneItems:SetValue(runeItems)
			end
			
			Library:Notify("Autoload config '" .. autoloadName .. "' loaded!", 4)
			print("âœ… Autoload complete!")
		else
			print("âŒ Autoload failed!")
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… FIXED KEYBIND SYSTEM (F1 = FARM, F2 = MINE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Library:OnUnload(function()
	Library.Unloaded = true
	
	if _G.KeybindConnection then
		_G.KeybindConnection:Disconnect()
		_G.KeybindConnection = nil
	end
end)

-- âœ… FIX: Setup keybinds after UI is fully ready
local function setupKeybinds()
	if _G.KeybindConnection then
		_G.KeybindConnection:Disconnect()
	end
	
	_G.KeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		-- Safety checks
		if not config then 
			warn("âš ï¸ Config not loaded")
			return 
		end
		
		if not Toggles then
			warn("âš ï¸ Toggles not initialized")
			return
		end
		
		-- F1 - Toggle Farming
		if input.KeyCode == Enum.KeyCode.F1 then
			if Toggles.FarmToggle then
				local newValue = not config.enabled
				Toggles.FarmToggle:SetValue(newValue)
				Library:Notify("Farming: " .. (newValue and "ON" or "OFF"), 2)
			else
				warn("âš ï¸ FarmToggle not found")
			end
			
		-- F2 - Toggle Mining
		elseif input.KeyCode == Enum.KeyCode.F2 then
			if Toggles.MineToggle then
				local newValue = not config.miningEnabled
				Toggles.MineToggle:SetValue(newValue)
				Library:Notify("Mining: " .. (newValue and "ON" or "OFF"), 2)
			else
				warn("âš ï¸ MineToggle not found")
			end
		end
	end)
	
	print("âœ… Keybinds ready: F1 = Farming | F2 = Mining")
end

-- âœ… FIX: Delay keybind setup until everything is ready
task.spawn(function()
	task.wait(1.5)
	setupKeybinds()
	print("âœ… Keybind system initialized!")
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THEME MANAGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder('RafsoHub')
ThemeManager:ApplyToTab(Tabs.Settings)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 5.5: SETTINGS & CONFIG MANAGEMENT TABS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'K', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

MenuGroup:AddDivider()

MenuGroup:AddButton({
	Text = 'Destroy GUI',
	Func = function()
		if Toggles.FarmToggle then
			Toggles.FarmToggle:SetValue(false)
		end
		if Toggles.MineToggle then
			Toggles.MineToggle:SetValue(false)
		end
		if Toggles.AutoSellToggle then
			Toggles.AutoSellToggle:SetValue(false)
		end
		if Toggles.AutoJoinWorld2 then
			Toggles.AutoJoinWorld2:SetValue(false)
		end
		
		task.wait(0.5)
		
		if _G.KeybindConnection then
			_G.KeybindConnection:Disconnect()
			_G.KeybindConnection = nil
		end
		
		_G.AutoLoopFunctions.stopAutoAttack()
		_G.AutoLoopFunctions.stopAutoMine()
		_G.AutoLoopFunctions.stopAutoSell()
		stopWorld2AutoJoin()
		
		funcs.stopNoclip()
		funcs.cleanupPhysicsMovement()
		
		_G.MobFarmConfig = nil
		_G.FarmFunctions = nil
		_G.AutoLoopFunctions = nil
		_G.ConfigFunctions = nil
		_G.UIReferences = nil
		
		Library:Unload()
	end,
	DoubleClick = false,
	Tooltip = 'Close and destroy the GUI'
})

local GeneralSettingsBox = Tabs.Settings:AddRightGroupbox('General Settings')

GeneralSettingsBox:AddSlider('HoverSpeed', {
	Text = 'Hover Speed',
	Default = 80,
	Min = 20,
	Max = 140,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.hoverSpeed = Value
	end
})

local FarmSettingsBox = Tabs.Settings:AddRightGroupbox('Farm Settings')

FarmSettingsBox:AddSlider('VerticalDistance', {
	Text = 'Vertical Distance',
	Default = 8,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.verticalDistance = Value
	end
})

local MiningSettingsBox = Tabs.Settings:AddRightGroupbox('Mining Settings')

MiningSettingsBox:AddSlider('MiningVerticalDistance', {
	Text = 'Mining Vertical Distance',
	Default = 6,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.miningVerticalDistance = Value
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFIG MANAGEMENT TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local configFuncs = _G.ConfigFunctions

local ConfigManagementBox = Tabs.Configs:AddLeftGroupbox('Config Management')

local selectedConfig = nil

ConfigManagementBox:AddInput('ConfigName', {
	Default = '',
	Numeric = false,
	Finished = false,
	Text = 'Config Name',
	Tooltip = 'Enter a name for your config',
	Placeholder = 'Enter config name...',
})

ConfigManagementBox:AddDropdown('ConfigSelector', {
	Values = configFuncs.getConfigList(),
	Default = 1,
	Multi = false,
	Text = 'Select Config',
	Tooltip = 'Choose a config to load/delete',
	Callback = function(Value)
		selectedConfig = Value
	end
})

ConfigManagementBox:AddDivider()

ConfigManagementBox:AddButton({
	Text = 'Refresh Configs',
	Func = function()
		local configList = configFuncs.getConfigList()
		Options.ConfigSelector:SetValues(configList)
		Library:Notify("Found " .. #configList .. " config(s)", 2)
	end,
	DoubleClick = false,
	Tooltip = 'Refresh the config list'
})

ConfigManagementBox:AddButton({
	Text = 'Create Config',
	Func = function()
		local configName = Options.ConfigName.Value
		
		if configName == "" or configName == nil then
			Library:Notify("Please enter a config name!", 3)
			return
		end
		
		configName = configName:gsub("%s+", "_")
		
		local success = configFuncs.saveConfig(configName)
		
		if success then
			Library:Notify("Config '" .. configName .. "' created!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			Options.ConfigSelector:SetValue(configName)
			selectedConfig = configName
			
			Options.ConfigName:SetValue("")
		else
			Library:Notify("Failed to create config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Create a new config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Load Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.loadConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' loaded!", 3)
			
			task.wait(0.2)
			
			Toggles.FarmToggle:SetValue(config.enabled)
			Toggles.MineToggle:SetValue(config.miningEnabled)
			Toggles.AutoSellToggle:SetValue(config.autoSellEnabled)
			Options.HoverSpeed:SetValue(config.hoverSpeed)
			Options.VerticalDistance:SetValue(config.verticalDistance)
			Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
			Options.LockPosition:SetValue(config.lockPosition)
			
			local enabledMobs = {}
			for _, mobData in ipairs(config.mobTypes) do
				if mobData.enabled then
					enabledMobs[mobData.name] = true
				end
			end
			Options.MobSelection:SetValue(enabledMobs)
			
			local enabledRocks = {}
			for _, rockData in ipairs(config.rockTypes) do
				if rockData.enabled then
					enabledRocks[rockData.name] = true
				end
			end
			Options.RockSelection:SetValue(enabledRocks)
			
			local commonItems = {}
			for _, item in ipairs(config.selectedItems.Common or {}) do
				commonItems[item] = true
			end
			Options.CommonItems:SetValue(commonItems)
			
			local uncommonItems = {}
			for _, item in ipairs(config.selectedItems.Uncommon or {}) do
				uncommonItems[item] = true
			end
			Options.UncommonItems:SetValue(uncommonItems)
			
			local rareItems = {}
			for _, item in ipairs(config.selectedItems.Rare or {}) do
				rareItems[item] = true
			end
			Options.RareItems:SetValue(rareItems)
			
			local epicItems = {}
			for _, item in ipairs(config.selectedItems.Epic or {}) do
				epicItems[item] = true
			end
			Options.EpicItems:SetValue(epicItems)
			
			local legendaryItems = {}
			for _, item in ipairs(config.selectedItems.Legendary or {}) do
				legendaryItems[item] = true
			end
			Options.LegendaryItems:SetValue(legendaryItems)
			
			local mythicalItems = {}
			for _, item in ipairs(config.selectedItems.Mythical or {}) do
				mythicalItems[item] = true
			end
			Options.MythicalItems:SetValue(mythicalItems)
			
			local runeItems = {}
			for _, item in ipairs(config.selectedItems.Rune or {}) do
				runeItems[item] = true
			end
			Options.RuneItems:SetValue(runeItems)
		else
			Library:Notify("Failed to load config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Load the selected config'
})

ConfigManagementBox:AddButton({
	Text = 'Overwrite Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.saveConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' overwritten!", 3)
		else
			Library:Notify("Failed to overwrite config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Overwrite selected config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Set as Autoload',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		configFuncs.setAutoload(selectedConfig)
		Library:Notify("Config '" .. selectedConfig .. "' set as autoload!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'This config will load automatically on startup'
})

ConfigManagementBox:AddButton({
	Text = 'Destroy Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local configToDelete = selectedConfig
		local success = configFuncs.deleteConfig(configToDelete)
		
		if success then
			Library:Notify("Config '" .. configToDelete .. "' deleted!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			selectedConfig = nil
		else
			Library:Notify("Failed to delete config!", 3)
		end
	end,
	DoubleClick = true,
	Tooltip = 'Double-click to delete the selected config'
})

local DebugBox = Tabs.Configs:AddRightGroupbox('Debug')

DebugBox:AddButton({
	Text = 'Print Current Config',
	Func = function()
		configFuncs.debugCurrentConfig()
		Library:Notify("Config info copied to clipboard!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'Copy current config state to clipboard'
})

local autoloadConfig = configFuncs.getAutoload()
if autoloadConfig then
	DebugBox:AddLabel('Autoload: ' .. autoloadConfig)
else
	DebugBox:AddLabel('Autoload: None')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STORE REFERENCES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_G.UIReferences.mobOptions = mobOptions
_G.UIReferences.rockOptions = rockOptions
_G.UIReferences.Toggles = Toggles
_G.UIReferences.Options = Options

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOAD CONFIG ON STARTUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(3)
	
	local autoloadName = configFuncs.getAutoload()
	if autoloadName then
		local success = configFuncs.loadConfig(autoloadName)
		
		if success then
			task.wait(0.5)
			
			Toggles.FarmToggle:SetValue(config.enabled)
			Toggles.MineToggle:SetValue(config.miningEnabled)
			Toggles.AutoSellToggle:SetValue(config.autoSellEnabled)
			Options.HoverSpeed:SetValue(config.hoverSpeed)
			Options.VerticalDistance:SetValue(config.verticalDistance)
			Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
			Options.LockPosition:SetValue(config.lockPosition)
			
			local enabledMobs = {}
			for _, mobData in ipairs(config.mobTypes) do
				if mobData.enabled then
					enabledMobs[mobData.name] = true
				end
			end
			Options.MobSelection:SetValue(enabledMobs)
			
			local enabledRocks = {}
			for _, rockData in ipairs(config.rockTypes) do
				if rockData.enabled then
					enabledRocks[rockData.name] = true
				end
			end
			Options.RockSelection:SetValue(enabledRocks)
			
			local commonItems = {}
			for _, item in ipairs(config.selectedItems.Common or {}) do
				commonItems[item] = true
			end
			Options.CommonItems:SetValue(commonItems)
			
			local uncommonItems = {}
			for _, item in ipairs(config.selectedItems.Uncommon or {}) do
				uncommonItems[item] = true
			end
			Options.UncommonItems:SetValue(uncommonItems)
			
			local rareItems = {}
			for _, item in ipairs(config.selectedItems.Rare or {}) do
				rareItems[item] = true
			end
			Options.RareItems:SetValue(rareItems)
			
			local epicItems = {}
			for _, item in ipairs(config.selectedItems.Epic or {}) do
				epicItems[item] = true
			end
			Options.EpicItems:SetValue(epicItems)
			
			local legendaryItems = {}
			for _, item in ipairs(config.selectedItems.Legendary or {}) do
				legendaryItems[item] = true
			end
			Options.LegendaryItems:SetValue(legendaryItems)
			
			local mythicalItems = {}
			for _, item in ipairs(config.selectedItems.Mythical or {}) do
				mythicalItems[item] = true
			end
			Options.MythicalItems:SetValue(mythicalItems)
			
			local runeItems = {}
			for _, item in ipairs(config.selectedItems.Rune or {}) do
				runeItems[item] = true
			end
			Options.RuneItems:SetValue(runeItems)
			
			Library:Notify("Autoload config '" .. autoloadName .. "' loaded!", 4)
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… FIXED KEYBIND SYSTEM (F1 = FARM, F2 = MINE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Library:OnUnload(function()
	Library.Unloaded = true
	
	-- Disconnect keybinds on unload
	if _G.KeybindConnection then
		_G.KeybindConnection:Disconnect()
		_G.KeybindConnection = nil
	end
end)

local UserInputService = game:GetService("UserInputService")

-- âœ… FIX: Wrap in pcall and add safety checks
local function setupKeybinds()
	if _G.KeybindConnection then
		_G.KeybindConnection:Disconnect()
	end
	
	_G.KeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		-- Don't trigger if typing in chat/textbox
		if gameProcessed then return end
		
		-- âœ… FIX: Add safety checks
		if not _G.MobFarmConfig then 
			print("âš ï¸ Config not loaded yet")
			return 
		end
		if not Toggles then
			print("âš ï¸ Toggles not initialized yet")
			return
		end
		
		-- F1 - Toggle Farming
		if input.KeyCode == Enum.KeyCode.F1 then
			if Toggles.FarmToggle then
				local newValue = not config.enabled
				Toggles.FarmToggle:SetValue(newValue)
				Library:Notify("Farming: " .. (newValue and "ON" or "OFF"), 2)
			else
				print("âš ï¸ FarmToggle not found")
			end
			
		-- F2 - Toggle Mining
		elseif input.KeyCode == Enum.KeyCode.F2 then
			if Toggles.MineToggle then
				local newValue = not config.miningEnabled
				Toggles.MineToggle:SetValue(newValue)
				Library:Notify("Mining: " .. (newValue and "ON" or "OFF"), 2)
			else
				print("âš ï¸ MineToggle not found")
			end
		end
	end)
	
	print("âœ… Keybinds initialized: F1 = Farming | F2 = Mining")
end

-- âœ… FIX: Delay keybind setup until UI is ready
task.spawn(function()
	task.wait(1) -- Wait for UI to fully initialize
	setupKeybinds()
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THEME MANAGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder('RafsoHub')
ThemeManager:ApplyToTab(Tabs.Settings)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 6: MAIN LOOPS & CHARACTER RESPAWN (WITH MINING DEFENSE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

Vector3.new(-44.71, -5.12, -273.02)
local SKIP_HOVER_DISTANCE = 150

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- IMPROVED MESSAGE DETECTION SYSTEM (INSTANT ROCK SWITCH)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local lastMessageTime = 0
local MESSAGE_COOLDOWN = 0.5

local function switchToNewRock(reason)
	if config.currentRock and config.miningEnabled then
		table.insert(config.ignoredRocks, config.currentRock)
		
		config.currentRock = nil
		config.lastRockDurability = nil
		config.isLockedOn = false
		
		local character = LocalPlayer.Character
		if character then
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if rootPart and config.bodyVelocity then
				config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			end
		end
	end
end

local function setupTextLabelMonitoring()
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
	if not playerGui then return end
	
	local function monitorTextLabel(textLabel)
		if not textLabel:IsA("TextLabel") then return end
		
		local connection
		connection = textLabel:GetPropertyChangedSignal("Text"):Connect(function()
			if (tick() - lastMessageTime) < MESSAGE_COOLDOWN then return end
			
			local text = textLabel.Text:lower()
			
			if text:find("someone else is already mining this rock.") or 
			   text:find("someone else") or 
			   text:find("being mined") or
			   text:find("another player") then
				
				lastMessageTime = tick()
				switchToNewRock("Detected: Another player is mining this rock!")
			end
		end)
	end
	
	for _, gui in pairs(playerGui:GetDescendants()) do
		monitorTextLabel(gui)
	end
	
	playerGui.DescendantAdded:Connect(function(descendant)
		task.wait(0.05)
		monitorTextLabel(descendant)
	end)
end

local function setupStarterGuiMonitoring()
	local starterGui = game:GetService("StarterGui")
	
	local oldSetCore = starterGui.SetCore
	starterGui.SetCore = function(self, ...)
		local args = {...}
		if args[1] == "ChatMakeSystemMessage" or args[1] == "SendNotification" then
			local message = ""
			if type(args[2]) == "table" then
				message = tostring(args[2].Text or ""):lower()
			else
				message = tostring(args[2] or ""):lower()
			end
			
			if message:find("already mining") or 
			   message:find("someone else") or 
			   message:find("being mined") then
				
				switchToNewRock("Detected notification: Rock being mined by another player!")
			end
		end
		return oldSetCore(self, ...)
	end
end

local function setupCommonGuiMonitoring()
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
	if not playerGui then return end
	
	local commonPaths = {
		"Notifications",
		"SystemMessages", 
		"Messages",
		"Hints",
		"Popups",
		"ErrorMessages",
		"Chat"
	}
	
	for _, guiName in ipairs(commonPaths) do
		local gui = playerGui:FindFirstChild(guiName)
		if gui then
			gui.DescendantAdded:Connect(function(descendant)
				if descendant:IsA("TextLabel") or descendant:IsA("TextBox") then
					task.wait(0.05)
					local text = descendant.Text:lower()
					
					if text:find("already mining") or 
					   text:find("someone else") or 
					   text:find("being mined") then
						
						switchToNewRock("Detected in " .. guiName .. ": Rock occupied!")
					end
				end
			end)
		end
	end
end

local function setupChatMonitoring()
	local textChatService = game:GetService("TextChatService")
	
	pcall(function()
		textChatService.MessageReceived:Connect(function(message)
			local text = message.Text:lower()
			if text:find("already mining") or 
			   text:find("someone else") or 
			   text:find("being mined") then
				
				switchToNewRock("Detected in chat: Rock occupied!")
			end
		end)
	end)
end

task.spawn(function()
	task.wait(1)
	
	setupTextLabelMonitoring()
	setupStarterGuiMonitoring()
	setupCommonGuiMonitoring()
	setupChatMonitoring()
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PROXIMITY CHECK
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function checkProximityToTarget()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	local currentPos = rootPart.Position
	
	if config.enabled then
		local closestMob = funcs.getClosestMob()
		if closestMob then
			local mobRoot = closestMob:FindFirstChild("HumanoidRootPart")
			if mobRoot then
				local distance = (currentPos - mobRoot.Position).Magnitude
				if distance <= SKIP_HOVER_DISTANCE then
					return true
				end
			end
		end
	end
	
	if config.miningEnabled then
		local closestRock = funcs.getClosestRock()
		if closestRock then
			local positionPart = funcs.getRockPosition(closestRock)
			if positionPart then
				local distance = (currentPos - positionPart.Position).Magnitude
				if distance <= SKIP_HOVER_DISTANCE then
					return true
				end
			end
		end
	end
	
	return false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEFENSE ATTACK FUNCTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local VirtualInputManager = game:GetService("VirtualInputManager")

local function clickMouseForDefense()
	local success = pcall(function()
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		task.wait(0.01)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end)
	return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN FARMING LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Living = workspace:WaitForChild("Living")

local farmLoop = RunService.Heartbeat:Connect(function()
	if not config.enabled or config.isRespawning then return end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		return
	end
	
	-- Check proximity for hover skip
	if config.hoverSequenceActive and config.currentHoverTarget == 1 then
		if checkProximityToTarget() then
			config.hoverSequenceActive = false
			config.currentHoverTarget = 3
			return
		end
	end
	
	-- Execute hover sequence
	if config.hoverSequenceActive then
		if config.currentHoverTarget == 1 then
			if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
				config.currentHoverTarget = 2
			end
		elseif config.currentHoverTarget == 2 then
			if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
				config.currentHoverTarget = 3
				config.hoverSequenceActive = false
			end
		end
		return
	end
	
	-- Check if current mob is still valid
	local needNewMob = not config.currentMob or not config.currentMob.Parent or not funcs.isValidMob(config.currentMob)
	
	if needNewMob then
		config.currentMob = funcs.getClosestMob()
		return
	end
	
	-- Move to mob
	if config.currentMob then
		local lockPos = funcs.getLockPosition(config.currentMob)
		if lockPos then
			funcs.hoverToMob(lockPos, config.currentMob)
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN MINING LOOP (WITH DEFENSE SYSTEM)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local miningLoop = RunService.Heartbeat:Connect(function()
	if not config.miningEnabled then 
		if config.currentRock then
			config.currentRock = nil
			config.lastRockDurability = nil
			config.isLockedOn = false
		end
		if config.defendingAgainstMob then
			config.defendingAgainstMob = nil
			config.savedMiningRock = nil
			config.weaponEquipped = false
		end
		return 
	end
	
	if config.isRespawning then return end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		return
	end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MINING DEFENSE SYSTEM - Check for nearby mobs
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if config.miningDefenseEnabled then
		local closestThreat = nil
		local closestDistance = config.miningDefenseDistance
		
		-- Scan for nearby hostile mobs
		for _, child in pairs(Living:GetChildren()) do
			if funcs.isValidMob(child) then
				local mobRoot = child:FindFirstChild("HumanoidRootPart")
				if mobRoot then
					local distance = (rootPart.Position - mobRoot.Position).Magnitude
					if distance < closestDistance then
						closestThreat = child
						closestDistance = distance
					end
				end
			end
		end
		
		-- Start defending if threat detected and not already defending
		if closestThreat and not config.defendingAgainstMob then
			config.defendingAgainstMob = closestThreat
			config.savedMiningRock = config.currentRock
			config.currentRock = nil
			config.isLockedOn = false
			config.weaponEquipped = false
			
			-- Stop pickaxe check loop
			if pickaxeCheckLoop then
				pickaxeCheckLoop:Disconnect()
				pickaxeCheckLoop = nil
			end
			
			return
		end
		
		-- Update threat if already defending
		if closestThreat and config.defendingAgainstMob then
			config.defendingAgainstMob = closestThreat
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- DEFENSE MODE - Fight the mob
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if config.defendingAgainstMob then
		-- Check if mob is still valid
		if not config.defendingAgainstMob.Parent or not funcs.isValidMob(config.defendingAgainstMob) then
			config.defendingAgainstMob = nil
			config.weaponEquipped = false
			config.isLockedOn = false
			
			-- Unequip weapon
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid:UnequipTools()
				task.wait(0.2)
			end
			
			-- Restore mining rock
			config.currentRock = config.savedMiningRock
			config.savedMiningRock = nil
			
			-- Restart pickaxe check loop
			_G.AutoLoopFunctions.startAutoMine()
			
			return
		end
		
		-- Equip weapon if not equipped
		if not config.weaponEquipped then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid:UnequipTools()
				task.wait(0.2)
			end
			
			local backpack = LocalPlayer:FindFirstChild("Backpack")
			if backpack then
				local weapon = backpack:FindFirstChild("Weapon")
				if weapon and weapon:IsA("Tool") then
					humanoid:EquipTool(weapon)
					task.wait(0.3)
					config.weaponEquipped = true
				end
			end
			return
		end
		
		-- Move to mob and attack
		local lockPos = funcs.getLockPosition(config.defendingAgainstMob)
		if lockPos then
			local distance = (rootPart.Position - lockPos).Magnitude
			
			funcs.hoverToMob(lockPos, config.defendingAgainstMob)
			
			if distance < 3 then
				config.isLockedOn = true
				
				local currentTime = tick()
				if currentTime - config.lastDefenseAttackTime >= config.defenseAttackCooldown then
					config.lastDefenseAttackTime = currentTime
					clickMouseForDefense()
				end
			end
		end
		
		return
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- NORMAL MINING MODE
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Check proximity for hover skip
	if config.hoverSequenceActive and config.currentHoverTarget == 1 then
		if checkProximityToTarget() then
			config.hoverSequenceActive = false
			config.currentHoverTarget = 3
			return
		end
	end
	
	-- Execute hover sequence
	if config.hoverSequenceActive then
		if config.currentHoverTarget == 1 then
			if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
				config.currentHoverTarget = 2
			end
		elseif config.currentHoverTarget == 2 then
			if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
				config.currentHoverTarget = 3
				config.hoverSequenceActive = false
			end
		end
		return
	end
	
	-- Check if current rock is still valid
	if config.currentRock and (not config.currentRock.Parent or not funcs.isValidRock(config.currentRock)) then
		config.currentRock = nil
		config.lastRockDurability = nil
		return
	end
	
	-- Get new rock if needed
	if not config.currentRock then
		config.currentRock = funcs.getClosestRock()
		
		if config.currentRock then
			config.lastRockDurability = funcs.getRockDurability(config.currentRock)
			config.rockDurabilityCheck = tick()
			funcs.makeRockTransparent(config.currentRock)
		end
		return
	end
	
	-- Move to rock
	if config.currentRock then
		local rockPos = funcs.getMiningPosition(config.currentRock)
		if rockPos then
			funcs.hoverToRock(rockPos, config.currentRock)
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CHARACTER RESPAWN HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LocalPlayer.CharacterAdded:Connect(function(character)
	config.currentMob = nil
	config.currentRock = nil
	config.isLockedOn = false
	config.isRespawning = true
	config.hoverSequenceActive = false
	config.defendingAgainstMob = nil
	config.savedMiningRock = nil
	config.weaponEquipped = false
	
	funcs.cleanupPhysicsMovement()
	funcs.stopNoclip()
	
	local wasFarming = config.enabled
	local wasMining = config.miningEnabled
	
	if wasFarming or wasMining then
		character:WaitForChild("HumanoidRootPart", 10)
		task.wait(3)
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if rootPart then
			config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
			config.hoverSequenceActive = true
			config.currentHoverTarget = 1
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			
			if wasFarming then 
				funcs.autoEquipWeapon()
			end
			if wasMining then 
				funcs.autoEquipPickaxe()
				config.ignoredRocks = {}
				config.lastRockDurability = nil
				config.rockDurabilityCheck = tick()
			end
		end
		
		config.isRespawning = false
	else
		config.isRespawning = false
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-INITIALIZATION FOR AUTOSELL
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(0)
	funcs.talkToSeller()
end)
