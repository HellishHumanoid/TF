	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- RAFSO'S COMPLETE SCRIPT - PART 1: CORE SETUP & CONFIG (WITH CLIPBOARD DEBUG)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Services
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local VirtualInputManager = game:GetService("VirtualInputManager")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local LocalPlayer = Players.LocalPlayer
	local Living = workspace:WaitForChild("Living")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- HOVER POSITIONS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local HOVER_HEIGHT = 85
	local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AUTOSELL CONFIG
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
	local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
	local NO_BUTTON_X = 1200
	local NO_BUTTON_Y = 498

	local originalPosition = nil

	-- Remote for selling
	local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- ITEMS BY RARITY (FOR AUTOSELL)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local ItemsByRarity = {
		Common = {
			"Stone",
			"Sand Stone",
			"Copper",
			"Iron",
			"Cardboardite"
		},
		Uncommon = {
			"Cobalt",
			"Titanium",
			"Lapis Lazuli",
			"Tin",
			"Silver",
			"Gold",
			"Bananite"
		},
		Rare = {
			"Volcanic Rock",
			"Quartz",
			"Amethyst",
			"Boneite",
			"Dark Boneite",
			"Topaz",
			"Diamond",
			"Sapphire",
			"Mushroomite",
			"Platinum"
		},
		Epic = {
			"Aite",
			"Slimite",
			"Poopite",
			"Cuprite",
			"Obsidian",
			"Emerald",
			"Ruby",
			"Rivalite"
		},
		Legendary = {
			"Uranium",
			"Mythril",
			"Eye Ore",
			"Fireite",
			"Magmaite",
			"Lightite"
		},
		Mythical = {
			"Demonite",
			"Darkryte"
		},
		Rune = {
			"Frost Speck",
			"Venom Crumb",
			"Blast Chip",
			"Miner Shard",
			"Flame Spark",
			"Drain Edge",
			"Briar Notch",
			"Ward Patch",
			"Rot Stich",
			"Chill Dust",
			"Rage Mark"
		}
	}

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CONFIG SAVE/LOAD SYSTEM (WITH CLIPBOARD DEBUG)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local CONFIG_FOLDER = "RafsoHubConfigs"
	local CONFIG_LIST_FILE = CONFIG_FOLDER .. "/ConfigList.json"
	local AUTOLOAD_FILE = CONFIG_FOLDER .. "/AutoLoad.txt"

	-- Debug log storage
	local debugLog = ""

	local function addToLog(message)
		print(message)
		debugLog = debugLog .. message .. "\n"
	end

	local function clearLog()
		debugLog = ""
	end

	-- Ensure config folder exists
	if not isfolder(CONFIG_FOLDER) then
		makefolder(CONFIG_FOLDER)
		print("ğŸ“ Created config folder: " .. CONFIG_FOLDER)
	end

	-- Save configuration
	local function saveConfig(configName)
		clearLog()
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		addToLog("ğŸ’¾ SAVING CONFIG: " .. configName)
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		
		-- Capture current state
		local configData = {
			-- Farming settings
			behindDistance = _G.MobFarmConfig.behindDistance,
			verticalDistance = _G.MobFarmConfig.verticalDistance,
			farmDistance = _G.MobFarmConfig.farmDistance,
			hoverSpeed = _G.MobFarmConfig.hoverSpeed,
			lockPosition = _G.MobFarmConfig.lockPosition,
			aboveAngle = _G.MobFarmConfig.aboveAngle,
			belowAngle = _G.MobFarmConfig.belowAngle,
			
			-- Mob types
			mobTypes = {},
			
			-- Mining settings
			miningVerticalDistance = _G.MobFarmConfig.miningVerticalDistance,
			miningAngle = _G.MobFarmConfig.miningAngle,
			ignoreGoblinCave = _G.MobFarmConfig.ignoreGoblinCave,
			
			-- Rock types
			rockTypes = {},
			
			-- AutoSell settings
			selectedItems = _G.MobFarmConfig.selectedItems
		}
		
		addToLog("ğŸ“Š Current settings being saved:")
		addToLog("  Hover Speed: " .. configData.hoverSpeed)
		addToLog("  Vertical Distance: " .. configData.verticalDistance)
		addToLog("  Mining Vertical Distance: " .. configData.miningVerticalDistance)
		addToLog("  Lock Position: " .. configData.lockPosition)
		
		-- Save mob types
		local enabledMobCount = 0
		for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
			table.insert(configData.mobTypes, {
				name = mobData.name,
				enabled = mobData.enabled,
				priority = mobData.priority
			})
			if mobData.enabled then
				addToLog("  âœ… Mob: " .. mobData.name)
				enabledMobCount = enabledMobCount + 1
			end
		end
		addToLog("Total enabled mobs: " .. enabledMobCount)
		
		-- Save rock types
		local enabledRockCount = 0
		for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
			table.insert(configData.rockTypes, {
				name = rockData.name,
				enabled = rockData.enabled,
				priority = rockData.priority
			})
			if rockData.enabled then
				addToLog("  â›ï¸ Rock: " .. rockData.name)
				enabledRockCount = enabledRockCount + 1
			end
		end
		addToLog("Total enabled rocks: " .. enabledRockCount)
		
		-- Debug: Print AutoSell items
		addToLog("ğŸ’° AutoSell items:")
		local totalItems = 0
		for rarity, items in pairs(configData.selectedItems) do
			if #items > 0 then
				addToLog("  " .. rarity .. " (" .. #items .. "): " .. table.concat(items, ", "))
				totalItems = totalItems + #items
			end
		end
		addToLog("Total AutoSell items: " .. totalItems)
		
		-- Write to file
		local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
		local success, err = pcall(function()
			local jsonData = game:GetService("HttpService"):JSONEncode(configData)
			writefile(configPath, jsonData)
		end)
		
		if not success then
			addToLog("âŒ Failed to write config file: " .. tostring(err))
			setclipboard(debugLog)
			return false
		end
		
		addToLog("âœ… Config file written to: " .. configPath)
		
		-- Update config list
		local configList = {}
		if isfile(CONFIG_LIST_FILE) then
			local listSuccess, listData = pcall(function()
				return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
			end)
			if listSuccess then
				configList = listData
			end
		end
		
		if not table.find(configList, configName) then
			table.insert(configList, configName)
			writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
			addToLog("âœ… Added to config list")
		end
		
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		addToLog("âœ… CONFIG SAVED SUCCESSFULLY")
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		
		setclipboard(debugLog)
		return true
	end

	-- Load configuration
	local function loadConfig(configName)
		clearLog()
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		addToLog("ğŸ“‚ LOADING CONFIG: " .. configName)
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		
		local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
		
		if not isfile(configPath) then
			addToLog("âŒ Config file not found: " .. configPath)
			setclipboard(debugLog)
			return false
		end
		
		addToLog("âœ… Config file exists")
		
		local success, configData = pcall(function()
			local fileContent = readfile(configPath)
			return game:GetService("HttpService"):JSONDecode(fileContent)
		end)
		
		if not success then
			addToLog("âŒ Failed to parse config JSON: " .. tostring(configData))
			setclipboard(debugLog)
			return false
		end
		
		addToLog("âœ… Config JSON parsed successfully")
		
		-- Apply basic settings
		_G.MobFarmConfig.behindDistance = configData.behindDistance or 8
		_G.MobFarmConfig.verticalDistance = configData.verticalDistance or 8
		_G.MobFarmConfig.farmDistance = configData.farmDistance or 1000
		_G.MobFarmConfig.hoverSpeed = configData.hoverSpeed or 80
		_G.MobFarmConfig.lockPosition = configData.lockPosition or "Below"
		_G.MobFarmConfig.aboveAngle = configData.aboveAngle or 90
		_G.MobFarmConfig.belowAngle = configData.belowAngle or 240
		
		addToLog("ğŸ“Š Settings loaded:")
		addToLog("  Hover Speed: " .. _G.MobFarmConfig.hoverSpeed)
		addToLog("  Vertical Distance: " .. _G.MobFarmConfig.verticalDistance)
		addToLog("  Lock Position: " .. _G.MobFarmConfig.lockPosition)
		
		-- Apply mob types
		local loadedMobCount = 0
		if configData.mobTypes then
			for i, savedMob in ipairs(configData.mobTypes) do
				if _G.MobFarmConfig.mobTypes[i] then
					_G.MobFarmConfig.mobTypes[i].enabled = savedMob.enabled
					if savedMob.enabled then
						addToLog("  âœ… Enabled mob: " .. savedMob.name)
						loadedMobCount = loadedMobCount + 1
					end
				end
			end
		end
		addToLog("Total mobs enabled: " .. loadedMobCount)
		
		-- Apply mining settings
		_G.MobFarmConfig.miningVerticalDistance = configData.miningVerticalDistance or 6
		_G.MobFarmConfig.miningAngle = configData.miningAngle or 270
		_G.MobFarmConfig.ignoreGoblinCave = configData.ignoreGoblinCave ~= false
		
		addToLog("â›ï¸ Mining settings loaded:")
		addToLog("  Mining Vertical Distance: " .. _G.MobFarmConfig.miningVerticalDistance)
		
		-- Apply rock types
		local loadedRockCount = 0
		if configData.rockTypes then
			for i, savedRock in ipairs(configData.rockTypes) do
				if _G.MobFarmConfig.rockTypes[i] then
					_G.MobFarmConfig.rockTypes[i].enabled = savedRock.enabled
					if savedRock.enabled then
						addToLog("  âœ… Enabled rock: " .. savedRock.name)
						loadedRockCount = loadedRockCount + 1
					end
				end
			end
		end
		addToLog("Total rocks enabled: " .. loadedRockCount)
		
		-- Apply autosell items
		if configData.selectedItems then
			_G.MobFarmConfig.selectedItems = configData.selectedItems
			
			addToLog("ğŸ’° AutoSell items loaded:")
			local totalItems = 0
			for rarity, items in pairs(configData.selectedItems) do
				if #items > 0 then
					addToLog("  " .. rarity .. " (" .. #items .. "): " .. table.concat(items, ", "))
					totalItems = totalItems + #items
				end
			end
			addToLog("Total AutoSell items: " .. totalItems)
		end
		
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		addToLog("âœ… CONFIG LOADED SUCCESSFULLY")
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		
		setclipboard(debugLog)
		return true
	end

	-- Get list of saved configs
	local function getConfigList()
		if not isfile(CONFIG_LIST_FILE) then
			return {}
		end
		
		local success, configList = pcall(function()
			return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
		end)
		
		if success then
			return configList
		else
			return {}
		end
	end

	-- Delete configuration
	local function deleteConfig(configName)
		clearLog()
		addToLog("ğŸ—‘ï¸ Deleting config: " .. configName)
		
		local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
		
		if isfile(configPath) then
			delfile(configPath)
			addToLog("âœ… Deleted config file")
		end
		
		-- Update config list
		local configList = getConfigList()
		for i, name in ipairs(configList) do
			if name == configName then
				table.remove(configList, i)
				writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
				addToLog("âœ… Removed from config list")
				break
			end
		end
		
		-- Remove autoload if it was this config
		if isfile(AUTOLOAD_FILE) and readfile(AUTOLOAD_FILE) == configName then
			delfile(AUTOLOAD_FILE)
			addToLog("âœ… Removed from autoload")
		end
		
		addToLog("âœ… Config deleted successfully")
		setclipboard(debugLog)
		return true
	end

	-- Set autoload config
	local function setAutoload(configName)
		clearLog()
		writefile(AUTOLOAD_FILE, configName)
		addToLog("ğŸ”„ Autoload set to: " .. configName)
		addToLog("ğŸ“ Written to: " .. AUTOLOAD_FILE)
		setclipboard(debugLog)
	end

	-- Get autoload config
	local function getAutoload()
		if isfile(AUTOLOAD_FILE) then
			local autoloadName = readfile(AUTOLOAD_FILE)
			print("ğŸ“– Autoload config found: " .. autoloadName)
			return autoloadName
		end
		print("âŒ No autoload config set")
		return nil
	end

	-- Debug function to print current config state
	local function debugCurrentConfig()
		clearLog()
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		addToLog("ğŸ” CURRENT CONFIG STATE")
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		addToLog("Hover Speed: " .. _G.MobFarmConfig.hoverSpeed)
		addToLog("Vertical Distance: " .. _G.MobFarmConfig.verticalDistance)
		addToLog("Mining Vertical Distance: " .. _G.MobFarmConfig.miningVerticalDistance)
		addToLog("Lock Position: " .. _G.MobFarmConfig.lockPosition)
		
		addToLog("\nEnabled Mobs:")
		local mobCount = 0
		for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
			if mobData.enabled then
				addToLog("  - " .. mobData.name)
				mobCount = mobCount + 1
			end
		end
		if mobCount == 0 then
			addToLog("  (none)")
		end
		
		addToLog("\nEnabled Rocks:")
		local rockCount = 0
		for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
			if rockData.enabled then
				addToLog("  - " .. rockData.name)
				rockCount = rockCount + 1
			end
		end
		if rockCount == 0 then
			addToLog("  (none)")
		end
		
		addToLog("\nAutoSell Items:")
		local itemCount = 0
		for rarity, items in pairs(_G.MobFarmConfig.selectedItems) do
			if #items > 0 then
				addToLog("  " .. rarity .. ": " .. table.concat(items, ", "))
				itemCount = itemCount + #items
			end
		end
		if itemCount == 0 then
			addToLog("  (none)")
		end
		addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		
		setclipboard(debugLog)
	end

	-- Store config functions globally
	_G.ConfigFunctions = {
		saveConfig = saveConfig,
		loadConfig = loadConfig,
		getConfigList = getConfigList,
		deleteConfig = deleteConfig,
		setAutoload = setAutoload,
		getAutoload = getAutoload,
		debugCurrentConfig = debugCurrentConfig
	}

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- GLOBAL CONFIG
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	_G.MobFarmConfig = {
		-- Farming settings
		enabled = false,
		behindDistance = 8,
		verticalDistance = 8,
		farmDistance = 1000,
		hoverSpeed = 80,
		lockPosition = "Below",
		aboveAngle = 90,
		belowAngle = 240,
		
		-- Hover sequence
		hoverSequenceActive = false,
		currentHoverTarget = 1,
		hoverReachedThreshold = 3,
		hoverPosition1 = nil,
		
		-- Attack settings
		weaponRemote = nil,
		lastAttackTime = 0,
		attackCooldown = 0.25,
		lastWeaponCheckTime = 0,
		weaponCheckInterval = 0.5,
		
		-- State
		currentMob = nil,
		isLockedOn = false,
		bodyVelocity = nil,
		bodyGyro = nil,
		noclipLoop = nil,
		isRespawning = false,
		
		-- Mob types
		mobTypes = {
			{name = "Reaper", pattern = "^Reaper%d+$", enabled = false, priority = 1},
			{name = "Deathaxe Skeleton", pattern = "^Deathaxe Skeleton%d+$", enabled = false, priority = 2},
			{name = "Elite Deathaxe Skeleton", pattern = "^Elite Deathaxe Skeleton%d+$", enabled = false, priority = 3},
			{name = "Elite Rogue Skeleton", pattern = "^Elite Rogue Skeleton%d+$", enabled = false, priority = 4},
			{name = "Blazing Slime", pattern = "^Blazing Slime%d+$", enabled = false, priority = 5},
			{name = "Axe Skeleton", pattern = "^Axe Skeleton%d+$", enabled = false, priority = 6},
			{name = "Skeleton Rogue", pattern = "^Skeleton Rogue%d+$", enabled = false, priority = 7},
			{name = "Bomber", pattern = "^Bomber%d+$", enabled = false, priority = 8},
			{name = "Slime", pattern = "^Slime%d+$", enabled = false, priority = 9},
		},
		
		-- Mining system
		miningEnabled = false,
		miningVerticalDistance = 6,
		miningAngle = 270,
		currentRock = nil,
		lastMineTime = 0,
		miningCooldown = 0.1,
		lastPickaxeCheckTime = 0,
		pickaxeCheckInterval = 0.5,
		miningBodyVelocity = nil,
		miningBodyGyro = nil,
		ignoreGoblinCave = true,
		
		-- Rock damage tracking
		rockDurabilityCheck = 0,
		rockDurabilityCheckInterval = 3,
		lastRockDurability = nil,
		ignoredRocks = {},
		
		-- Rock types (PRIORITY ORDER)
		rockTypes = {
			{name = "Volcanic Rock", enabled = false, priority = 1},
			{name = "Earth Crystal", enabled = false, priority = 2},
			{name = "Violet Crystal", enabled = false, priority = 3},
			{name = "Crimson Crystal", enabled = false, priority = 4},
			{name = "Light Crystal", enabled = false, priority = 5},
			{name = "Cyan Crystal", enabled = false, priority = 6},
			{name = "Basalt Vein", enabled = false, priority = 7},
			{name = "Basalt Core", enabled = false, priority = 8},
			{name = "Basalt Rock", enabled = false, priority = 9},
			{name = "Boulder", enabled = false, priority = 10},
			{name = "Rock", enabled = false, priority = 11},
			{name = "Pebble", enabled = false, priority = 12},
		},
		
		-- AutoSell settings
		autoSellEnabled = false,
		sellCooldown = 1.5,
		lastSellTime = 0,
		autoClickerActive = false,
		autoClickerLoop = nil,
		selectedItems = {
			Common = {},
			Uncommon = {},
			Rare = {},
			Epic = {},
			Legendary = {},
			Mythical = {},
			Rune = {}
		}
	}

	local config = _G.MobFarmConfig

	print("âœ… Part 1 Loaded: Core Setup & Config (WITH CLIPBOARD COPY)")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PART 2: NOCLIP & MOB/ROCK DETECTION (X-RAY REMOVED)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	local Living = workspace:WaitForChild("Living")
	local config = _G.MobFarmConfig

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- NOCLIP SYSTEM
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function startNoclip()
		if config.noclipLoop then return end
		
		config.noclipLoop = RunService.Stepped:Connect(function()
			if not config.enabled and not config.miningEnabled then return end
			
			local character = LocalPlayer.Character
			if not character then return end
			
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
				end
			end
		end)
	end

	local function stopNoclip()
		if config.noclipLoop then
			config.noclipLoop:Disconnect()
			config.noclipLoop = nil
			
			local character = LocalPlayer.Character
			if character then
				for _, part in pairs(character:GetDescendants()) do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						part.CanCollide = true
					end
				end
			end
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MOB DETECTION
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function isValidMob(mob)
		local humanoid = mob:FindFirstChildOfClass("Humanoid")
		local rootPart = mob:FindFirstChild("HumanoidRootPart")
		
		if not humanoid or not rootPart then return false end
		if humanoid.Health <= 0 then return false end
		if Players:GetPlayerFromCharacter(mob) then return false end
		
		return true
	end

	local function matchesMobPattern(mobName, pattern)
		return string.match(mobName, pattern) ~= nil
	end

	local function getMobPriority(mob)
		for _, mobData in ipairs(config.mobTypes) do
			if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
				return mobData.priority
			end
		end
		return 999
	end

	local function getClosestMob()
		local character = LocalPlayer.Character
		if not character then return nil end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return nil end
		
		local closestMob = nil
		local closestDistance = config.farmDistance
		local highestPriority = 999
		
		for _, child in pairs(Living:GetChildren()) do
			if isValidMob(child) then
				for _, mobData in pairs(config.mobTypes) do
					if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
						local mobRoot = child:FindFirstChild("HumanoidRootPart")
						if mobRoot then
							local distance = (rootPart.Position - mobRoot.Position).Magnitude
							local priority = getMobPriority(child)
							
							if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
								closestMob = child
								closestDistance = distance
								highestPriority = priority
							end
						end
						break
					end
				end
			end
		end
		
		return closestMob
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- ROCK DETECTION (FOR MINING)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function isValidRock(durabilityModel)
		if not durabilityModel:IsA("Model") then return false end
		if not durabilityModel.Parent then return false end
		
		local hasMeshPart = durabilityModel:FindFirstChildOfClass("MeshPart") ~= nil
		
		return hasMeshPart
	end

	local function isRockIgnored(rock)
		for _, ignoredRock in ipairs(config.ignoredRocks) do
			if ignoredRock == rock then
				return true
			end
		end
		return false
	end

	local function getRockPriority(rockTypeName)
		for _, rockData in ipairs(config.rockTypes) do
			if rockData.enabled and rockTypeName == rockData.name then
				return rockData.priority
			end
		end
		return 999
	end

	local function getRockPosition(durabilityModel)
		local rockPart = durabilityModel:FindFirstChild("Rock")
		if rockPart and rockPart:IsA("BasePart") then
			return rockPart
		end
		
		local rockTypeModel = durabilityModel.Parent
		if rockTypeModel then
			local hitbox = rockTypeModel:FindFirstChild("Hitbox")
			if hitbox and hitbox:IsA("BasePart") then
				return hitbox
			end
		end
		
		local meshPart = durabilityModel:FindFirstChildOfClass("MeshPart")
		if meshPart then
			return meshPart
		end
		
		return nil
	end

	local function getRockDurability(rock)
		if not rock then return nil end
		return tonumber(rock.Name)
	end

	local function getClosestRock()
		local character = LocalPlayer.Character
		if not character then 
			return nil 
		end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then 
			return nil 
		end
		
		local rocksFolder = workspace:FindFirstChild("Rocks")
		if not rocksFolder then
			return nil
		end
		
		local closestRock = nil
		local closestDistance = config.farmDistance
		local highestPriority = 999
		
		for _, islandFolder in pairs(rocksFolder:GetChildren()) do
			if islandFolder:IsA("Folder") then
				if config.ignoreGoblinCave and islandFolder.Name == "Island2GoblinCave" then
					continue
				end
				
				for _, spawnPart in pairs(islandFolder:GetChildren()) do
					if spawnPart:IsA("Part") and spawnPart.Name == "SpawnLocation" then
						for _, rockTypeModel in pairs(spawnPart:GetChildren()) do
							if rockTypeModel:IsA("Model") then
								local rockTypeName = rockTypeModel.Name
								local priority = getRockPriority(rockTypeName)
								
								if priority < 999 then
									for _, durabilityModel in pairs(rockTypeModel:GetChildren()) do
										if durabilityModel:IsA("Model") and tonumber(durabilityModel.Name) then
											if not isRockIgnored(durabilityModel) and isValidRock(durabilityModel) then
												local positionPart = getRockPosition(durabilityModel)
												if positionPart then
													local distance = (rootPart.Position - positionPart.Position).Magnitude
													
													if distance <= config.farmDistance then
														if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
															closestRock = durabilityModel
															closestDistance = distance
															highestPriority = priority
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		
		return closestRock
	end

	local function makeRockTransparent(rock)
		if not rock then return end
		
		for _, descendant in pairs(rock:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				descendant.Transparency = 0.7
			end
		end
		
		local rockTypeModel = rock.Parent
		if rockTypeModel then
			for _, descendant in pairs(rockTypeModel:GetDescendants()) do
				if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
					descendant.Transparency = 0.7
				end
			end
		end
	end

	-- Store functions globally
	_G.FarmFunctions = {
		startNoclip = startNoclip,
		stopNoclip = stopNoclip,
		getClosestMob = getClosestMob,
		getClosestRock = getClosestRock,
		isValidMob = isValidMob,
		isValidRock = isValidRock,
		getRockPosition = getRockPosition,
		getRockDurability = getRockDurability,
		isRockIgnored = isRockIgnored,
		makeRockTransparent = makeRockTransparent,
	}

	print("âœ… Part 2 Loaded: Noclip & Detection Systems")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PART 3: WEAPON SYSTEM, AUTOSELL & PHYSICS MOVEMENT
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local VirtualInputManager = game:GetService("VirtualInputManager")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local LocalPlayer = Players.LocalPlayer
	local config = _G.MobFarmConfig
	local funcs = _G.FarmFunctions

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- WEAPON & TOOL SYSTEM
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function autoEquipWeapon()
		local character = LocalPlayer.Character
		if not character then return false end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if not humanoid then return false end
		
		local weaponInChar = character:FindFirstChild("Weapon")
		if weaponInChar and weaponInChar:IsA("Tool") then
			return true
		end
		
		local backpack = LocalPlayer:FindFirstChild("Backpack")
		if backpack then
			local weapon = backpack:FindFirstChild("Weapon")
			if weapon and weapon:IsA("Tool") then
				humanoid:EquipTool(weapon)
				task.wait(0.2)
				return true
			end
		end
		
		return false
	end

	local function autoEquipPickaxe()
		local character = LocalPlayer.Character
		if not character then return false end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if not humanoid then return false end
		
		local pickaxeInChar = character:FindFirstChild("Pickaxe")
		if pickaxeInChar and pickaxeInChar:IsA("Tool") then
			return true
		end
		
		local backpack = LocalPlayer:FindFirstChild("Backpack")
		if backpack then
			local pickaxe = backpack:FindFirstChild("Pickaxe")
			if pickaxe and pickaxe:IsA("Tool") then
				humanoid:EquipTool(pickaxe)
				task.wait(0.2)
				return true
			end
		end
		
		return false
	end

	local function clickMouse()
		local success = pcall(function()
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
			task.wait(0.01)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
		end)
		return success
	end

	local function performAttack()
		if not config.isLockedOn or not config.currentMob or config.hoverSequenceActive then
			return
		end
		
		local currentTime = tick()
		if currentTime - config.lastAttackTime < config.attackCooldown then
			return
		end
		
		config.lastAttackTime = currentTime
		clickMouse()
	end

	local function performMine()
		if not config.currentRock then return end
		if not config.miningEnabled then return end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		local pickaxe = character:FindFirstChild("Pickaxe")
		if not pickaxe then
			autoEquipPickaxe()
			return
		end
		
		local currentTime = tick()
		if currentTime - config.lastMineTime < config.miningCooldown then
			return
		end
		
		config.lastMineTime = currentTime
		clickMouse()
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AUTOSELL SYSTEM
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
	local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
	local NO_BUTTON_X = 1200
	local NO_BUTTON_Y = 498
	local originalPosition = nil

	local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

	local function startAutoClickerAt(x, y, duration)
		if config.autoClickerActive then return end
		
		config.autoClickerActive = true
		print("ğŸ–±ï¸ AutoClicker started at: X=" .. x .. ", Y=" .. y .. " for " .. duration .. " seconds")
		
		config.autoClickerLoop = task.spawn(function()
			local startTime = tick()
			local clicks = 0
			while config.autoClickerActive and (tick() - startTime) < duration do
				VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
				task.wait(0.01)
				VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
				clicks = clicks + 1
				task.wait(0.05)
			end
			config.autoClickerActive = false
			print("ğŸ›‘ AutoClicker stopped after " .. clicks .. " clicks")
		end)
	end

	local function stopAutoClicker()
		config.autoClickerActive = false
		if config.autoClickerLoop then
			task.cancel(config.autoClickerLoop)
			config.autoClickerLoop = nil
		end
	end

	local function closeChat()
		task.wait(0.3)
		print("ğŸ”˜ Starting autoclicker at No button position: X=" .. NO_BUTTON_X .. ", Y=" .. NO_BUTTON_Y)
		startAutoClickerAt(NO_BUTTON_X, NO_BUTTON_Y, 3)
		task.wait(0.3)
		stopAutoClicker()
		print("âœ… Dialogue close attempt complete")
	end

	local function talkToSeller()
		local character = LocalPlayer.Character
		if not character then return false end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return false end
		
		originalPosition = rootPart.CFrame
		print("ğŸ’¾ Saved original position: " .. tostring(originalPosition.Position))
		
		rootPart.CFrame = CFrame.new(SELLER_POSITION)
		task.wait(0.5)
		
		if SELLER_PROXIMITY then
			fireproximityprompt(SELLER_PROXIMITY)
			task.wait(0.5)
			closeChat()
			task.wait(0)
			
			if originalPosition then
				rootPart.CFrame = originalPosition
				print("ğŸ”™ Teleported back to original position")
			end
			
			return true
		end
		
		return false
	end

	local function getItemQuantity(itemName)
		local success, quantity = pcall(function()
			local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
			if not playerGui then return 0 end
			
			local menu = playerGui:FindFirstChild("Menu")
			if not menu then return 0 end
			
			local stash = menu:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Frame", true)
				if stash then
					stash = stash:FindFirstChild("Menus", true)
					if stash then
						stash = stash:FindFirstChild("Stash", true)
						if stash then
							stash = stash:FindFirstChild("Background", true)
							if stash then
								for _, itemFolder in pairs(stash:GetChildren()) do
									if itemFolder:IsA("Folder") or itemFolder:IsA("Frame") then
										local main = itemFolder:FindFirstChild("Main")
										if main then
											if itemFolder.Name == itemName then
												local quantityLabel = main:FindFirstChild("Quantity")
												if quantityLabel and quantityLabel:IsA("TextLabel") then
													local quantityText = quantityLabel.Text
													local number = tonumber(string.match(quantityText, "%d+"))
													return number or 0
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
			
			return 0
		end)
		
		if success then
			return quantity
		else
			return 0
		end
	end

	local function sellItems()
		if not config.autoSellEnabled then return end
		
		local currentTime = tick()
		if currentTime - config.lastSellTime < config.sellCooldown then
			return
		end
		
		local itemsToSell = {}
		
		for rarity, items in pairs(config.selectedItems) do
			if rarity ~= "Rune" then
				for _, itemName in ipairs(items) do
					local quantity = getItemQuantity(itemName)
					
					if quantity > 0 then
						itemsToSell[itemName] = quantity
						print(string.format("ğŸ“¦ %s: %d", itemName, quantity))
					end
				end
			end
		end
		
		local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
		if playerGui then
			local menu = playerGui:FindFirstChild("Menu")
			if menu then
				local stash = menu:FindFirstChild("Frame", true)
				if stash then
					stash = stash:FindFirstChild("Frame", true)
					if stash then
						stash = stash:FindFirstChild("Menus", true)
						if stash then
							stash = stash:FindFirstChild("Stash", true)
							if stash then
								stash = stash:FindFirstChild("Background", true)
								if stash then
									for _, itemFolder in pairs(stash:GetChildren()) do
										local main = itemFolder:FindFirstChild("Main")
										if main then
											local itemNameLabel = main:FindFirstChild("ItemName")
											if itemNameLabel and itemNameLabel:IsA("TextLabel") then
												local itemName = itemNameLabel.Text
												
												for _, selectedRuneName in ipairs(config.selectedItems.Rune) do
													if itemName == selectedRuneName then
														itemsToSell[itemFolder.Name] = 1
														print(string.format("ğŸ”® %s (UUID: %s): 1", itemName, itemFolder.Name))
														break
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		
		if next(itemsToSell) == nil then
			return
		end
		
		local success, err = pcall(function()
			RunCommand:InvokeServer("SellConfirm", {Basket = itemsToSell})
		end)
		
		if success then
			config.lastSellTime = currentTime
			print("âœ… Sold items successfully")
		else
			print("âŒ Error selling: " .. tostring(err))
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PHYSICS MOVEMENT
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function setupPhysicsMovement()
		local character = LocalPlayer.Character
		if not character then return false end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return false end
		
		if config.bodyVelocity then
			config.bodyVelocity:Destroy()
		end
		if config.bodyGyro then
			config.bodyGyro:Destroy()
		end
		
		local bv = Instance.new("BodyVelocity")
		bv.Name = "FarmVelocity"
		bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
		bv.Velocity = Vector3.new(0, 0, 0)
		bv.P = 1250
		bv.Parent = rootPart
		config.bodyVelocity = bv
		
		local bg = Instance.new("BodyGyro")
		bg.Name = "FarmGyro"
		bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		bg.P = 30000
		bg.D = 1000
		bg.Parent = rootPart
		config.bodyGyro = bg
		
		rootPart.Anchored = false
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
			humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		end
		
		return true
	end

	local function cleanupPhysicsMovement()
		if config.bodyVelocity then
			config.bodyVelocity:Destroy()
			config.bodyVelocity = nil
		end
		if config.bodyGyro then
			config.bodyGyro:Destroy()
			config.bodyGyro = nil
		end
		
		local character = LocalPlayer.Character
		if character then
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if rootPart then
				rootPart.Anchored = false
				rootPart.Velocity = Vector3.new(0, 0, 0)
			end
			
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
				humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
				task.wait(0.1)
				humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
			end
		end
		
		config.isLockedOn = false
	end

	-- Add to global functions
	funcs.autoEquipWeapon = autoEquipWeapon
	funcs.autoEquipPickaxe = autoEquipPickaxe
	funcs.performAttack = performAttack
	funcs.performMine = performMine
	funcs.setupPhysicsMovement = setupPhysicsMovement
	funcs.cleanupPhysicsMovement = cleanupPhysicsMovement
	funcs.talkToSeller = talkToSeller
	funcs.sellItems = sellItems

	print("âœ… Part 3 Loaded: Weapon, AutoSell & Physics")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PART 4: MOVEMENT LOGIC & HOVERING (FIXED - BETTER MOB TRACKING)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Players = game:GetService("Players")
	local LocalPlayer = Players.LocalPlayer
	local config = _G.MobFarmConfig
	local funcs = _G.FarmFunctions

	local HOVER_HEIGHT = 85
	local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- POSITION CALCULATION
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function getLockPosition(mob)
		local mobRoot = mob:FindFirstChild("HumanoidRootPart")
		if not mobRoot then return nil end
		
		local distance = config.behindDistance
		local verticalDist = config.verticalDistance
		local mobPos = mobRoot.Position
		local targetPos
		
		if config.lockPosition == "Back" then
			local behindOffset = -mobRoot.CFrame.LookVector * distance
			targetPos = mobPos + behindOffset
			targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
		elseif config.lockPosition == "Front" then
			local frontOffset = mobRoot.CFrame.LookVector * distance
			targetPos = mobPos + frontOffset
			targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
		elseif config.lockPosition == "Above" then
			targetPos = mobPos + Vector3.new(0, verticalDist, 0)
		elseif config.lockPosition == "Below" then
			targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
		else
			local behindOffset = -mobRoot.CFrame.LookVector * distance
			targetPos = mobPos + behindOffset
			targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
		end
		
		return targetPos
	end

	local function getMiningPosition(rock)
		if not rock then return nil end
		
		local positionPart = funcs.getRockPosition(rock)
		if not positionPart then 
			return nil 
		end
		
		local rockPos = positionPart.Position
		local targetPos = rockPos + Vector3.new(0, -config.miningVerticalDistance, 0)
		
		return targetPos
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- HOVER MOVEMENT
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local function hoverToPosition(targetPos, lookAtPos)
		local character = LocalPlayer.Character
		if not character then return false end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		
		if not rootPart or not config.bodyVelocity or not config.bodyGyro then
			return false
		end
		
		local currentPos = rootPart.Position
		local direction = (targetPos - currentPos)
		local distance = direction.Magnitude
		
		if distance < config.hoverReachedThreshold then
			config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			return true
		end
		
		local speedMultiplier = math.min(distance / 10, 1)
		local targetSpeed = config.hoverSpeed * speedMultiplier
		
		local desiredVelocity = direction.Unit * targetSpeed
		local currentVelocity = config.bodyVelocity.Velocity
		local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
		
		config.bodyVelocity.Velocity = newVelocity
		
		if lookAtPos then
			local lookCFrame = CFrame.new(currentPos, lookAtPos)
			config.bodyGyro.CFrame = lookCFrame
		end
		
		return false
	end

	-- âœ… FIXED: Better mob tracking - follows mob even when close
	local function hoverToMob(targetPos, mob)
		local character = LocalPlayer.Character
		if not character then return end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		local mobRoot = mob:FindFirstChild("HumanoidRootPart")
		
		if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
			return
		end
		
		local currentPos = rootPart.Position
		local direction = (targetPos - currentPos)
		local distance = direction.Magnitude
		
		-- âœ… CRITICAL FIX: Mark as locked on when close, but KEEP FOLLOWING the mob
		config.isLockedOn = distance < 5  -- Slightly larger range for attacking
		
		-- Handle Above/Below positions (stationary attack angle)
		if (config.lockPosition == "Above" or config.lockPosition == "Below") and distance < 3 then
			-- âœ… FIX: Still follow mob position even when locked
			local followSpeed = 15  -- Slower speed to track mob
			local desiredVelocity = direction.Unit * followSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.2)
			
			-- Set attack angle
			if config.lockPosition == "Above" then
				local angle = math.rad(config.aboveAngle)
				local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
				config.bodyGyro.CFrame = downCFrame
			else
				local angle = math.rad(config.belowAngle)
				local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
				config.bodyGyro.CFrame = upCFrame
			end
			return
		end
		
		-- âœ… FIX: For Back/Front positions, ALWAYS follow the mob
		-- Use slower speed when close, faster when far
		local targetSpeed
		if distance < 3 then
			-- Close range: slow tracking to match mob movement
			targetSpeed = 20
		else
			-- Far range: fast approach
			targetSpeed = config.hoverSpeed * math.min(distance / 10, 1)
		end
		
		local desiredVelocity = direction.Unit * targetSpeed
		
		-- âœ… FIX: Smoother lerp when close for better tracking
		local lerpSpeed = distance < 3 and 0.4 or 0.3
		local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, lerpSpeed)
		
		config.bodyVelocity.Velocity = newVelocity
		
		-- âœ… FIX: Always look at mob for better hitbox alignment
		local lookCFrame = CFrame.new(currentPos, mobRoot.Position)
		local gyroLerpSpeed = distance < 3 and 0.5 or 0.3
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, gyroLerpSpeed)
	end

	local function hoverToRock(targetPos, rock)
		if not targetPos then 
			return 
		end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		
		if not rootPart or not config.bodyVelocity or not config.bodyGyro then
			return
		end
		
		local currentPos = rootPart.Position
		local direction = (targetPos - currentPos)
		local distance = direction.Magnitude
		
		if distance < 3 then
			config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			
			local angle = math.rad(config.miningAngle)
			local lookCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
			config.bodyGyro.CFrame = lookCFrame
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 50000
			return
		end
		
		local speedMultiplier = math.min(distance / 10, 1)
		local targetSpeed = config.hoverSpeed * speedMultiplier
		local desiredVelocity = direction.Unit * targetSpeed
		local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.5)
		
		config.bodyVelocity.Velocity = newVelocity
		
		local positionPart = funcs.getRockPosition(rock)
		if positionPart then
			local lookCFrame = CFrame.new(currentPos, positionPart.Position)
			config.bodyGyro.CFrame = lookCFrame
			config.bodyGyro.P = 10000
		end
	end

	-- Add to global functions
	funcs.getLockPosition = getLockPosition
	funcs.getMiningPosition = getMiningPosition
	funcs.hoverToPosition = hoverToPosition
	funcs.hoverToMob = hoverToMob
	funcs.hoverToRock = hoverToRock

	print("âœ… Part 4 Loaded: Movement Logic & Hovering (FIXED - Better Mob Tracking)")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PART 5: LINORIA UI & AUTO-LOOPS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local LocalPlayer = Players.LocalPlayer
	local Living = workspace:WaitForChild("Living")

	local config = _G.MobFarmConfig
	local funcs = _G.FarmFunctions

	local HOVER_HEIGHT = 85
	local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- LOAD LINORIA UI LIBRARY
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	print("ğŸ”„ Loading LinoriaLib UI Library...")

	local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

	local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
	local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
	local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

	print("âœ… LinoriaLib loaded successfully")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CREATE WINDOW
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Window = Library:CreateWindow({
		Title = "Rafso's Complete Hub",
		Center = true,
		AutoShow = true,
		TabPadding = 8,
		MenuFadeTime = 0.2
	})

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STORE UI REFERENCES GLOBALLY
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	_G.UIReferences = {
		Window = Window,
		Library = Library,
		Tabs = {},
		Toggles = {},
		Options = {},
	}

	local Tabs = _G.UIReferences.Tabs
	local Toggles = Toggles or {}
	local Options = Options or {}

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AUTO-LOOPS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local attackLoop = nil
	local mineLoop = nil
	local weaponCheckLoop = nil
	local pickaxeCheckLoop = nil
	local sellLoop = nil

	local function startAutoAttack()
		if attackLoop then return end
		
		task.spawn(function()
			task.wait(0.5)
			funcs.autoEquipWeapon()
		end)
		
		attackLoop = RunService.Heartbeat:Connect(function()
			if not config.enabled then return end
			funcs.performAttack()
		end)
		
		if not weaponCheckLoop then
			weaponCheckLoop = RunService.Heartbeat:Connect(function()
				if not config.enabled then return end
				local currentTime = tick()
				if currentTime - config.lastWeaponCheckTime >= config.weaponCheckInterval then
					config.lastWeaponCheckTime = currentTime
					funcs.autoEquipWeapon()
				end
			end)
		end
	end

	local function stopAutoAttack()
		if attackLoop then
			attackLoop:Disconnect()
			attackLoop = nil
		end
		if weaponCheckLoop then
			weaponCheckLoop:Disconnect()
			weaponCheckLoop = nil
		end
	end

	local function startAutoMine()
		if mineLoop then return end
		
		task.spawn(function()
			task.wait(0.3)
			funcs.autoEquipPickaxe()
		end)
		
		mineLoop = RunService.Heartbeat:Connect(function()
			if not config.miningEnabled then return end
			funcs.performMine()
		end)
		
		if not pickaxeCheckLoop then
			pickaxeCheckLoop = RunService.Heartbeat:Connect(function()
				if not config.miningEnabled then return end
				local currentTime = tick()
				if currentTime - config.lastPickaxeCheckTime >= config.pickaxeCheckInterval then
					config.lastPickaxeCheckTime = currentTime
					funcs.autoEquipPickaxe()
				end
			end)
		end
	end

	local function stopAutoMine()
		if mineLoop then
			mineLoop:Disconnect()
			mineLoop = nil
		end
		if pickaxeCheckLoop then
			pickaxeCheckLoop:Disconnect()
			pickaxeCheckLoop = nil
		end
	end

	local function startAutoSell()
		if sellLoop then return end
		
		sellLoop = RunService.Heartbeat:Connect(function()
			if not config.autoSellEnabled then return end
			funcs.sellItems()
		end)
	end

	local function stopAutoSell()
		if sellLoop then
			sellLoop:Disconnect()
			sellLoop = nil
		end
	end

	-- Make auto-loop functions global
	_G.AutoLoopFunctions = {
		startAutoAttack = startAutoAttack,
		stopAutoAttack = stopAutoAttack,
		startAutoMine = startAutoMine,
		stopAutoMine = stopAutoMine,
		startAutoSell = startAutoSell,
		stopAutoSell = stopAutoSell,
	}

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CREATE TABS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	Tabs.Farming = Window:AddTab('Farming')
	Tabs.Mining = Window:AddTab('Mining')
	Tabs.AutoSell = Window:AddTab('AutoSell')
	Tabs.Settings = Window:AddTab('Settings')
	Tabs.Configs = Window:AddTab('Configs')

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- FARMING TAB
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local FarmingGroupBox = Tabs.Farming:AddLeftGroupbox('Mob Farming')

	FarmingGroupBox:AddToggle('FarmToggle', {
		Text = 'Enable Mob Farming (F1)',
		Default = false,
		Tooltip = 'Toggle mob farming on/off',
		Callback = function(Value)
			config.enabled = Value
			
			if config.enabled then
				local character = LocalPlayer.Character
				if character then
					local rootPart = character:FindFirstChild("HumanoidRootPart")
					if rootPart then
						config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
						config.hoverSequenceActive = true
						config.currentHoverTarget = 1
					end
				end
				
				funcs.setupPhysicsMovement()
				funcs.startNoclip()
				startAutoAttack()
			else
				config.hoverSequenceActive = false
				config.currentMob = nil
				stopAutoAttack()
				funcs.stopNoclip()
				funcs.cleanupPhysicsMovement()
			end
		end
	})

	FarmingGroupBox:AddDivider()

	FarmingGroupBox:AddDropdown('LockPosition', {
		Values = {'Back', 'Front', 'Above', 'Below'},
		Default = 1,
		Multi = false,
		Text = 'Lock Position',
		Tooltip = 'Choose where to position yourself relative to the mob',
		Callback = function(Value)
			config.lockPosition = Value
		end
	})

	FarmingGroupBox:AddDivider()

	local mobOptions = {}
	for i, mobData in ipairs(config.mobTypes) do
		table.insert(mobOptions, mobData.name)
	end

	FarmingGroupBox:AddLabel('Select Mobs to Farm:')

	FarmingGroupBox:AddDropdown('MobSelection', {
		Values = mobOptions,
		Default = 1,
		Multi = true,
		Text = 'Select Mobs',
		Tooltip = 'Choose which mobs to farm',
		Callback = function(Value)
			-- Reset all mobs
			for i, mobData in ipairs(config.mobTypes) do
				config.mobTypes[i].enabled = false
			end
			
			-- Enable selected mobs
			for mobName, isEnabled in pairs(Value) do
				if isEnabled then
					for i, mobData in ipairs(config.mobTypes) do
						if mobData.name == mobName then
							config.mobTypes[i].enabled = true
							break
						end
					end
				end
			end
		end
	})

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MINING TAB
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local MiningGroupBox = Tabs.Mining:AddLeftGroupbox('Mining')

	MiningGroupBox:AddToggle('MineToggle', {
		Text = 'Enable Mining (F2)',
		Default = false,
		Tooltip = 'Toggle mining on/off',
		Callback = function(Value)
			config.miningEnabled = Value
			
			if config.miningEnabled then
				config.ignoredRocks = {}
				config.lastRockDurability = nil
				config.rockDurabilityCheck = tick()
				config.currentRock = nil
				
				local character = LocalPlayer.Character
				if character then
					local rootPart = character:FindFirstChild("HumanoidRootPart")
					if rootPart then
						config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
						config.hoverSequenceActive = true
						config.currentHoverTarget = 1
					end
				end
				
				funcs.setupPhysicsMovement()
				funcs.startNoclip()
				startAutoMine()
			else
				config.hoverSequenceActive = false
				config.currentHoverTarget = 1
				config.currentRock = nil
				config.ignoredRocks = {}
				config.lastRockDurability = nil
				config.isLockedOn = false
				
				stopAutoMine()
				funcs.stopNoclip()
				funcs.cleanupPhysicsMovement()
				
				local character = LocalPlayer.Character
				if character then
					local rootPart = character:FindFirstChild("HumanoidRootPart")
					if rootPart then
						rootPart.Velocity = Vector3.new(0, 0, 0)
						rootPart.Anchored = false
					end
				end
			end
		end
	})

	MiningGroupBox:AddDivider()

	local rockOptions = {}
	for i, rockData in ipairs(config.rockTypes) do
		table.insert(rockOptions, rockData.name)
	end

	MiningGroupBox:AddLabel('Select Rocks to Mine:')

	MiningGroupBox:AddDropdown('RockSelection', {
		Values = rockOptions,
		Default = 1,
		Multi = true,
		Text = 'Select Rocks',
		Tooltip = 'Choose which rocks to mine',
		Callback = function(Value)
			-- Reset all rocks
			for i, rockData in ipairs(config.rockTypes) do
				config.rockTypes[i].enabled = false
			end
			
			-- Enable selected rocks
			for rockName, isEnabled in pairs(Value) do
				if isEnabled then
					for i, rockData in ipairs(config.rockTypes) do
						if rockData.name == rockName then
							config.rockTypes[i].enabled = true
							break
						end
					end
				end
			end
		end
	})

	-- Store references
	_G.UIReferences.mobOptions = mobOptions
	_G.UIReferences.rockOptions = rockOptions

	print("âœ… Part 5 Loaded: LinoriaLib UI & Auto-Loops")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PART 6: AUTOSELL, SETTINGS & CONFIG MANAGEMENT (LINORIA - ADJUSTED LAYOUT)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local config = _G.MobFarmConfig
	local funcs = _G.FarmFunctions
	local configFuncs = _G.ConfigFunctions
	local autoLoopFuncs = _G.AutoLoopFunctions

	local uiRefs = _G.UIReferences
	local Window = uiRefs.Window
	local Library = uiRefs.Library
	local Tabs = uiRefs.Tabs

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AUTOSELL TAB
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local AutoSellGroupBox = Tabs.AutoSell:AddLeftGroupbox('Auto Sell')

	AutoSellGroupBox:AddToggle('AutoSellToggle', {
		Text = 'Enable Auto Sell',
		Default = false,
		Tooltip = 'Automatically sell selected items',
		Callback = function(Value)
			config.autoSellEnabled = Value
			
			if config.autoSellEnabled then
				print("ğŸŸ¢ AutoSell Enabled")
				autoLoopFuncs.startAutoSell()
			else
				print("ğŸ”´ AutoSell Disabled")
				autoLoopFuncs.stopAutoSell()
			end
		end
	})

	AutoSellGroupBox:AddDivider()

	AutoSellGroupBox:AddButton({
		Text = 'Talk to Seller',
		Func = function()
			print("ğŸ—£ï¸ Talking to Seller...")
			local success = funcs.talkToSeller()
			
			if success then
				Library:Notify("Successfully talked to seller!", 3)
				print("âœ… Seller conversation complete!")
			else
				Library:Notify("Failed to talk to seller!", 3)
				print("âŒ Failed to talk to seller")
			end
		end,
		DoubleClick = false,
		Tooltip = 'Teleport to seller and open dialogue'
	})

	local ItemSelectionGroupBox = Tabs.AutoSell:AddRightGroupbox('Item Selection')

	ItemSelectionGroupBox:AddLabel('Select Items to Auto Sell:')

	ItemSelectionGroupBox:AddDropdown('CommonItems', {
		Values = ItemsByRarity.Common,
		Default = 1,
		Multi = true,
		Text = 'Common Items',
		Tooltip = 'Select common items to sell',
		Callback = function(Value)
			config.selectedItems.Common = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Common, itemName)
				end
			end
		end
	})

	ItemSelectionGroupBox:AddDropdown('UncommonItems', {
		Values = ItemsByRarity.Uncommon,
		Default = 1,
		Multi = true,
		Text = 'Uncommon Items',
		Tooltip = 'Select uncommon items to sell',
		Callback = function(Value)
			config.selectedItems.Uncommon = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Uncommon, itemName)
				end
			end
		end
	})

	ItemSelectionGroupBox:AddDropdown('RareItems', {
		Values = ItemsByRarity.Rare,
		Default = 1,
		Multi = true,
		Text = 'Rare Items',
		Tooltip = 'Select rare items to sell',
		Callback = function(Value)
			config.selectedItems.Rare = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Rare, itemName)
				end
			end
		end
	})

	ItemSelectionGroupBox:AddDropdown('EpicItems', {
		Values = ItemsByRarity.Epic,
		Default = 1,
		Multi = true,
		Text = 'Epic Items',
		Tooltip = 'Select epic items to sell',
		Callback = function(Value)
			config.selectedItems.Epic = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Epic, itemName)
				end
			end
		end
	})

	ItemSelectionGroupBox:AddDropdown('LegendaryItems', {
		Values = ItemsByRarity.Legendary,
		Default = 1,
		Multi = true,
		Text = 'Legendary Items',
		Tooltip = 'Select legendary items to sell',
		Callback = function(Value)
			config.selectedItems.Legendary = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Legendary, itemName)
				end
			end
		end
	})

	ItemSelectionGroupBox:AddDropdown('MythicalItems', {
		Values = ItemsByRarity.Mythical,
		Default = 1,
		Multi = true,
		Text = 'Mythical Items',
		Tooltip = 'Select mythical items to sell',
		Callback = function(Value)
			config.selectedItems.Mythical = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Mythical, itemName)
				end
			end
		end
	})

	ItemSelectionGroupBox:AddDropdown('RuneItems', {
		Values = ItemsByRarity.Rune,
		Default = 1,
		Multi = true,
		Text = 'Rune Items',
		Tooltip = 'Select rune items to sell',
		Callback = function(Value)
			config.selectedItems.Rune = {}
			for itemName, isEnabled in pairs(Value) do
				if isEnabled then
					table.insert(config.selectedItems.Rune, itemName)
				end
			end
		end
	})

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- SETTINGS TAB (MOVED TO RIGHT SIDE)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local MiningSettingsBox = Tabs.Settings:AddLeftGroupbox('Mining Settings')

	MiningSettingsBox:AddSlider('MiningVerticalDistance', {
		Text = 'Mining Vertical Distance',
		Default = 6,
		Min = 1,
		Max = 15,
		Rounding = 0,
		Compact = false,
		Callback = function(Value)
			config.miningVerticalDistance = Value
		end
	})

	MiningSettingsBox:AddToggle('IgnoreGoblinCave', {
		Text = 'Ignore Goblin Cave Rocks',
		Default = true,
		Tooltip = 'Skip rocks in the goblin cave',
		Callback = function(Value)
			config.ignoreGoblinCave = Value
		end
	})

	local GeneralSettingsBox = Tabs.Settings:AddRightGroupbox('General Settings')

	GeneralSettingsBox:AddSlider('HoverSpeed', {
		Text = 'Hover Speed',
		Default = 80,
		Min = 20,
		Max = 150,
		Rounding = 0,
		Compact = false,
		Callback = function(Value)
			config.hoverSpeed = Value
		end
	})

	local FarmSettingsBox = Tabs.Settings:AddRightGroupbox('Farm Settings')

	FarmSettingsBox:AddSlider('VerticalDistance', {
		Text = 'Vertical Distance',
		Default = 8,
		Min = 1,
		Max = 20,
		Rounding = 0,
		Compact = false,
		Callback = function(Value)
			config.verticalDistance = Value
		end
	})

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CONFIG MANAGEMENT TAB
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local ConfigManagementBox = Tabs.Configs:AddLeftGroupbox('Config Management')

	local selectedConfig = nil

	ConfigManagementBox:AddInput('ConfigName', {
		Default = '',
		Numeric = false,
		Finished = false,
		Text = 'Config Name',
		Tooltip = 'Enter a name for your config',
		Placeholder = 'Enter config name...',
	})

	ConfigManagementBox:AddDropdown('ConfigSelector', {
		Values = configFuncs.getConfigList(),
		Default = 1,
		Multi = false,
		Text = 'Select Config',
		Tooltip = 'Choose a config to load/delete',
		Callback = function(Value)
			selectedConfig = Value
			print("ğŸ“‹ Selected config: " .. Value)
		end
	})

	ConfigManagementBox:AddDivider()

	ConfigManagementBox:AddButton({
		Text = 'Refresh Configs',
		Func = function()
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			Library:Notify("Found " .. #configList .. " config(s)", 2)
			print("ğŸ”„ Config list refreshed. Found " .. #configList .. " configs")
		end,
		DoubleClick = false,
		Tooltip = 'Refresh the config list'
	})

	ConfigManagementBox:AddButton({
		Text = 'Create Config',
		Func = function()
			local configName = Options.ConfigName.Value
			
			if configName == "" or configName == nil then
				Library:Notify("Please enter a config name!", 3)
				print("âŒ Please enter a config name first!")
				return
			end
			
			configName = configName:gsub("%s+", "_")
			
			local success = configFuncs.saveConfig(configName)
			
			if success then
				Library:Notify("Config '" .. configName .. "' created!", 3)
				
				-- Refresh dropdown
				local configList = configFuncs.getConfigList()
				Options.ConfigSelector:SetValues(configList)
				Options.ConfigSelector:SetValue(configName)
				selectedConfig = configName
				
				-- Clear input
				Options.ConfigName:SetValue("")
			else
				Library:Notify("Failed to create config!", 3)
			end
		end,
		DoubleClick = false,
		Tooltip = 'Create a new config with current settings'
	})

	ConfigManagementBox:AddButton({
		Text = 'Load Config',
		Func = function()
			if not selectedConfig or selectedConfig == "" then
				Library:Notify("Please select a config first!", 3)
				return
			end
			
			print("ğŸ”„ Loading config: " .. selectedConfig)
			local success = configFuncs.loadConfig(selectedConfig)
			
			if success then
				Library:Notify("Config '" .. selectedConfig .. "' loaded!", 3)
				
				-- Update UI with loaded config
				task.wait(0.2)
				
				-- Update sliders
				Options.HoverSpeed:SetValue(config.hoverSpeed)
				Options.VerticalDistance:SetValue(config.verticalDistance)
				Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
				
				-- Update toggles
				Toggles.IgnoreGoblinCave:SetValue(config.ignoreGoblinCave)
				
				-- Update lock position
				Options.LockPosition:SetValue(config.lockPosition)
				
				-- Update mob selection
				local enabledMobs = {}
				for _, mobData in ipairs(config.mobTypes) do
					if mobData.enabled then
						enabledMobs[mobData.name] = true
					end
				end
				Options.MobSelection:SetValue(enabledMobs)
				
				-- Update rock selection
				local enabledRocks = {}
				for _, rockData in ipairs(config.rockTypes) do
					if rockData.enabled then
						enabledRocks[rockData.name] = true
					end
				end
				Options.RockSelection:SetValue(enabledRocks)
				
				-- Update AutoSell items
				local commonItems = {}
				for _, item in ipairs(config.selectedItems.Common or {}) do
					commonItems[item] = true
				end
				Options.CommonItems:SetValue(commonItems)
				
				local uncommonItems = {}
				for _, item in ipairs(config.selectedItems.Uncommon or {}) do
					uncommonItems[item] = true
				end
				Options.UncommonItems:SetValue(uncommonItems)
				
				local rareItems = {}
				for _, item in ipairs(config.selectedItems.Rare or {}) do
					rareItems[item] = true
				end
				Options.RareItems:SetValue(rareItems)
				
				local epicItems = {}
				for _, item in ipairs(config.selectedItems.Epic or {}) do
					epicItems[item] = true
				end
				Options.EpicItems:SetValue(epicItems)
				
				local legendaryItems = {}
				for _, item in ipairs(config.selectedItems.Legendary or {}) do
					legendaryItems[item] = true
				end
				Options.LegendaryItems:SetValue(legendaryItems)
				
				local mythicalItems = {}
				for _, item in ipairs(config.selectedItems.Mythical or {}) do
					mythicalItems[item] = true
				end
				Options.MythicalItems:SetValue(mythicalItems)
				
				local runeItems = {}
				for _, item in ipairs(config.selectedItems.Rune or {}) do
					runeItems[item] = true
				end
				Options.RuneItems:SetValue(runeItems)
				
				print("âœ… UI updated with loaded config")
			else
				Library:Notify("Failed to load config!", 3)
			end
		end,
		DoubleClick = false,
		Tooltip = 'Load the selected config'
	})

	ConfigManagementBox:AddButton({
		Text = 'Overwrite Config',
		Func = function()
			if not selectedConfig or selectedConfig == "" then
				Library:Notify("Please select a config first!", 3)
				return
			end
			
			local success = configFuncs.saveConfig(selectedConfig)
			
			if success then
				Library:Notify("Config '" .. selectedConfig .. "' overwritten!", 3)
			else
				Library:Notify("Failed to overwrite config!", 3)
			end
		end,
		DoubleClick = false,
		Tooltip = 'Overwrite selected config with current settings'
	})

	ConfigManagementBox:AddButton({
		Text = 'Set as Autoload',
		Func = function()
			if not selectedConfig or selectedConfig == "" then
				Library:Notify("Please select a config first!", 3)
				return
			end
			
			configFuncs.setAutoload(selectedConfig)
			Library:Notify("Config '" .. selectedConfig .. "' set as autoload!", 3)
		end,
		DoubleClick = false,
		Tooltip = 'This config will load automatically on startup'
	})

	ConfigManagementBox:AddButton({
		Text = 'Destroy Config',
		Func = function()
			if not selectedConfig or selectedConfig == "" then
				Library:Notify("Please select a config first!", 3)
				return
			end
			
			local configToDelete = selectedConfig
			local success = configFuncs.deleteConfig(configToDelete)
			
			if success then
				Library:Notify("Config '" .. configToDelete .. "' deleted!", 3)
				
				-- Refresh dropdown
				local configList = configFuncs.getConfigList()
				Options.ConfigSelector:SetValues(configList)
				selectedConfig = nil
			else
				Library:Notify("Failed to delete config!", 3)
			end
		end,
		DoubleClick = true,
		Tooltip = 'Double-click to delete the selected config'
	})

	local DebugBox = Tabs.Configs:AddRightGroupbox('Debug')

	DebugBox:AddButton({
		Text = 'ğŸ” Debug Current Config',
		Func = function()
			configFuncs.debugCurrentConfig()
			Library:Notify("Debug info copied to clipboard!", 3)
		end,
		DoubleClick = false,
		Tooltip = 'Copy current config state to clipboard'
	})

	local autoloadConfig = configFuncs.getAutoload()
	if autoloadConfig then
		DebugBox:AddLabel('Autoload: ' .. autoloadConfig)
	else
		DebugBox:AddLabel('Autoload: None')
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AUTO-LOAD CONFIG ON STARTUP
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	task.spawn(function()
		task.wait(3)
		
		local autoloadName = configFuncs.getAutoload()
		if autoloadName then
			print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
			print("ğŸ”„ AUTOLOAD: Loading config '" .. autoloadName .. "'")
			print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
			
			local success = configFuncs.loadConfig(autoloadName)
			
			if success then
				print("âœ… Autoload config loaded successfully!")
				
				task.wait(0.5)
				
				-- Update UI (same as Load Config button)
				Options.HoverSpeed:SetValue(config.hoverSpeed)
				Options.VerticalDistance:SetValue(config.verticalDistance)
				Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
				Toggles.IgnoreGoblinCave:SetValue(config.ignoreGoblinCave)
				Options.LockPosition:SetValue(config.lockPosition)
				
				local enabledMobs = {}
				for _, mobData in ipairs(config.mobTypes) do
					if mobData.enabled then
						enabledMobs[mobData.name] = true
					end
				end
				Options.MobSelection:SetValue(enabledMobs)
				
				local enabledRocks = {}
				for _, rockData in ipairs(config.rockTypes) do
					if rockData.enabled then
						enabledRocks[rockData.name] = true
					end
				end
				Options.RockSelection:SetValue(enabledRocks)
				
				-- Update AutoSell dropdowns
				local commonItems = {}
				for _, item in ipairs(config.selectedItems.Common or {}) do
					commonItems[item] = true
				end
				Options.CommonItems:SetValue(commonItems)
				
				local uncommonItems = {}
				for _, item in ipairs(config.selectedItems.Uncommon or {}) do
					uncommonItems[item] = true
				end
				Options.UncommonItems:SetValue(uncommonItems)
				
				local rareItems = {}
				for _, item in ipairs(config.selectedItems.Rare or {}) do
					rareItems[item] = true
				end
				Options.RareItems:SetValue(rareItems)
				
				local epicItems = {}
				for _, item in ipairs(config.selectedItems.Epic or {}) do
					epicItems[item] = true
				end
				Options.EpicItems:SetValue(epicItems)
				
				local legendaryItems = {}
				for _, item in ipairs(config.selectedItems.Legendary or {}) do
					legendaryItems[item] = true
				end
				Options.LegendaryItems:SetValue(legendaryItems)
				
				local mythicalItems = {}
				for _, item in ipairs(config.selectedItems.Mythical or {}) do
					mythicalItems[item] = true
				end
				Options.MythicalItems:SetValue(mythicalItems)
				
				local runeItems = {}
				for _, item in ipairs(config.selectedItems.Rune or {}) do
					runeItems[item] = true
				end
				Options.RuneItems:SetValue(runeItems)
				
				Library:Notify("Autoload config '" .. autoloadName .. "' loaded!", 4)
				print("âœ… AUTOLOAD COMPLETE")
			else
				print("âŒ Failed to load autoload config")
			end
		else
			print("â„¹ï¸ No autoload config set")
		end
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- KEYBIND SYSTEM (F1/F2 + K TO TOGGLE UI)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- K key to toggle UI
	Library:OnUnload(function()
		print('ğŸ—‘ï¸ Unloaded GUI')
		Library.Unloaded = true
	end)

	local MenuGroup = Tabs.Settings:AddRightGroupbox('Menu')

	MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'K', NoUI = true, Text = 'Menu keybind' })

	Library.ToggleKeybind = Options.MenuKeybind

	-- F1/F2 Keybinds
	local keybindConnection = nil

	keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if not _G.MobFarmConfig or not _G.FarmFunctions then
			return
		end
		
		if input.KeyCode == Enum.KeyCode.F1 then
			local newValue = not config.enabled
			Toggles.FarmToggle:SetValue(newValue)
			
		elseif input.KeyCode == Enum.KeyCode.F2 then
			local newValue = not config.miningEnabled
			Toggles.MineToggle:SetValue(newValue)
		end
	end)

	-- Theme Manager
	ThemeManager:SetLibrary(Library)
	ThemeManager:SetFolder('RafsoHub')
	ThemeManager:ApplyToTab(Tabs.Settings)

	print("âœ… Part 6 Loaded: AutoSell, Settings & Config Management (ADJUSTED LAYOUT)")

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PART 7: MAIN LOOPS & CHARACTER RESPAWN HANDLER (SMART LAVA CHECK)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local StarterGui = game:GetService("StarterGui")
	local VirtualInputManager = game:GetService("VirtualInputManager")
	local LocalPlayer = Players.LocalPlayer

	local config = _G.MobFarmConfig
	local funcs = _G.FarmFunctions

	local HOVER_HEIGHT = 85
	local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)
	local SKIP_HOVER_DISTANCE = 150  -- If target is within this distance, skip hover sequence

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MINING DEFENSE CONFIG
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	config.miningDefenseEnabled = true
	config.miningDefenseDistance = 10
	config.defendingAgainstMob = nil
	config.savedMiningRock = nil
	config.weaponEquipped = false
	config.lastDefenseAttackTime = 0
	config.defenseAttackCooldown = 0.1

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- IMPROVED LAVA CHECK CONFIG
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	config.lavaCheckEnabled = true
	config.lastHealth = nil
	config.inLavaMode = false
	config.normalMiningDistance = 6  -- Normal mining distance
	config.lavaMiningDistance = 1    -- Distance when mining above lava
	config.currentRockModel = nil    -- Track the rock model (parent of durability model)
	config.lavaCheckCooldown = false
	config.lavaCooldownTime = 1

	-- âœ… NEW: Smart lava detection function
	local function checkLavaDamage()
		if not config.miningEnabled or config.defendingAgainstMob or not config.lavaCheckEnabled then
			return
		end
		
		if config.lavaCheckCooldown then return end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if not humanoid then return end
		
		local currentHealth = humanoid.Health
		
		if not config.lastHealth then
			config.lastHealth = currentHealth
			return
		end
		
		-- âœ… Detect health loss (lava damage)
		if currentHealth < config.lastHealth and not config.inLavaMode then
			print("ğŸ”¥ LAVA DETECTED! Switching to lava mode...")
			config.inLavaMode = true
			config.miningVerticalDistance = config.lavaMiningDistance
			
			-- Save current rock model reference
			if config.currentRock then
				config.currentRockModel = config.currentRock.Parent
				print("ğŸ“ Tracking rock model: " .. config.currentRockModel.Name)
			end
			
			-- Cooldown to prevent spam
			config.lavaCheckCooldown = true
			task.delay(config.lavaCooldownTime, function()
				config.lavaCheckCooldown = false
			end)
			
			print("â¬†ï¸ Mining distance changed to: " .. config.miningVerticalDistance)
		end
		
		config.lastHealth = currentHealth
	end

	-- âœ… NEW: Monitor rock destruction to reset mining distance
	local function monitorRockDestruction()
		if not config.inLavaMode or not config.currentRockModel then
			return
		end
		
		-- Check if rock model is destroyed/despawned
		if not config.currentRockModel.Parent then
			print("âœ… Lava rock destroyed! Returning to normal mining distance...")
			config.inLavaMode = false
			config.miningVerticalDistance = config.normalMiningDistance
			config.currentRockModel = nil
			
			-- Reset health tracking
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					config.lastHealth = humanoid.Health
				end
			end
			
			print("â¬‡ï¸ Mining distance reset to: " .. config.miningVerticalDistance)
		end
	end

	-- âœ… NEW: Check if close to target to skip hover sequence
	local function checkProximityToTarget()
		local character = LocalPlayer.Character
		if not character then return false end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return false end
		
		local currentPos = rootPart.Position
		
		-- Check for mob farming
		if config.enabled then
			local closestMob = funcs.getClosestMob()
			if closestMob then
				local mobRoot = closestMob:FindFirstChild("HumanoidRootPart")
				if mobRoot then
					local distance = (currentPos - mobRoot.Position).Magnitude
					if distance <= SKIP_HOVER_DISTANCE then
						print("ğŸ¯ Mob nearby (" .. math.floor(distance) .. " studs) - Skipping hover sequence!")
						return true
					end
				end
			end
		end
		
		-- Check for mining
		if config.miningEnabled then
			local closestRock = funcs.getClosestRock()
			if closestRock then
				local positionPart = funcs.getRockPosition(closestRock)
				if positionPart then
					local distance = (currentPos - positionPart.Position).Magnitude
					if distance <= SKIP_HOVER_DISTANCE then
						print("â›ï¸ Rock nearby (" .. math.floor(distance) .. " studs) - Skipping hover sequence!")
						return true
					end
				end
			end
		end
		
		return false
	end

	local function clickMouseForDefense()
		local success = pcall(function()
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
			task.wait(0.01)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
		end)
		return success
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- IMPROVED MESSAGE DETECTION SYSTEM (INSTANT ROCK SWITCH)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local lastMessageTime = 0
	local MESSAGE_COOLDOWN = 0.5

	local function switchToNewRock(reason)
		if config.currentRock and config.miningEnabled and not config.defendingAgainstMob then
			print("âš ï¸ " .. reason)
			print("ğŸš« INSTANTLY switching to new rock...")
			
			table.insert(config.ignoredRocks, config.currentRock)
			
			config.currentRock = nil
			config.currentRockModel = nil
			config.lastRockDurability = nil
			config.isLockedOn = false
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart and config.bodyVelocity then
					config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
				end
			end
			
			print("âœ… Ready to find new rock!")
		end
	end

	local function setupTextLabelMonitoring()
		local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
		if not playerGui then return end
		
		local function monitorTextLabel(textLabel)
			if not textLabel:IsA("TextLabel") then return end
			
			local connection
			connection = textLabel:GetPropertyChangedSignal("Text"):Connect(function()
				if (tick() - lastMessageTime) < MESSAGE_COOLDOWN then return end
				
				local text = textLabel.Text:lower()
				
				if text:find("Someone else is already mining this rock.") or 
				text:find("someone else") or 
				text:find("being mined") or
				text:find("another player") then
					
					lastMessageTime = tick()
					switchToNewRock("Detected: Another player is mining this rock!")
				end
			end)
		end
		
		for _, gui in pairs(playerGui:GetDescendants()) do
			monitorTextLabel(gui)
		end
		
		playerGui.DescendantAdded:Connect(function(descendant)
			task.wait(0.05)
			monitorTextLabel(descendant)
		end)
	end

	local function setupStarterGuiMonitoring()
		local starterGui = game:GetService("StarterGui")
		
		local oldSetCore = starterGui.SetCore
		starterGui.SetCore = function(self, ...)
			local args = {...}
			if args[1] == "ChatMakeSystemMessage" or args[1] == "SendNotification" then
				local message = ""
				if type(args[2]) == "table" then
					message = tostring(args[2].Text or ""):lower()
				else
					message = tostring(args[2] or ""):lower()
				end
				
				if message:find("already mining") or 
				message:find("someone else") or 
				message:find("being mined") then
					
					switchToNewRock("Detected notification: Rock being mined by another player!")
				end
			end
			return oldSetCore(self, ...)
		end
	end

	local function setupCommonGuiMonitoring()
		local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
		if not playerGui then return end
		
		local commonPaths = {
			"Notifications",
			"SystemMessages", 
			"Messages",
			"Hints",
			"Popups",
			"ErrorMessages",
			"Chat"
		}
		
		for _, guiName in ipairs(commonPaths) do
			local gui = playerGui:FindFirstChild(guiName)
			if gui then
				gui.DescendantAdded:Connect(function(descendant)
					if descendant:IsA("TextLabel") or descendant:IsA("TextBox") then
						task.wait(0.05)
						local text = descendant.Text:lower()
						
						if text:find("already mining") or 
						text:find("someone else") or 
						text:find("being mined") then
							
							switchToNewRock("Detected in " .. guiName .. ": Rock occupied!")
						end
					end
				end)
			end
		end
	end

	local function setupChatMonitoring()
		local chatService = game:GetService("Chat")
		local textChatService = game:GetService("TextChatService")
		
		pcall(function()
			textChatService.MessageReceived:Connect(function(message)
				local text = message.Text:lower()
				if text:find("already mining") or 
				text:find("someone else") or 
				text:find("being mined") then
					
					switchToNewRock("Detected in chat: Rock occupied!")
				end
			end)
		end)
	end

	task.spawn(function()
		task.wait(1)
		print("ğŸ” Setting up INSTANT rock switch detection...")
		
		setupTextLabelMonitoring()
		print("âœ… Method 1: TextLabel monitoring active")
		
		setupStarterGuiMonitoring()
		print("âœ… Method 2: StarterGui monitoring active")
		
		setupCommonGuiMonitoring()
		print("âœ… Method 3: Common GUI monitoring active")
		
		setupChatMonitoring()
		print("âœ… Method 4: Chat monitoring active")
		
		print("ğŸ¯ All detection methods ready!")
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MAIN FARMING LOOP (WITH PROXIMITY CHECK)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local farmLoop = RunService.Heartbeat:Connect(function()
		if not config.enabled or config.isRespawning then return end
		
		if not config.bodyVelocity or not config.bodyGyro then
			funcs.setupPhysicsMovement()
			return
		end
		
		-- âœ… NEW: Check if close to target and skip hover sequence
		if config.hoverSequenceActive and config.currentHoverTarget == 1 then
			if checkProximityToTarget() then
				config.hoverSequenceActive = false
				config.currentHoverTarget = 3
				print("âš¡ Starting farm immediately!")
				return
			end
		end
		
		if config.hoverSequenceActive then
			if config.currentHoverTarget == 1 then
				if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
					config.currentHoverTarget = 2
				end
			elseif config.currentHoverTarget == 2 then
				if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
					config.currentHoverTarget = 3
					config.hoverSequenceActive = false
				end
			end
			return
		end
		
		if not config.currentMob or not config.currentMob.Parent or not funcs.isValidMob(config.currentMob) then
			config.currentMob = funcs.getClosestMob()
			return
		end
		
		if config.currentMob then
			local lockPos = funcs.getLockPosition(config.currentMob)
			if lockPos then
				funcs.hoverToMob(lockPos, config.currentMob)
			end
		end
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MAIN MINING LOOP (WITH SMART LAVA DETECTION + PROXIMITY CHECK)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local Living = workspace:WaitForChild("Living")

	local miningLoop = RunService.Heartbeat:Connect(function()
		if not config.miningEnabled then 
			if config.currentRock then
				config.currentRock = nil
				config.currentRockModel = nil
				config.lastRockDurability = nil
				config.isLockedOn = false
			end
			if config.defendingAgainstMob then
				config.defendingAgainstMob = nil
				config.savedMiningRock = nil
				config.weaponEquipped = false
			end
			config.lastHealth = nil
			config.inLavaMode = false
			config.miningVerticalDistance = config.normalMiningDistance
			return 
		end
		
		if config.isRespawning then return end
		
		if not config.bodyVelocity or not config.bodyGyro then
			funcs.setupPhysicsMovement()
			return
		end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return end
		
		-- âœ… Check for lava damage
		checkLavaDamage()
		
		-- âœ… Monitor rock destruction to reset mining distance
		monitorRockDestruction()
		
		-- DEFENSE: CHECK FOR THREATS
		if config.miningDefenseEnabled then
			local closestThreat = nil
			local closestDistance = config.miningDefenseDistance
			
			for _, child in pairs(Living:GetChildren()) do
				if funcs.isValidMob(child) then
					local mobRoot = child:FindFirstChild("HumanoidRootPart")
					if mobRoot then
						local distance = (rootPart.Position - mobRoot.Position).Magnitude
						if distance < closestDistance then
							closestThreat = child
							closestDistance = distance
						end
					end
				end
			end
			
			if closestThreat and not config.defendingAgainstMob then
				print("ğŸš¨ THREAT: " .. closestThreat.Name .. " at " .. math.floor(closestDistance) .. " studs!")
				config.defendingAgainstMob = closestThreat
				config.savedMiningRock = config.currentRock
				config.currentRock = nil
				config.currentRockModel = nil
				config.isLockedOn = false
				config.weaponEquipped = false
				config.lastHealth = nil
				
				if pickaxeCheckLoop then
					pickaxeCheckLoop:Disconnect()
					pickaxeCheckLoop = nil
				end
				
				return
			end
			
			if closestThreat and config.defendingAgainstMob then
				config.defendingAgainstMob = closestThreat
			end
		end
		
		-- DEFENSE MODE: KILL THE MOB
		if config.defendingAgainstMob then
			if not config.defendingAgainstMob.Parent or not funcs.isValidMob(config.defendingAgainstMob) then
				print("âœ… THREAT ELIMINATED!")
				config.defendingAgainstMob = nil
				config.weaponEquipped = false
				config.isLockedOn = false
				
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:UnequipTools()
					task.wait(0.2)
				end
				
				config.currentRock = config.savedMiningRock
				if config.currentRock then
					config.currentRockModel = config.currentRock.Parent
				end
				config.savedMiningRock = nil
				
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					config.lastHealth = humanoid.Health
				end
				
				startAutoMine()
				
				print("â›ï¸ Resuming mining...")
				return
			end
			
			if not config.weaponEquipped then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:UnequipTools()
					task.wait(0.2)
				end
				
				local backpack = LocalPlayer:FindFirstChild("Backpack")
				if backpack then
					local weapon = backpack:FindFirstChild("Weapon")
					if weapon and weapon:IsA("Tool") then
						humanoid:EquipTool(weapon)
						task.wait(0.3)
						config.weaponEquipped = true
						print("âš”ï¸ WEAPON EQUIPPED!")
					end
				end
				return
			end
			
			local lockPos = funcs.getLockPosition(config.defendingAgainstMob)
			if lockPos then
				local distance = (rootPart.Position - lockPos).Magnitude
				
				funcs.hoverToMob(lockPos, config.defendingAgainstMob)
				
				if distance < 3 then
					config.isLockedOn = true
					
					local currentTime = tick()
					if currentTime - config.lastDefenseAttackTime >= config.defenseAttackCooldown then
						config.lastDefenseAttackTime = currentTime
						clickMouseForDefense()
					end
				end
			end
			
			return
		end
		
		-- âœ… NEW: Check if close to target and skip hover sequence
		if config.hoverSequenceActive and config.currentHoverTarget == 1 then
			if checkProximityToTarget() then
				config.hoverSequenceActive = false
				config.currentHoverTarget = 3
				print("âš¡ Starting mining immediately!")
				return
			end
		end
		
		-- NORMAL MINING
		if config.hoverSequenceActive then
			if config.currentHoverTarget == 1 then
				if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
					config.currentHoverTarget = 2
				end
			elseif config.currentHoverTarget == 2 then
				if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
					config.currentHoverTarget = 3
					config.hoverSequenceActive = false
				end
			end
			return
		end
		
		if config.currentRock and (not config.currentRock.Parent or not funcs.isValidRock(config.currentRock)) then
			print("ğŸª¨ Rock destroyed, finding new rock...")
			config.currentRock = nil
			config.currentRockModel = nil
			config.lastRockDurability = nil
			return
		end
		
		if not config.currentRock then
			config.currentRock = funcs.getClosestRock()
			
			if config.currentRock then
				config.currentRockModel = config.currentRock.Parent
				config.lastRockDurability = funcs.getRockDurability(config.currentRock)
				config.rockDurabilityCheck = tick()
				funcs.makeRockTransparent(config.currentRock)
				print("ğŸ¯ Locked onto rock: " .. config.currentRockModel.Name .. " (Durability: " .. tostring(config.lastRockDurability) .. ")")
			end
			return
		end
		
		if config.currentRock then
			local rockPos = funcs.getMiningPosition(config.currentRock)
			if rockPos then
				funcs.hoverToRock(rockPos, config.currentRock)
			end
		end
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CHARACTER RESPAWN HANDLER
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	LocalPlayer.CharacterAdded:Connect(function(character)
		config.currentMob = nil
		config.currentRock = nil
		config.currentRockModel = nil
		config.isLockedOn = false
		config.isRespawning = true
		config.hoverSequenceActive = false
		config.defendingAgainstMob = nil
		config.savedMiningRock = nil
		config.weaponEquipped = false
		config.lastHealth = nil
		config.inLavaMode = false
		config.miningVerticalDistance = config.normalMiningDistance
		config.lavaCheckCooldown = false
		funcs.cleanupPhysicsMovement()
		funcs.stopNoclip()
		
		local wasFarming = config.enabled
		local wasMining = config.miningEnabled
		
		if wasFarming or wasMining then
			character:WaitForChild("HumanoidRootPart", 10)
			task.wait(3)
			
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if rootPart then
				config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
				config.hoverSequenceActive = true
				config.currentHoverTarget = 1
				
				funcs.setupPhysicsMovement()
				funcs.startNoclip()
				
				if wasFarming then 
					funcs.autoEquipWeapon()
				end
				if wasMining then 
					funcs.autoEquipPickaxe()
					config.ignoredRocks = {}
					config.lastRockDurability = nil
					config.rockDurabilityCheck = tick()
					
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid then
						config.lastHealth = humanoid.Health
					end
				end
			end
			
			config.isRespawning = false
		else
			config.isRespawning = false
		end
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AUTO-INITIALIZATION FOR AUTOSELL
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	task.spawn(function()
		task.wait(0)
		print("ğŸ”„ Talking to seller...")
		funcs.talkToSeller()
		print("âœ… Ready to auto-sell!")
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- FINISH
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
