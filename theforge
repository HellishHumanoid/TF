-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RAFSO'S COMPLETE SCRIPT - PART 1: CORE SETUP & CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER POSITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498

local originalPosition = nil

-- Remote for selling
local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ITEMS BY RARITY (FOR AUTOSELL)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ItemsByRarity = {
    Common = {
        "Stone",
        "Sand Stone",
        "Copper",
        "Iron",
        "Cardboardite"
    },
    Uncommon = {
        "Cobalt",
        "Titanium",
        "Lapis Lazuli",
        "Tin",
        "Silver",
        "Gold",
        "Bananite"
    },
    Rare = {
        "Volcanic Rock",
        "Quartz",
        "Amethyst",
        "Boneite",
        "Dark Boneite",
        "Topaz",
        "Diamond",
        "Sapphire",
        "Mushroomite",
        "Platinum"
    },
    Epic = {
        "Aite",
        "Slimite",
        "Poopite",
        "Cuprite",
        "Obsidian",
        "Emerald",
        "Ruby",
        "Rivalite"
    },
    Legendary = {
        "Uranium",
        "Mythril",
        "Eye Ore",
        "Fireite",
        "Magmaite",
        "Lightite"
    },
    Mythical = {
        "Demonite",
        "Darkryte"
    },
    Rune = {
        "Frost Speck",
        "Venom Crumb",
        "Blast Chip",
        "Miner Shard",
        "Flame Spark",
        "Drain Edge",
        "Briar Notch",
        "Ward Patch",
        "Rot Stich",
        "Chill Dust",
        "Rage Mark"
    }
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GLOBAL CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
_G.MobFarmConfig = {
    -- Farming settings
    enabled = false,
    behindDistance = 8,
    verticalDistance = 8,
    farmDistance = 1000,
    hoverSpeed = 80,
    lockPosition = "Below",
    aboveAngle = 90,
    belowAngle = 240,
    
    -- Hover sequence
    hoverSequenceActive = false,
    currentHoverTarget = 1,
    hoverReachedThreshold = 3,
    hoverPosition1 = nil,
    
    -- Attack settings
    weaponRemote = nil,
    lastAttackTime = 0,
    attackCooldown = 0.25,
    lastWeaponCheckTime = 0,
    weaponCheckInterval = 0.5,
    
    -- State
    currentMob = nil,
    isLockedOn = false,
    bodyVelocity = nil,
    bodyGyro = nil,
    noclipLoop = nil,
    isRespawning = false,
    
    -- Mob types
    mobTypes = {
        {name = "Reaper", pattern = "^Reaper%d+$", enabled = false, priority = 1},
        {name = "Deathaxe Skeleton", pattern = "^Deathaxe Skeleton%d+$", enabled = false, priority = 2},
        {name = "Elite Deathaxe Skeleton", pattern = "^Elite Deathaxe Skeleton%d+$", enabled = false, priority = 3},
        {name = "Elite Rogue Skeleton", pattern = "^Elite Rogue Skeleton%d+$", enabled = false, priority = 4},
        {name = "Blazing Slime", pattern = "^Blazing Slime%d+$", enabled = false, priority = 5},
        {name = "Axe Skeleton", pattern = "^Axe Skeleton%d+$", enabled = false, priority = 6},
        {name = "Skeleton Rogue", pattern = "^Skeleton Rogue%d+$", enabled = false, priority = 7},
        {name = "Bomber", pattern = "^Bomber%d+$", enabled = false, priority = 8},
        {name = "Slime", pattern = "^Slime%d+$", enabled = false, priority = 9},
    },
    
    -- Mining system
    miningEnabled = false,
    miningVerticalDistance = 6,
    miningAngle = 270,
    currentRock = nil,
    lastMineTime = 0,
    miningCooldown = 0.1,
    lastPickaxeCheckTime = 0,
    pickaxeCheckInterval = 0.5,
    miningBodyVelocity = nil,
    miningBodyGyro = nil,
    ignoreGoblinCave = true,
    
    -- Rock damage tracking
    rockDurabilityCheck = 0,
    rockDurabilityCheckInterval = 3,
    lastRockDurability = nil,
    ignoredRocks = {},
    
    -- Rock types (PRIORITY ORDER)
    rockTypes = {
        {name = "Volcanic Rock", enabled = false, priority = 1},
        {name = "Earth Crystal", enabled = false, priority = 2},
        {name = "Violet Crystal", enabled = false, priority = 3},
        {name = "Crimson Crystal", enabled = false, priority = 4},
        {name = "Light Crystal", enabled = false, priority = 5},
        {name = "Cyan Crystal", enabled = false, priority = 6},
        {name = "Basalt Vein", enabled = false, priority = 7},
        {name = "Basalt Core", enabled = false, priority = 8},
        {name = "Basalt Rock", enabled = false, priority = 9},
        {name = "Boulder", enabled = false, priority = 10},
        {name = "Rock", enabled = false, priority = 11},
        {name = "Pebble", enabled = false, priority = 12},
    },
    
    -- AutoSell settings
    autoSellEnabled = false,
    sellCooldown = 1.5,
    lastSellTime = 0,
    autoClickerActive = false,
    autoClickerLoop = nil,
    selectedItems = {
        Common = {},
        Uncommon = {},
        Rare = {},
        Epic = {},
        Legendary = {},
        Mythical = {},
        Rune = {}
    }
}

local config = _G.MobFarmConfig

print("âœ… Part 1 Loaded: Core Setup & Config")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 2: NOCLIP & MOB/ROCK DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")
local config = _G.MobFarmConfig

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startNoclip()
    if config.noclipLoop then return end
    
    config.noclipLoop = RunService.Stepped:Connect(function()
        if not config.enabled and not config.miningEnabled then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

local function stopNoclip()
    if config.noclipLoop then
        config.noclipLoop:Disconnect()
        config.noclipLoop = nil
        
        local character = LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOB DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidMob(mob)
    local humanoid = mob:FindFirstChildOfClass("Humanoid")
    local rootPart = mob:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then return false end
    if humanoid.Health <= 0 then return false end
    if Players:GetPlayerFromCharacter(mob) then return false end
    
    return true
end

local function matchesMobPattern(mobName, pattern)
    return string.match(mobName, pattern) ~= nil
end

local function getMobPriority(mob)
    for _, mobData in ipairs(config.mobTypes) do
        if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
            return mobData.priority
        end
    end
    return 999
end

local function getClosestMob()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local closestMob = nil
    local closestDistance = config.farmDistance
    local highestPriority = 999
    
    for _, child in pairs(Living:GetChildren()) do
        if isValidMob(child) then
            for _, mobData in pairs(config.mobTypes) do
                if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
                    local mobRoot = child:FindFirstChild("HumanoidRootPart")
                    if mobRoot then
                        local distance = (rootPart.Position - mobRoot.Position).Magnitude
                        local priority = getMobPriority(child)
                        
                        if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
                            closestMob = child
                            closestDistance = distance
                            highestPriority = priority
                        end
                    end
                    break
                end
            end
        end
    end
    
    return closestMob
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ROCK DETECTION (FOR MINING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidRock(durabilityModel)
    if not durabilityModel:IsA("Model") then return false end
    if not durabilityModel.Parent then return false end
    
    local hasMeshPart = durabilityModel:FindFirstChildOfClass("MeshPart") ~= nil
    
    return hasMeshPart
end

local function isRockIgnored(rock)
    for _, ignoredRock in ipairs(config.ignoredRocks) do
        if ignoredRock == rock then
            return true
        end
    end
    return false
end

local function getRockPriority(rockTypeName)
    for _, rockData in ipairs(config.rockTypes) do
        if rockData.enabled and rockTypeName == rockData.name then
            return rockData.priority
        end
    end
    return 999
end

local function getRockPosition(durabilityModel)
    local rockPart = durabilityModel:FindFirstChild("Rock")
    if rockPart and rockPart:IsA("BasePart") then
        return rockPart
    end
    
    local rockTypeModel = durabilityModel.Parent
    if rockTypeModel then
        local hitbox = rockTypeModel:FindFirstChild("Hitbox")
        if hitbox and hitbox:IsA("BasePart") then
            return hitbox
        end
    end
    
    local meshPart = durabilityModel:FindFirstChildOfClass("MeshPart")
    if meshPart then
        return meshPart
    end
    
    return nil
end

local function getRockDurability(rock)
    if not rock then return nil end
    return tonumber(rock.Name)
end

local function getClosestRock()
    local character = LocalPlayer.Character
    if not character then 
        return nil 
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then 
        return nil 
    end
    
    local rocksFolder = workspace:FindFirstChild("Rocks")
    if not rocksFolder then
        return nil
    end
    
    local closestRock = nil
    local closestDistance = config.farmDistance
    local highestPriority = 999
    
    for _, islandFolder in pairs(rocksFolder:GetChildren()) do
        if islandFolder:IsA("Folder") then
            if config.ignoreGoblinCave and islandFolder.Name == "Island2GoblinCave" then
                continue
            end
            
            for _, spawnPart in pairs(islandFolder:GetChildren()) do
                if spawnPart:IsA("Part") and spawnPart.Name == "SpawnLocation" then
                    for _, rockTypeModel in pairs(spawnPart:GetChildren()) do
                        if rockTypeModel:IsA("Model") then
                            local rockTypeName = rockTypeModel.Name
                            local priority = getRockPriority(rockTypeName)
                            
                            if priority < 999 then
                                for _, durabilityModel in pairs(rockTypeModel:GetChildren()) do
                                    if durabilityModel:IsA("Model") and tonumber(durabilityModel.Name) then
                                        if not isRockIgnored(durabilityModel) and isValidRock(durabilityModel) then
                                            local positionPart = getRockPosition(durabilityModel)
                                            if positionPart then
                                                local distance = (rootPart.Position - positionPart.Position).Magnitude
                                                
                                                if distance <= config.farmDistance then
                                                    if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
                                                        closestRock = durabilityModel
                                                        closestDistance = distance
                                                        highestPriority = priority
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    return closestRock
end

local function makeRockTransparent(rock)
    if not rock then return end
    
    for _, descendant in pairs(rock:GetDescendants()) do
        if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
            descendant.Transparency = 0.7
        end
    end
    
    local rockTypeModel = rock.Parent
    if rockTypeModel then
        for _, descendant in pairs(rockTypeModel:GetDescendants()) do
            if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
                descendant.Transparency = 0.7
            end
        end
    end
end

-- Store functions globally
_G.FarmFunctions = {
    startNoclip = startNoclip,
    stopNoclip = stopNoclip,
    getClosestMob = getClosestMob,
    getClosestRock = getClosestRock,
    isValidMob = isValidMob,
    isValidRock = isValidRock,
    getRockPosition = getRockPosition,
    getRockDurability = getRockDurability,
    isRockIgnored = isRockIgnored,
    makeRockTransparent = makeRockTransparent,
}

print("âœ… Part 2 Loaded: Noclip & Detection Systems")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 3: WEAPON SYSTEM, AUTOSELL & PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WEAPON & TOOL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function autoEquipWeapon()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    local weaponInChar = character:FindFirstChild("Weapon")
    if weaponInChar and weaponInChar:IsA("Tool") then
        return true
    end
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local weapon = backpack:FindFirstChild("Weapon")
        if weapon and weapon:IsA("Tool") then
            humanoid:EquipTool(weapon)
            task.wait(0.2)
            return true
        end
    end
    
    return false
end

local function autoEquipPickaxe()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    local pickaxeInChar = character:FindFirstChild("Pickaxe")
    if pickaxeInChar and pickaxeInChar:IsA("Tool") then
        return true
    end
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local pickaxe = backpack:FindFirstChild("Pickaxe")
        if pickaxe and pickaxe:IsA("Tool") then
            humanoid:EquipTool(pickaxe)
            task.wait(0.2)
            return true
        end
    end
    
    return false
end

local function clickMouse()
    local success = pcall(function()
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        task.wait(0.01)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    end)
    return success
end

local function performAttack()
    if not config.isLockedOn or not config.currentMob or config.hoverSequenceActive then
        return
    end
    
    local currentTime = tick()
    if currentTime - config.lastAttackTime < config.attackCooldown then
        return
    end
    
    config.lastAttackTime = currentTime
    clickMouse()
end

local function performMine()
    if not config.currentRock then return end
    if not config.miningEnabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local pickaxe = character:FindFirstChild("Pickaxe")
    if not pickaxe then
        autoEquipPickaxe()
        return
    end
    
    local currentTime = tick()
    if currentTime - config.lastMineTime < config.miningCooldown then
        return
    end
    
    config.lastMineTime = currentTime
    clickMouse()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498
local originalPosition = nil

local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

local function startAutoClickerAt(x, y, duration)
    if config.autoClickerActive then return end
    
    config.autoClickerActive = true
    print("ğŸ–±ï¸ AutoClicker started at: X=" .. x .. ", Y=" .. y .. " for " .. duration .. " seconds")
    
    config.autoClickerLoop = task.spawn(function()
        local startTime = tick()
        local clicks = 0
        while config.autoClickerActive and (tick() - startTime) < duration do
            VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
            task.wait(0.01)
            VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
            clicks = clicks + 1
            task.wait(0.05)
        end
        config.autoClickerActive = false
        print("ğŸ›‘ AutoClicker stopped after " .. clicks .. " clicks")
    end)
end

local function stopAutoClicker()
    config.autoClickerActive = false
    if config.autoClickerLoop then
        task.cancel(config.autoClickerLoop)
        config.autoClickerLoop = nil
    end
end

local function closeChat()
    task.wait(0.3)
    print("ğŸ”˜ Starting autoclicker at No button position: X=" .. NO_BUTTON_X .. ", Y=" .. NO_BUTTON_Y)
    startAutoClickerAt(NO_BUTTON_X, NO_BUTTON_Y, 3)
    task.wait(0.3)
    stopAutoClicker()
    print("âœ… Dialogue close attempt complete")
end

local function talkToSeller()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    originalPosition = rootPart.CFrame
    print("ğŸ’¾ Saved original position: " .. tostring(originalPosition.Position))
    
    rootPart.CFrame = CFrame.new(SELLER_POSITION)
    task.wait(0.5)
    
    if SELLER_PROXIMITY then
        fireproximityprompt(SELLER_PROXIMITY)
        task.wait(0.5)
        closeChat()
        task.wait(0)
        
        if originalPosition then
            rootPart.CFrame = originalPosition
            print("ğŸ”™ Teleported back to original position")
        end
        
        return true
    end
    
    return false
end

local function getItemQuantity(itemName)
    local success, quantity = pcall(function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
        if not playerGui then return 0 end
        
        local menu = playerGui:FindFirstChild("Menu")
        if not menu then return 0 end
        
        local stash = menu:FindFirstChild("Frame", true)
        if stash then
            stash = stash:FindFirstChild("Frame", true)
            if stash then
                stash = stash:FindFirstChild("Menus", true)
                if stash then
                    stash = stash:FindFirstChild("Stash", true)
                    if stash then
                        stash = stash:FindFirstChild("Background", true)
                        if stash then
                            for _, itemFolder in pairs(stash:GetChildren()) do
                                if itemFolder:IsA("Folder") or itemFolder:IsA("Frame") then
                                    local main = itemFolder:FindFirstChild("Main")
                                    if main then
                                        if itemFolder.Name == itemName then
                                            local quantityLabel = main:FindFirstChild("Quantity")
                                            if quantityLabel and quantityLabel:IsA("TextLabel") then
                                                local quantityText = quantityLabel.Text
                                                local number = tonumber(string.match(quantityText, "%d+"))
                                                return number or 0
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return 0
    end)
    
    if success then
        return quantity
    else
        return 0
    end
end

local function sellItems()
    if not config.autoSellEnabled then return end
    
    local currentTime = tick()
    if currentTime - config.lastSellTime < config.sellCooldown then
        return
    end
    
    local itemsToSell = {}
    
    for rarity, items in pairs(config.selectedItems) do
        if rarity ~= "Rune" then
            for _, itemName in ipairs(items) do
                local quantity = getItemQuantity(itemName)
                
                if quantity > 0 then
                    itemsToSell[itemName] = quantity
                    print(string.format("ğŸ“¦ %s: %d", itemName, quantity))
                end
            end
        end
    end
    
    local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
    if playerGui then
        local menu = playerGui:FindFirstChild("Menu")
        if menu then
            local stash = menu:FindFirstChild("Frame", true)
            if stash then
                stash = stash:FindFirstChild("Frame", true)
                if stash then
                    stash = stash:FindFirstChild("Menus", true)
                    if stash then
                        stash = stash:FindFirstChild("Stash", true)
                        if stash then
                            stash = stash:FindFirstChild("Background", true)
                            if stash then
                                for _, itemFolder in pairs(stash:GetChildren()) do
                                    local main = itemFolder:FindFirstChild("Main")
                                    if main then
                                        local itemNameLabel = main:FindFirstChild("ItemName")
                                        if itemNameLabel and itemNameLabel:IsA("TextLabel") then
                                            local itemName = itemNameLabel.Text
                                            
                                            for _, selectedRuneName in ipairs(config.selectedItems.Rune) do
                                                if itemName == selectedRuneName then
                                                    itemsToSell[itemFolder.Name] = 1
                                                    print(string.format("ğŸ”® %s (UUID: %s): 1", itemName, itemFolder.Name))
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    if next(itemsToSell) == nil then
        return
    end
    
    local success, err = pcall(function()
        RunCommand:InvokeServer("SellConfirm", {Basket = itemsToSell})
    end)
    
    if success then
        config.lastSellTime = currentTime
        print("âœ… Sold items successfully")
    else
        print("âŒ Error selling: " .. tostring(err))
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function setupPhysicsMovement()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    if config.bodyVelocity then
        config.bodyVelocity:Destroy()
    end
    if config.bodyGyro then
        config.bodyGyro:Destroy()
    end
    
    local bv = Instance.new("BodyVelocity")
    bv.Name = "FarmVelocity"
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.P = 1250
    bv.Parent = rootPart
    config.bodyVelocity = bv
    
    local bg = Instance.new("BodyGyro")
    bg.Name = "FarmGyro"
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.P = 30000
    bg.D = 1000
    bg.Parent = rootPart
    config.bodyGyro = bg
    
    rootPart.Anchored = false
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end
    
    return true
end

local function cleanupPhysicsMovement()
    if config.bodyVelocity then
        config.bodyVelocity:Destroy()
        config.bodyVelocity = nil
    end
    if config.bodyGyro then
        config.bodyGyro:Destroy()
        config.bodyGyro = nil
    end
    
    local character = LocalPlayer.Character
    if character then
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.Anchored = false
            rootPart.Velocity = Vector3.new(0, 0, 0)
        end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            task.wait(0.1)
            humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
        end
    end
    
    config.isLockedOn = false
end

-- Add to global functions
funcs.autoEquipWeapon = autoEquipWeapon
funcs.autoEquipPickaxe = autoEquipPickaxe
funcs.performAttack = performAttack
funcs.performMine = performMine
funcs.setupPhysicsMovement = setupPhysicsMovement
funcs.cleanupPhysicsMovement = cleanupPhysicsMovement
funcs.talkToSeller = talkToSeller
funcs.sellItems = sellItems

print("âœ… Part 3 Loaded: Weapon, AutoSell & Physics")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 4: MOVEMENT LOGIC & HOVERING (FIXED - BETTER MOB TRACKING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- POSITION CALCULATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getLockPosition(mob)
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    if not mobRoot then return nil end
    
    local distance = config.behindDistance
    local verticalDist = config.verticalDistance
    local mobPos = mobRoot.Position
    local targetPos
    
    if config.lockPosition == "Back" then
        local behindOffset = -mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + behindOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    elseif config.lockPosition == "Front" then
        local frontOffset = mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + frontOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    elseif config.lockPosition == "Above" then
        targetPos = mobPos + Vector3.new(0, verticalDist, 0)
    elseif config.lockPosition == "Below" then
        targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
    else
        local behindOffset = -mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + behindOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    end
    
    return targetPos
end

local function getMiningPosition(rock)
    if not rock then return nil end
    
    local positionPart = funcs.getRockPosition(rock)
    if not positionPart then 
        return nil 
    end
    
    local rockPos = positionPart.Position
    local targetPos = rockPos + Vector3.new(0, -config.miningVerticalDistance, 0)
    
    return targetPos
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function hoverToPosition(targetPos, lookAtPos)
    local character = LocalPlayer.Character
    if not character then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not config.bodyVelocity or not config.bodyGyro then
        return false
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    if distance < config.hoverReachedThreshold then
        config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        return true
    end
    
    local speedMultiplier = math.min(distance / 10, 1)
    local targetSpeed = config.hoverSpeed * speedMultiplier
    
    local desiredVelocity = direction.Unit * targetSpeed
    local currentVelocity = config.bodyVelocity.Velocity
    local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
    
    config.bodyVelocity.Velocity = newVelocity
    
    if lookAtPos then
        local lookCFrame = CFrame.new(currentPos, lookAtPos)
        config.bodyGyro.CFrame = lookCFrame
    end
    
    return false
end

-- âœ… FIXED: Better mob tracking - follows mob even when close
local function hoverToMob(targetPos, mob)
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
        return
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    -- âœ… CRITICAL FIX: Mark as locked on when close, but KEEP FOLLOWING the mob
    config.isLockedOn = distance < 5  -- Slightly larger range for attacking
    
    -- Handle Above/Below positions (stationary attack angle)
    if (config.lockPosition == "Above" or config.lockPosition == "Below") and distance < 3 then
        -- âœ… FIX: Still follow mob position even when locked
        local followSpeed = 15  -- Slower speed to track mob
        local desiredVelocity = direction.Unit * followSpeed
        config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.2)
        
        -- Set attack angle
        if config.lockPosition == "Above" then
            local angle = math.rad(config.aboveAngle)
            local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
            config.bodyGyro.CFrame = downCFrame
        else
            local angle = math.rad(config.belowAngle)
            local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
            config.bodyGyro.CFrame = upCFrame
        end
        return
    end
    
    -- âœ… FIX: For Back/Front positions, ALWAYS follow the mob
    -- Use slower speed when close, faster when far
    local targetSpeed
    if distance < 3 then
        -- Close range: slow tracking to match mob movement
        targetSpeed = 20
    else
        -- Far range: fast approach
        targetSpeed = config.hoverSpeed * math.min(distance / 10, 1)
    end
    
    local desiredVelocity = direction.Unit * targetSpeed
    
    -- âœ… FIX: Smoother lerp when close for better tracking
    local lerpSpeed = distance < 3 and 0.4 or 0.3
    local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, lerpSpeed)
    
    config.bodyVelocity.Velocity = newVelocity
    
    -- âœ… FIX: Always look at mob for better hitbox alignment
    local lookCFrame = CFrame.new(currentPos, mobRoot.Position)
    local gyroLerpSpeed = distance < 3 and 0.5 or 0.3
    config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, gyroLerpSpeed)
end

local function hoverToRock(targetPos, rock)
    if not targetPos then 
        return 
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not config.bodyVelocity or not config.bodyGyro then
        return
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    if distance < 3 then
        config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        
        local angle = math.rad(config.miningAngle)
        local lookCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
        config.bodyGyro.CFrame = lookCFrame
        config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        config.bodyGyro.P = 50000
        return
    end
    
    local speedMultiplier = math.min(distance / 10, 1)
    local targetSpeed = config.hoverSpeed * speedMultiplier
    local desiredVelocity = direction.Unit * targetSpeed
    local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.5)
    
    config.bodyVelocity.Velocity = newVelocity
    
    local positionPart = funcs.getRockPosition(rock)
    if positionPart then
        local lookCFrame = CFrame.new(currentPos, positionPart.Position)
        config.bodyGyro.CFrame = lookCFrame
        config.bodyGyro.P = 10000
    end
end

-- Add to global functions
funcs.getLockPosition = getLockPosition
funcs.getMiningPosition = getMiningPosition
funcs.hoverToPosition = hoverToPosition
funcs.hoverToMob = hoverToMob
funcs.hoverToRock = hoverToRock

print("âœ… Part 4 Loaded: Movement Logic & Hovering (FIXED - Better Mob Tracking)")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 5: RAYFIELD GUI & AUTO-LOOPS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- LOAD RAYFIELD
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Rafso's Complete Hub",
   LoadingTitle = "Loading",
   LoadingSubtitle = "by Rafso",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "RafsoHub",
      FileName = "CompleteConfig"
   },
   KeySystem = false,
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOOPS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local attackLoop = nil
local mineLoop = nil
local weaponCheckLoop = nil
local pickaxeCheckLoop = nil
local sellLoop = nil

local function startAutoAttack()
    if attackLoop then return end
    
    task.spawn(function()
        task.wait(0.5)
        funcs.autoEquipWeapon()
    end)
    
    attackLoop = RunService.Heartbeat:Connect(function()
        if not config.enabled then return end
        funcs.performAttack()
    end)
    
    if not weaponCheckLoop then
        weaponCheckLoop = RunService.Heartbeat:Connect(function()
            if not config.enabled then return end
            local currentTime = tick()
            if currentTime - config.lastWeaponCheckTime >= config.weaponCheckInterval then
                config.lastWeaponCheckTime = currentTime
                funcs.autoEquipWeapon()
            end
        end)
    end
end

local function stopAutoAttack()
    if attackLoop then
        attackLoop:Disconnect()
        attackLoop = nil
    end
    if weaponCheckLoop then
        weaponCheckLoop:Disconnect()
        weaponCheckLoop = nil
    end
end

local function startAutoMine()
    if mineLoop then return end
    
    task.spawn(function()
        task.wait(0.3)
        funcs.autoEquipPickaxe()
    end)
    
    mineLoop = RunService.Heartbeat:Connect(function()
        if not config.miningEnabled then return end
        funcs.performMine()
    end)
    
    if not pickaxeCheckLoop then
        pickaxeCheckLoop = RunService.Heartbeat:Connect(function()
            if not config.miningEnabled then return end
            local currentTime = tick()
            if currentTime - config.lastPickaxeCheckTime >= config.pickaxeCheckInterval then
                config.lastPickaxeCheckTime = currentTime
                funcs.autoEquipPickaxe()
            end
        end)
    end
end

local function stopAutoMine()
    if mineLoop then
        mineLoop:Disconnect()
        mineLoop = nil
    end
    if pickaxeCheckLoop then
        pickaxeCheckLoop:Disconnect()
        pickaxeCheckLoop = nil
    end
end

local function startAutoSell()
    if sellLoop then return end
    
    sellLoop = RunService.Heartbeat:Connect(function()
        if not config.autoSellEnabled then return end
        funcs.sellItems()
    end)
end

local function stopAutoSell()
    if sellLoop then
        sellLoop:Disconnect()
        sellLoop = nil
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FARMING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FarmTab = Window:CreateTab("âš”ï¸ Farming", 4483362458)

local FarmToggle = FarmTab:CreateToggle({
   Name = "Enable Mob Farming (F1)",
   CurrentValue = false,
   Flag = "FarmToggle",
   Callback = function(Value)
      config.enabled = Value
      
      if config.enabled then
         local character = LocalPlayer.Character
         if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
               config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
               config.hoverSequenceActive = true
               config.currentHoverTarget = 1
            end
         end
         
         funcs.setupPhysicsMovement()
         funcs.startNoclip()
         startAutoAttack()
      else
         config.hoverSequenceActive = false
         config.currentMob = nil
         stopAutoAttack()
         funcs.stopNoclip()
         funcs.cleanupPhysicsMovement()
      end
   end,
})

FarmTab:CreateSection("Lock Position")

local LockPositionDropdown = FarmTab:CreateDropdown({
   Name = "Lock Position",
   Options = {"Back", "Front", "Above", "Below"},
   CurrentOption = {"Below"},
   MultipleOptions = false,
   Flag = "LockPosition",
   Callback = function(Option)
      config.lockPosition = Option[1]
   end,
})

FarmTab:CreateSection("Mob Selection")

local mobOptions = {}
for i, mobData in ipairs(config.mobTypes) do
   table.insert(mobOptions, mobData.name)
end

local MobDropdown = FarmTab:CreateDropdown({
   Name = "Select Mobs to Farm",
   Options = mobOptions,
   CurrentOption = {},
   MultipleOptions = true,
   Flag = "MobDropdown",
   Callback = function(Options)
      for i, mobData in ipairs(config.mobTypes) do
         config.mobTypes[i].enabled = false
      end
      
      for _, selectedMob in ipairs(Options) do
         for i, mobData in ipairs(config.mobTypes) do
            if mobData.name == selectedMob then
               config.mobTypes[i].enabled = true
               break
            end
         end
      end
   end,
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MineTab = Window:CreateTab("â›ï¸ Mining", 4483362458)

local MineToggle = MineTab:CreateToggle({
   Name = "Enable Mining (F2)",
   CurrentValue = false,
   Flag = "MineToggle",
   Callback = function(Value)
      config.miningEnabled = Value
      
      if config.miningEnabled then
         config.ignoredRocks = {}
         config.lastRockDurability = nil
         config.rockDurabilityCheck = tick()
         config.currentRock = nil
         
         local character = LocalPlayer.Character
         if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
               config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
               config.hoverSequenceActive = true
               config.currentHoverTarget = 1
            end
         end
         
         funcs.setupPhysicsMovement()
         funcs.startNoclip()
         startAutoMine()
      else
         config.hoverSequenceActive = false
         config.currentHoverTarget = 1
         config.currentRock = nil
         config.ignoredRocks = {}
         config.lastRockDurability = nil
         config.isLockedOn = false
         
         stopAutoMine()
         funcs.stopNoclip()
         funcs.cleanupPhysicsMovement()
         
         local character = LocalPlayer.Character
         if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
               rootPart.Velocity = Vector3.new(0, 0, 0)
               rootPart.Anchored = false
            end
         end
      end
   end,
})

MineTab:CreateSection("Rock Selection")

local rockOptions = {}
for i, rockData in ipairs(config.rockTypes) do
   table.insert(rockOptions, rockData.name)
end

local RockDropdown = MineTab:CreateDropdown({
   Name = "Select Rocks to Mine",
   Options = rockOptions,
   CurrentOption = {},
   MultipleOptions = true,
   Flag = "RockDropdown",
   Callback = function(Options)
      for i, rockData in ipairs(config.rockTypes) do
         config.rockTypes[i].enabled = false
      end
      
      for _, selectedRock in ipairs(Options) do
         for i, rockData in ipairs(config.rockTypes) do
            if rockData.name == selectedRock then
               config.rockTypes[i].enabled = true
               break
            end
         end
      end
   end,
})

print("âœ… Part 5 Loaded: Rayfield GUI & Auto-Loops")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 6: AUTOSELL TAB & SETTINGS (COMPLETE WITH FIXED KEYBINDS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SellTab = Window:CreateTab("ğŸ’° AutoSell", 4483362458)

SellTab:CreateSection("Auto Sell")

local AutoSellToggle = SellTab:CreateToggle({
    Name = "Enable Auto Sell",
    CurrentValue = false,
    Flag = "AutoSellToggle",
    Callback = function(Value)
        config.autoSellEnabled = Value
        
        if config.autoSellEnabled then
            print("ğŸŸ¢ AutoSell Enabled")
            startAutoSell()
        else
            print("ğŸ”´ AutoSell Disabled")
            stopAutoSell()
        end
    end,
})

SellTab:CreateSection("Select Items to Auto Sell")

-- Common Items
SellTab:CreateDropdown({
    Name = "Common Items",
    Options = ItemsByRarity.Common,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "CommonDropdown",
    Callback = function(Options)
        config.selectedItems.Common = Options
    end,
})

-- Uncommon Items
SellTab:CreateDropdown({
    Name = "Uncommon Items",
    Options = ItemsByRarity.Uncommon,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "UncommonDropdown",
    Callback = function(Options)
        config.selectedItems.Uncommon = Options
    end,
})

-- Rare Items
SellTab:CreateDropdown({
    Name = "Rare Items",
    Options = ItemsByRarity.Rare,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "RareDropdown",
    Callback = function(Options)
        config.selectedItems.Rare = Options
    end,
})

-- Epic Items
SellTab:CreateDropdown({
    Name = "Epic Items",
    Options = ItemsByRarity.Epic,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "EpicDropdown",
    Callback = function(Options)
        config.selectedItems.Epic = Options
    end,
})

-- Legendary Items
SellTab:CreateDropdown({
    Name = "Legendary Items",
    Options = ItemsByRarity.Legendary,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "LegendaryDropdown",
    Callback = function(Options)
        config.selectedItems.Legendary = Options
    end,
})

-- Mythical Items
SellTab:CreateDropdown({
    Name = "Mythical Items",
    Options = ItemsByRarity.Mythical,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "MythicalDropdown",
    Callback = function(Options)
        config.selectedItems.Mythical = Options
    end,
})

-- Rune Items
SellTab:CreateDropdown({
    Name = "Rune Items",
    Options = ItemsByRarity.Rune,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "RuneDropdown",
    Callback = function(Options)
        config.selectedItems.Rune = Options
    end,
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SettingsTab = Window:CreateTab("âš™ï¸ Settings", 4483362458)

SettingsTab:CreateSection("General Settings")

SettingsTab:CreateSlider({
   Name = "Hover Speed",
   Range = {20, 150},
   Increment = 5,
   CurrentValue = 80,
   Flag = "HoverSpeed",
   Callback = function(Value)
      config.hoverSpeed = Value
   end,
})

SettingsTab:CreateSection("Farm Settings")

SettingsTab:CreateSlider({
   Name = "Vertical Distance",
   Range = {1, 20},
   Increment = 1,
   CurrentValue = 8,
   Flag = "VerticalDistance",
   Callback = function(Value)
      config.verticalDistance = Value
   end,
})

SettingsTab:CreateSection("Mining Settings")

SettingsTab:CreateSlider({
   Name = "Mining Vertical Distance",
   Range = {1, 15},
   Increment = 1,
   CurrentValue = 6,
   Flag = "MiningVerticalDistance",
   Callback = function(Value)
      config.miningVerticalDistance = Value
   end,
})

SettingsTab:CreateToggle({
   Name = "Ignore Goblin Cave Rocks",
   CurrentValue = true,
   Flag = "IgnoreGoblinCave",
   Callback = function(Value)
      config.ignoreGoblinCave = Value
   end,
})

SettingsTab:CreateSection("Script Control")

SettingsTab:CreateButton({
   Name = "Destroy GUI",
   Callback = function()
      if farmLoop then farmLoop:Disconnect() end
      if miningLoop then miningLoop:Disconnect() end
      stopAutoAttack()
      stopAutoMine()
      stopAutoSell()
      
      if keybindConnection then
         keybindConnection:Disconnect()
         keybindConnection = nil
      end
      
      funcs.stopNoclip()
      funcs.cleanupPhysicsMovement()
      
      config.enabled = false
      config.miningEnabled = false
      config.autoSellEnabled = false
      
      _G.MobFarmConfig = nil
      _G.FarmFunctions = nil
      
      Rayfield:Destroy()
   end,
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- KEYBIND SYSTEM (F1/F2) - FIXED VERSION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local keybindConnection = nil

keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if not _G.MobFarmConfig or not _G.FarmFunctions then
        return
    end
    
    if input.KeyCode == Enum.KeyCode.F1 then
        config.enabled = not config.enabled
        
        if FarmToggle then
            FarmToggle:Set(config.enabled)
        end
        
        if config.enabled then
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
                    config.hoverSequenceActive = true
                    config.currentHoverTarget = 1
                end
            end
            
            funcs.setupPhysicsMovement()
            funcs.startNoclip()
            startAutoAttack()
        else
            config.hoverSequenceActive = false
            config.currentMob = nil
            stopAutoAttack()
            funcs.stopNoclip()
            funcs.cleanupPhysicsMovement()
        end
        
    elseif input.KeyCode == Enum.KeyCode.F2 then
        config.miningEnabled = not config.miningEnabled
        
        if MineToggle then
            MineToggle:Set(config.miningEnabled)
        end
        
        if config.miningEnabled then
            print("â›ï¸ Mining ENABLED")
            config.ignoredRocks = {}
            config.lastRockDurability = nil
            config.rockDurabilityCheck = tick()
            config.currentRock = nil
            
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
                    config.hoverSequenceActive = true
                    config.currentHoverTarget = 1
                end
            end
            
            funcs.setupPhysicsMovement()
            funcs.startNoclip()
            startAutoMine()
        else
            -- âœ… FIXED: Complete cleanup when disabled
            print("â›ï¸ Mining DISABLED - Cleaning up...")
            
            config.hoverSequenceActive = false
            config.currentHoverTarget = 1
            config.currentRock = nil
            config.ignoredRocks = {}
            config.lastRockDurability = nil
            config.isLockedOn = false
            
            -- Stop all mining activities
            stopAutoMine()
            funcs.stopNoclip()
            funcs.cleanupPhysicsMovement()
            
            -- Reset character physics
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Velocity = Vector3.new(0, 0, 0)
                    rootPart.RotVelocity = Vector3.new(0, 0, 0)
                    rootPart.Anchored = false
                end
                
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
                    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
                end
            end
            
            print("âœ… Mining cleanup complete")
        end
    end
end)

print("âœ… Part 6 Loaded: AutoSell Tab & Settings (FIXED)")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 7: MAIN LOOPS & CHARACTER RESPAWN HANDLER (INSTANT ROCK SWITCH)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING DEFENSE CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

config.miningDefenseEnabled = true
config.miningDefenseDistance = 10
config.defendingAgainstMob = nil
config.savedMiningRock = nil
config.weaponEquipped = false
config.lastDefenseAttackTime = 0
config.defenseAttackCooldown = 0.1

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- LAVA CHECK CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

config.lavaCheckEnabled = true
config.lastHealth = nil
config.lavaTeleportHeight = 6
config.inLavaCooldown = false
config.lavaCooldownTime = 2

local function checkLavaDamage()
    if not config.miningEnabled or config.defendingAgainstMob or not config.lavaCheckEnabled then
        return
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local currentHealth = humanoid.Health
    
    if not config.lastHealth then
        config.lastHealth = currentHealth
        return
    end
    
    if currentHealth < config.lastHealth and not config.inLavaCooldown then
        print("ğŸ”¥ LAVA DAMAGE DETECTED! Teleporting up...")
        config.inLavaCooldown = true
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart and config.currentRock then
            local positionPart = funcs.getRockPosition(config.currentRock)
            if positionPart then
                local rockPos = positionPart.Position
                local safePos = rockPos + Vector3.new(0, config.lavaTeleportHeight, 0)
                rootPart.CFrame = CFrame.new(safePos)
                
                if config.bodyVelocity then
                    config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                
                print("âœ… Teleported to safety at " .. config.lavaTeleportHeight .. " studs above rock")
            end
        end
        
        task.delay(config.lavaCooldownTime, function()
            config.inLavaCooldown = false
        end)
    end
    
    config.lastHealth = currentHealth
end

local function clickMouseForDefense()
    local success = pcall(function()
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        task.wait(0.01)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    end)
    return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- IMPROVED MESSAGE DETECTION SYSTEM (INSTANT ROCK SWITCH)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local lastMessageTime = 0
local MESSAGE_COOLDOWN = 0.5  -- Reduced from 1 second for faster detection

-- âœ… INSTANT rock switch function
local function switchToNewRock(reason)
    if config.currentRock and config.miningEnabled and not config.defendingAgainstMob then
        print("âš ï¸ " .. reason)
        print("ğŸš« INSTANTLY switching to new rock...")
        
        -- Add to ignore list
        table.insert(config.ignoredRocks, config.currentRock)
        
        -- Clear current rock IMMEDIATELY
        config.currentRock = nil
        config.lastRockDurability = nil
        config.isLockedOn = false
        
        -- Force body velocity to stop moving to old rock
        local character = LocalPlayer.Character
        if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart and config.bodyVelocity then
                config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
        
        print("âœ… Ready to find new rock!")
    end
end

-- âœ… METHOD 1: Monitor ALL TextLabels in PlayerGui
local function setupTextLabelMonitoring()
    local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
    if not playerGui then return end
    
    local function monitorTextLabel(textLabel)
        if not textLabel:IsA("TextLabel") then return end
        
        local connection
        connection = textLabel:GetPropertyChangedSignal("Text"):Connect(function()
            if (tick() - lastMessageTime) < MESSAGE_COOLDOWN then return end
            
            local text = textLabel.Text:lower()
            
            if text:find("already mining") or 
               text:find("someone else") or 
               text:find("being mined") or
               text:find("another player") then
                
                lastMessageTime = tick()
                switchToNewRock("Detected: Another player is mining this rock!")
            end
        end)
    end
    
    -- Monitor existing labels
    for _, gui in pairs(playerGui:GetDescendants()) do
        monitorTextLabel(gui)
    end
    
    -- Monitor new labels
    playerGui.DescendantAdded:Connect(function(descendant)
        task.wait(0.05)
        monitorTextLabel(descendant)
    end)
end

-- âœ… METHOD 2: Monitor StarterGui notifications
local function setupStarterGuiMonitoring()
    local starterGui = game:GetService("StarterGui")
    
    -- Hook into SetCore notifications
    local oldSetCore = starterGui.SetCore
    starterGui.SetCore = function(self, ...)
        local args = {...}
        if args[1] == "ChatMakeSystemMessage" or args[1] == "SendNotification" then
            local message = ""
            if type(args[2]) == "table" then
                message = tostring(args[2].Text or ""):lower()
            else
                message = tostring(args[2] or ""):lower()
            end
            
            if message:find("already mining") or 
               message:find("someone else") or 
               message:find("being mined") then
                
                switchToNewRock("Detected notification: Rock being mined by another player!")
            end
        end
        return oldSetCore(self, ...)
    end
end

-- âœ… METHOD 3: Monitor specific common GUI paths
local function setupCommonGuiMonitoring()
    local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
    if not playerGui then return end
    
    -- Common notification GUI names
    local commonPaths = {
        "Notifications",
        "SystemMessages", 
        "Messages",
        "Hints",
        "Popups",
        "ErrorMessages",
        "Chat"
    }
    
    for _, guiName in ipairs(commonPaths) do
        local gui = playerGui:FindFirstChild(guiName)
        if gui then
            gui.DescendantAdded:Connect(function(descendant)
                if descendant:IsA("TextLabel") or descendant:IsA("TextBox") then
                    task.wait(0.05)
                    local text = descendant.Text:lower()
                    
                    if text:find("already mining") or 
                       text:find("someone else") or 
                       text:find("being mined") then
                        
                        switchToNewRock("Detected in " .. guiName .. ": Rock occupied!")
                    end
                end
            end)
        end
    end
end

-- âœ… METHOD 4: Direct chat monitoring
local function setupChatMonitoring()
    local chatService = game:GetService("Chat")
    local textChatService = game:GetService("TextChatService")
    
    -- Try new TextChatService
    pcall(function()
        textChatService.MessageReceived:Connect(function(message)
            local text = message.Text:lower()
            if text:find("already mining") or 
               text:find("someone else") or 
               text:find("being mined") then
                
                switchToNewRock("Detected in chat: Rock occupied!")
            end
        end)
    end)
end

-- âœ… Initialize ALL detection methods (redundancy for reliability)
task.spawn(function()
    task.wait(1)
    print("ğŸ” Setting up INSTANT rock switch detection...")
    
    setupTextLabelMonitoring()
    print("âœ… Method 1: TextLabel monitoring active")
    
    setupStarterGuiMonitoring()
    print("âœ… Method 2: StarterGui monitoring active")
    
    setupCommonGuiMonitoring()
    print("âœ… Method 3: Common GUI monitoring active")
    
    setupChatMonitoring()
    print("âœ… Method 4: Chat monitoring active")
    
    print("ğŸ¯ All detection methods ready!")
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN FARMING LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local farmLoop = RunService.Heartbeat:Connect(function()
    if not config.enabled or config.isRespawning then return end
    
    if not config.bodyVelocity or not config.bodyGyro then
        funcs.setupPhysicsMovement()
        return
    end
    
    if config.hoverSequenceActive then
        if config.currentHoverTarget == 1 then
            if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
                config.currentHoverTarget = 2
            end
        elseif config.currentHoverTarget == 2 then
            if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
                config.currentHoverTarget = 3
                config.hoverSequenceActive = false
            end
        end
        return
    end
    
    if not config.currentMob or not config.currentMob.Parent or not funcs.isValidMob(config.currentMob) then
        config.currentMob = funcs.getClosestMob()
        return
    end
    
    if config.currentMob then
        local lockPos = funcs.getLockPosition(config.currentMob)
        if lockPos then
            funcs.hoverToMob(lockPos, config.currentMob)
        end
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN MINING LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Living = workspace:WaitForChild("Living")

local miningLoop = RunService.Heartbeat:Connect(function()
    if not config.miningEnabled then 
        if config.currentRock then
            config.currentRock = nil
            config.lastRockDurability = nil
            config.isLockedOn = false
        end
        if config.defendingAgainstMob then
            config.defendingAgainstMob = nil
            config.savedMiningRock = nil
            config.weaponEquipped = false
        end
        config.lastHealth = nil
        return 
    end
    
    if config.isRespawning then return end
    
    if not config.bodyVelocity or not config.bodyGyro then
        funcs.setupPhysicsMovement()
        return
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    checkLavaDamage()
    
    -- DEFENSE: CHECK FOR THREATS
    if config.miningDefenseEnabled then
        local closestThreat = nil
        local closestDistance = config.miningDefenseDistance
        
        for _, child in pairs(Living:GetChildren()) do
            if funcs.isValidMob(child) then
                local mobRoot = child:FindFirstChild("HumanoidRootPart")
                if mobRoot then
                    local distance = (rootPart.Position - mobRoot.Position).Magnitude
                    if distance < closestDistance then
                        closestThreat = child
                        closestDistance = distance
                    end
                end
            end
        end
        
        if closestThreat and not config.defendingAgainstMob then
            print("ğŸš¨ THREAT: " .. closestThreat.Name .. " at " .. math.floor(closestDistance) .. " studs!")
            config.defendingAgainstMob = closestThreat
            config.savedMiningRock = config.currentRock
            config.currentRock = nil
            config.isLockedOn = false
            config.weaponEquipped = false
            config.lastHealth = nil
            
            if pickaxeCheckLoop then
                pickaxeCheckLoop:Disconnect()
                pickaxeCheckLoop = nil
            end
            
            return
        end
        
        if closestThreat and config.defendingAgainstMob then
            config.defendingAgainstMob = closestThreat
        end
    end
    
    -- DEFENSE MODE: KILL THE MOB
    if config.defendingAgainstMob then
        if not config.defendingAgainstMob.Parent or not funcs.isValidMob(config.defendingAgainstMob) then
            print("âœ… THREAT ELIMINATED!")
            config.defendingAgainstMob = nil
            config.weaponEquipped = false
            config.isLockedOn = false
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:UnequipTools()
                task.wait(0.2)
            end
            
            config.currentRock = config.savedMiningRock
            config.savedMiningRock = nil
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                config.lastHealth = humanoid.Health
            end
            
            startAutoMine()
            
            print("â›ï¸ Resuming mining...")
            return
        end
        
        if not config.weaponEquipped then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:UnequipTools()
                task.wait(0.2)
            end
            
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                local weapon = backpack:FindFirstChild("Weapon")
                if weapon and weapon:IsA("Tool") then
                    humanoid:EquipTool(weapon)
                    task.wait(0.3)
                    config.weaponEquipped = true
                    print("âš”ï¸ WEAPON EQUIPPED!")
                end
            end
            return
        end
        
        local lockPos = funcs.getLockPosition(config.defendingAgainstMob)
        if lockPos then
            local distance = (rootPart.Position - lockPos).Magnitude
            
            funcs.hoverToMob(lockPos, config.defendingAgainstMob)
            
            if distance < 3 then
                config.isLockedOn = true
                
                local currentTime = tick()
                if currentTime - config.lastDefenseAttackTime >= config.defenseAttackCooldown then
                    config.lastDefenseAttackTime = currentTime
                    clickMouseForDefense()
                end
            end
        end
        
        return
    end
    
    -- NORMAL MINING
    if config.hoverSequenceActive then
        if config.currentHoverTarget == 1 then
            if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
                config.currentHoverTarget = 2
            end
        elseif config.currentHoverTarget == 2 then
            if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
                config.currentHoverTarget = 3
                config.hoverSequenceActive = false
            end
        end
        return
    end
    
    if config.currentRock and (not config.currentRock.Parent or not funcs.isValidRock(config.currentRock)) then
        print("ğŸª¨ Rock destroyed, finding new rock...")
        config.currentRock = nil
        config.lastRockDurability = nil
        return
    end
    
    if not config.currentRock then
        config.currentRock = funcs.getClosestRock()
        
        if config.currentRock then
            config.lastRockDurability = funcs.getRockDurability(config.currentRock)
            config.rockDurabilityCheck = tick()
            funcs.makeRockTransparent(config.currentRock)
            print("ğŸ¯ Locked onto rock: " .. config.currentRock.Parent.Name .. " (Durability: " .. tostring(config.lastRockDurability) .. ")")
        end
        return
    end
    
    if config.currentRock then
        local rockPos = funcs.getMiningPosition(config.currentRock)
        if rockPos then
            funcs.hoverToRock(rockPos, config.currentRock)
        end
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CHARACTER RESPAWN HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LocalPlayer.CharacterAdded:Connect(function(character)
    config.currentMob = nil
    config.currentRock = nil
    config.isLockedOn = false
    config.isRespawning = true
    config.hoverSequenceActive = false
    config.defendingAgainstMob = nil
    config.savedMiningRock = nil
    config.weaponEquipped = false
    config.lastHealth = nil
    config.inLavaCooldown = false
    funcs.cleanupPhysicsMovement()
    funcs.stopNoclip()
    
    local wasFarming = config.enabled
    local wasMining = config.miningEnabled
    
    if wasFarming or wasMining then
        character:WaitForChild("HumanoidRootPart", 10)
        task.wait(3)
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
            config.hoverSequenceActive = true
            config.currentHoverTarget = 1
            
            funcs.setupPhysicsMovement()
            funcs.startNoclip()
            
            if wasFarming then 
                funcs.autoEquipWeapon()
            end
            if wasMining then 
                funcs.autoEquipPickaxe()
                config.ignoredRocks = {}
                config.lastRockDurability = nil
                config.rockDurabilityCheck = tick()
                
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    config.lastHealth = humanoid.Health
                end
            end
        end
        
        config.isRespawning = false
    else
        config.isRespawning = false
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-INITIALIZATION FOR AUTOSELL
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
    task.wait(0)
    print("ğŸ”„ Talking to seller...")
    funcs.talkToSeller()
    print("âœ… Ready to auto-sell!")
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FINISH
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("âœ… Part 7 Loaded: INSTANT Rock Switch + Defense + Lava Protection")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("ğŸ‰ RAFSO'S COMPLETE HUB LOADED SUCCESSFULLY!")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("âš”ï¸  Press F1 to toggle Mob Farming")
print("â›ï¸  Press F2 to toggle Mining (with auto-defense)")
print("ğŸ’° Enable AutoSell in the AutoSell tab")
print("âš™ï¸  Configure settings in the Settings tab")
print("ğŸ›¡ï¸  Mining Defense: Auto-kills mobs within 10 studs")
print("ğŸ”¥ Lava Protection: Teleports 6 studs up when taking damage")
print("âš¡ INSTANT Rock Switch: 4 detection methods for instant response")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
