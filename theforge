--[[
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    MOB FARM v4.4 - MULTI-METHOD ATTACK SYSTEM
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    CHANGES:
    â€¢ Tries multiple attack methods in sequence:
      1. Tool:Activate()
      2. Remote events (Punch, Attack, Hit, etc.)
      3. VirtualInputManager mouse clicks
    â€¢ Automatic weapon remote detection
    â€¢ Works when alt-tabbed
    â€¢ Priority-based mob targeting
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

-- Global Config
_G.MobFarmConfig = {
    -- Settings
    enabled = false,
    behindDistance = 8,
    verticalDistance = 8,
    farmDistance = 1000,
    hoverSpeed = 80,
    acceleration = 40,
    lockPosition = "Back",
    unlockInterval = 0.3,
    lastUnlockTime = 0,
    aboveAngle = 90,
    belowAngle = 220,
    
    -- Attack settings
    attackMethod = "auto", -- Always use auto mode
    weaponRemote = nil,
    lastAttackTime = 0,
    attackCooldown = 0.25, -- Fixed at 0.25 seconds
    
    -- State
    currentMob = nil,
    isLockedOn = false,
    bodyVelocity = nil,
    bodyGyro = nil,
    noclipLoop = nil,
    
    -- Mob types (PRIORITY ORDER - Top = Highest Priority)
    mobTypes = {
        {name = "Reaper", pattern = "^Reaper%d+$", enabled = false, priority = 1},
        {name = "Blazing Slime", pattern = "^Blazing Slime%d+$", enabled = false, priority = 2},
        {name = "Elite Deathaxe Skeleton", pattern = "^Elite Deathaxe Skeleton%d+$", enabled = false, priority = 3},
        {name = "Elite Rogue Skeleton", pattern = "^Elite Rogue Skeleton%d+$", enabled = false, priority = 4},
        {name = "Deathaxe Skeleton", pattern = "^Deathaxe Skeleton%d+$", enabled = false, priority = 5},
        {name = "Axe Skeleton", pattern = "^Axe Skeleton%d+$", enabled = false, priority = 6},
        {name = "Skeleton Rogue", pattern = "^Skeleton Rogue%d+$", enabled = false, priority = 7},
        {name = "Bomber", pattern = "^Bomber%d+$", enabled = false, priority = 8},
        {name = "Slime", pattern = "^Slime%d+$", enabled = false, priority = 9},
    }
}

local config = _G.MobFarmConfig

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startNoclip()
    if config.noclipLoop then return end
    
    config.noclipLoop = RunService.Stepped:Connect(function()
        if not config.enabled then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    
    print("âœ… Noclip enabled")
end

local function stopNoclip()
    if config.noclipLoop then
        config.noclipLoop:Disconnect()
        config.noclipLoop = nil
        
        local character = LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
        
        print("ğŸ”’ Noclip disabled")
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOB DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidMob(mob)
    local humanoid = mob:FindFirstChildOfClass("Humanoid")
    local rootPart = mob:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then
        return false
    end
    
    if humanoid.Health <= 0 then
        return false
    end
    
    if Players:GetPlayerFromCharacter(mob) then
        return false
    end
    
    return true
end

local function matchesMobPattern(mobName, pattern)
    return string.match(mobName, pattern) ~= nil
end

local function getMobPriority(mob)
    for _, mobData in ipairs(config.mobTypes) do
        if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
            return mobData.priority
        end
    end
    return 999
end

local function getClosestMob()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local closestMob = nil
    local closestDistance = config.farmDistance
    local highestPriority = 999
    
    for _, child in pairs(Living:GetChildren()) do
        if isValidMob(child) then
            for _, mobData in pairs(config.mobTypes) do
                if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
                    local mobRoot = child:FindFirstChild("HumanoidRootPart")
                    if mobRoot then
                        local distance = (rootPart.Position - mobRoot.Position).Magnitude
                        local priority = getMobPriority(child)
                        
                        if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
                            closestMob = child
                            closestDistance = distance
                            highestPriority = priority
                        end
                    end
                    break
                end
            end
        end
    end
    
    return closestMob
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WEAPON & ATTACK SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function autoEquipWeapon()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    -- Check if weapon is already equipped in character
    local weaponInChar = character:FindFirstChild("Weapon")
    if weaponInChar and weaponInChar:IsA("Tool") then
        print("âœ… Weapon already equipped")
        return true
    end
    
    -- Check backpack for weapon
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local weapon = backpack:FindFirstChild("Weapon")
        if weapon and weapon:IsA("Tool") then
            humanoid:EquipTool(weapon)
            print("âš”ï¸ Auto-equipped Weapon from backpack")
            task.wait(0.2)
            return true
        end
    end
    
    print("âš ï¸ No weapon found in character or backpack")
    return false
end

local function findWeaponRemote()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local weapon = character:FindFirstChild("Weapon")
    if not weapon then return nil end
    
    -- Common remote names for attacks
    local remoteNames = {"Punch", "Attack", "Hit", "Strike", "Combat", "Swing", "Fire", "Activate", "Action", "Use"}
    
    for _, remoteName in pairs(remoteNames) do
        local remote = weapon:FindFirstChild(remoteName, true)
        if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
            return remote
        end
    end
    
    -- Search all descendants for any RemoteEvent
    for _, desc in pairs(weapon:GetDescendants()) do
        if desc:IsA("RemoteEvent") or desc:IsA("RemoteFunction") then
            return desc
        end
    end
    
    return nil
end

local function attackWithTool()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local weapon = character:FindFirstChild("Weapon")
    if weapon and weapon:IsA("Tool") then
        weapon:Activate()
        return true
    end
    return false
end

local function attackWithRemote()
    if not config.weaponRemote then
        config.weaponRemote = findWeaponRemote()
    end
    
    if config.weaponRemote then
        local success = pcall(function()
            if config.weaponRemote:IsA("RemoteEvent") then
                config.weaponRemote:FireServer()
            elseif config.weaponRemote:IsA("RemoteFunction") then
                config.weaponRemote:InvokeServer()
            end
        end)
        return success
    end
    return false
end

local function attackWithVirtualInput()
    local success = pcall(function()
        -- Send mouse button down
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        -- Small delay
        task.wait(0.01)
        -- Send mouse button up
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    end)
    return success
end

local function performAttack()
    if not config.isLockedOn or not config.currentMob then
        return
    end
    
    local currentTime = tick()
    if currentTime - config.lastAttackTime < config.attackCooldown then
        return
    end
    
    config.lastAttackTime = currentTime
    
    -- Always use auto mode (tries VirtualInput primarily)
    attackWithVirtualInput()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- POSITION & MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getLockPosition(mob)
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    if not mobRoot then return nil end
    
    local distance = config.behindDistance
    local verticalDist = config.verticalDistance
    local mobPos = mobRoot.Position
    local targetPos
    
    if config.lockPosition == "Back" then
        local behindOffset = -mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + behindOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
        
    elseif config.lockPosition == "Front" then
        local frontOffset = mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + frontOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
        
    elseif config.lockPosition == "Above" then
        targetPos = mobPos + Vector3.new(0, verticalDist, 0)
        
    elseif config.lockPosition == "Below" then
        targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
        if targetPos.Y < mobPos.Y - 20 then
            targetPos = Vector3.new(targetPos.X, mobPos.Y - 20, targetPos.Z)
        end
    else
        local behindOffset = -mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + behindOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    end
    
    return targetPos
end

local function setupPhysicsMovement()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    if config.bodyVelocity then
        config.bodyVelocity:Destroy()
    end
    if config.bodyGyro then
        config.bodyGyro:Destroy()
    end
    
    local bv = Instance.new("BodyVelocity")
    bv.Name = "FarmVelocity"
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = rootPart
    config.bodyVelocity = bv
    
    local bg = Instance.new("BodyGyro")
    bg.Name = "FarmGyro"
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.P = 10000
    bg.D = 500
    bg.Parent = rootPart
    config.bodyGyro = bg
    
    rootPart.Anchored = false
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
    end
    
    return true
end

local function hoverToPosition(targetPos, mob)
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
        return
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    if distance < 3 then
        config.isLockedOn = true
    else
        config.isLockedOn = false
    end
    
    if (config.lockPosition == "Above" or config.lockPosition == "Below") and distance < 3 then
        config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        config.bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        
        if config.lockPosition == "Above" then
            local angle = math.rad(config.aboveAngle)
            local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
            config.bodyGyro.CFrame = downCFrame
            config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
            config.bodyGyro.P = 50000
        else
            local angle = math.rad(config.belowAngle)
            local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
            config.bodyGyro.CFrame = upCFrame
            config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
            config.bodyGyro.P = 50000
        end
        
        return
    end
    
    local bobbing = 0
    if config.lockPosition ~= "Above" and config.lockPosition ~= "Below" then
        bobbing = math.sin(tick() * 2) * 0.3
    end
    
    local bobbedTarget = targetPos + Vector3.new(0, bobbing, 0)
    direction = (bobbedTarget - currentPos)
    
    local speedMultiplier = math.min(distance / 10, 1)
    local targetSpeed = config.hoverSpeed * speedMultiplier
    
    local desiredVelocity
    if direction.Magnitude > 0 then
        desiredVelocity = direction.Unit * math.min(distance * config.acceleration, targetSpeed)
    else
        desiredVelocity = Vector3.new(0, 0, 0)
    end
    
    local currentVelocity = config.bodyVelocity.Velocity
    local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
    
    config.bodyVelocity.Velocity = newVelocity
    
    local lookAtPos = mobRoot.Position
    local lookCFrame = CFrame.new(currentPos, lookAtPos)
    config.bodyGyro.CFrame = lookCFrame
    config.bodyGyro.P = 10000
end

local function cleanupPhysicsMovement()
    if config.bodyVelocity then
        config.bodyVelocity:Destroy()
        config.bodyVelocity = nil
    end
    if config.bodyGyro then
        config.bodyGyro:Destroy()
        config.bodyGyro = nil
    end
    
    local character = LocalPlayer.Character
    if character then
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.Anchored = false
            rootPart.Velocity = Vector3.new(0, 0, 0)
        end
    end
    
    config.isLockedOn = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-ATTACK LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local attackLoop = nil

local function startAutoAttack()
    if attackLoop then return end
    
    task.spawn(function()
        task.wait(0.5)
        autoEquipWeapon()
    end)
    
    attackLoop = RunService.Heartbeat:Connect(function()
        if not config.enabled then return end
        performAttack()
    end)
    
    print("ğŸ–±ï¸ Auto-attack started (Multi-method)")
end

local function stopAutoAttack()
    if attackLoop then
        attackLoop:Disconnect()
        attackLoop = nil
        print("ğŸ–±ï¸ Auto-attack stopped")
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GUI
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "Mob Farm v4.4 - Multi-Method Attack",
    LoadingTitle = "Loading Mob Farm",
    LoadingSubtitle = "Multiple attack methods!",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "MobFarmV44",
        FileName = "Config"
    },
    Discord = {Enabled = false},
    KeySystem = false
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MainTab = Window:CreateTab("Main", 4483362458)

local farmLoop = nil
local keybindConnection = nil
local characterConnection = nil

local EnableToggle = MainTab:CreateToggle({
    Name = "ğŸ¤– Enable Farm (F1)",
    CurrentValue = false,
    Flag = "EnableToggle",
    Callback = function(Value)
        config.enabled = Value
        
        if Value then
            setupPhysicsMovement()
            startNoclip()
            startAutoAttack()
            print("âœ… Farm ENABLED!")
        else
            stopAutoAttack()
            stopNoclip()
            cleanupPhysicsMovement()
            config.currentMob = nil
            print("âŒ Farm DISABLED")
        end
    end,
})

local MobDropdown = MainTab:CreateDropdown({
    Name = "Select Mobs to Farm (Priority Order)",
    Options = {},
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "MobDropdown",
    Callback = function(Options)
        for _, mobData in ipairs(config.mobTypes) do
            mobData.enabled = false
        end
        
        for _, selectedName in pairs(Options) do
            for _, mobData in ipairs(config.mobTypes) do
                if mobData.name == selectedName then
                    mobData.enabled = true
                    break
                end
            end
        end
        
        print("ğŸ“‹ Enabled mobs:", table.concat(Options, ", "))
    end,
})

local mobNames = {}
for _, mobData in ipairs(config.mobTypes) do
    table.insert(mobNames, mobData.name)
end
MobDropdown:Refresh(mobNames, mobNames)

MainTab:CreateButton({
    Name = "ğŸ—‘ï¸ Destroy GUI",
    Callback = function()
        config.enabled = false
        stopAutoAttack()
        stopNoclip()
        cleanupPhysicsMovement()
        
        if farmLoop then farmLoop:Disconnect() end
        if keybindConnection then keybindConnection:Disconnect() end
        if characterConnection then characterConnection:Disconnect() end
        
        _G.MobFarmConfig = nil
        Rayfield:Destroy()
        print("âœ… GUI Destroyed!")
    end,
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SettingsTab = Window:CreateTab("Settings", 4483362458)

SettingsTab:CreateDropdown({
    Name = "Lock Position",
    Options = {"Back", "Front", "Above", "Below"},
    CurrentOption = "Back",
    Flag = "LockPosition",
    Callback = function(Option)
        if type(Option) == "table" then
            config.lockPosition = Option[1] or "Back"
        else
            config.lockPosition = Option
        end
    end,
})

SettingsTab:CreateSlider({
    Name = "Hover Speed",
    Range = {20, 150},
    Increment = 10,
    CurrentValue = 80,
    Flag = "HoverSpeed",
    Callback = function(Value) 
        config.hoverSpeed = Value 
    end,
})

SettingsTab:CreateSlider({
    Name = "Acceleration",
    Range = {10, 80},
    Increment = 5,
    CurrentValue = 40,
    Flag = "Acceleration",
    Callback = function(Value) 
        config.acceleration = Value 
    end,
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN FARM LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

farmLoop = RunService.Heartbeat:Connect(function()
    if not config.enabled then return end
    
    if not config.bodyVelocity or not config.bodyGyro then
        setupPhysicsMovement()
        return
    end
    
    local needNewMob = false
    
    if not config.currentMob or not config.currentMob.Parent then
        needNewMob = true
    else
        local humanoid = config.currentMob:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            needNewMob = true
        end
    end
    
    if needNewMob then
        local newMob = getClosestMob()
        
        if newMob then
            print("ğŸ¯ New target:", newMob.Name)
            config.currentMob = newMob
            config.weaponRemote = nil -- Reset remote for new mob
            
            if not config.bodyVelocity or not config.bodyGyro then
                setupPhysicsMovement()
            end
        else
            config.currentMob = nil
            config.isLockedOn = false
        end
        
        return
    end
    
    if config.currentMob then
        local lockPos = getLockPosition(config.currentMob)
        if lockPos then
            hoverToPosition(lockPos, config.currentMob)
        end
    end
end)

-- F1 Keybind
keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.F1 then
        config.enabled = not config.enabled
        EnableToggle:Set(config.enabled)
    end
end)

-- Cleanup on character respawn
characterConnection = LocalPlayer.CharacterAdded:Connect(function()
    config.currentMob = nil
    config.isLockedOn = false
    config.weaponRemote = nil
    cleanupPhysicsMovement()
    stopNoclip()
    
    if config.enabled then
        task.wait(2)
        setupPhysicsMovement()
        startNoclip()
        autoEquipWeapon()
        print("âš”ï¸ Re-equipped after respawn")
    end
end)

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("MOB FARM v4.4 - SIMPLIFIED AUTO ATTACK!")
print("âœ… VirtualInputManager clicks (works alt-tabbed)")
print("âœ… Attack cooldown: 0.25 seconds")
print("âœ… Vertical distance: 8 studs (fixed)")
print("âœ… Auto-equips weapon")
print("â€¢ Press F1 to start!")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
