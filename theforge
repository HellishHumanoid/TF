-- ═══════════════════════════════════════════════════════════════════════════
-- RAYFIELD FARM & MINE SCRIPT - PART 1: CORE SETUP & CONFIG
-- ═══════════════════════════════════════════════════════════════════════════

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

-- ═══════════════════════════════════════════════════════════════════════════
-- HOVER POSITIONS
-- ═══════════════════════════════════════════════════════════════════════════
local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- ═══════════════════════════════════════════════════════════════════════════
-- GLOBAL CONFIG
-- ═══════════════════════════════════════════════════════════════════════════
_G.MobFarmConfig = {
    -- Farming settings
    enabled = false,
    behindDistance = 8,
    verticalDistance = 8,
    farmDistance = 1000,
    hoverSpeed = 80,
    lockPosition = "Below",
    aboveAngle = 90,
    belowAngle = 240,
    
    -- Hover sequence
    hoverSequenceActive = false,
    currentHoverTarget = 1,
    hoverReachedThreshold = 3,
    hoverPosition1 = nil,
    
    -- Attack settings
    weaponRemote = nil,
    lastAttackTime = 0,
    attackCooldown = 0.25,
    lastWeaponCheckTime = 0,
    weaponCheckInterval = 0.5,
    
    -- State
    currentMob = nil,
    isLockedOn = false,
    bodyVelocity = nil,
    bodyGyro = nil,
    noclipLoop = nil,
    isRespawning = false,
    
    -- Mob types
    mobTypes = {
        {name = "Reaper", pattern = "^Reaper%d+$", enabled = false, priority = 1},
        {name = "Blazing Slime", pattern = "^Blazing Slime%d+$", enabled = false, priority = 2},
        {name = "Elite Deathaxe Skeleton", pattern = "^Elite Deathaxe Skeleton%d+$", enabled = false, priority = 3},
        {name = "Elite Rogue Skeleton", pattern = "^Elite Rogue Skeleton%d+$", enabled = false, priority = 4},
        {name = "Deathaxe Skeleton", pattern = "^Deathaxe Skeleton%d+$", enabled = false, priority = 5},
        {name = "Axe Skeleton", pattern = "^Axe Skeleton%d+$", enabled = false, priority = 6},
        {name = "Skeleton Rogue", pattern = "^Skeleton Rogue%d+$", enabled = false, priority = 7},
        {name = "Bomber", pattern = "^Bomber%d+$", enabled = false, priority = 8},
        {name = "Slime", pattern = "^Slime%d+$", enabled = false, priority = 9},
    },
    
    -- Mining system
    miningEnabled = false,
    miningVerticalDistance = 6,
    miningAngle = 270,
    currentRock = nil,
    lastMineTime = 0,
    miningCooldown = 0.1,
    lastPickaxeCheckTime = 0,
    pickaxeCheckInterval = 0.5,
    miningBodyVelocity = nil,
    miningBodyGyro = nil,
    ignoreGoblinCave = true,
    
    -- ✅ NEW: Rock damage tracking
    rockDurabilityCheck = 0,
    rockDurabilityCheckInterval = 3,  -- Check every 3 seconds
    lastRockDurability = nil,
    ignoredRocks = {},  -- Table to store rocks being mined by others
    
    -- Rock types (PRIORITY ORDER)
    rockTypes = {
        {name = "Volcanic Rock", enabled = false, priority = 1},
        {name = "Earth Crystal", enabled = false, priority = 2},
        {name = "Violet Crystal", enabled = false, priority = 3},
        {name = "Crimson Crystal", enabled = false, priority = 4},
        {name = "Light Crystal", enabled = false, priority = 5},
        {name = "Cyan Crystal", enabled = false, priority = 6},
        {name = "Basalt Vein", enabled = false, priority = 7},
        {name = "Basalt Core", enabled = false, priority = 8},
        {name = "Basalt Rock", enabled = false, priority = 9},
        {name = "Boulder", enabled = false, priority = 10},
        {name = "Rock", enabled = false, priority = 11},
        {name = "Pebble", enabled = false, priority = 12},
    }
}

local config = _G.MobFarmConfig

-- ═══════════════════════════════════════════════════════════════════════════
-- PART 2: NOCLIP & MOB/ROCK DETECTION (WITH TRANSPARENCY + IGNORE GOBLIN CAVE + DAMAGE CHECK)
-- ═══════════════════════════════════════════════════════════════════════════

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")
local config = _G.MobFarmConfig

-- ═══════════════════════════════════════════════════════════════════════════
-- NOCLIP SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════

local function startNoclip()
    if config.noclipLoop then return end
    
    config.noclipLoop = RunService.Stepped:Connect(function()
        if not config.enabled and not config.miningEnabled then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

local function stopNoclip()
    if config.noclipLoop then
        config.noclipLoop:Disconnect()
        config.noclipLoop = nil
        
        local character = LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- ═══════════════════════════════════════════════════════════════════════════
-- MOB DETECTION
-- ═══════════════════════════════════════════════════════════════════════════

local function isValidMob(mob)
    local humanoid = mob:FindFirstChildOfClass("Humanoid")
    local rootPart = mob:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then return false end
    if humanoid.Health <= 0 then return false end
    if Players:GetPlayerFromCharacter(mob) then return false end
    
    return true
end

local function matchesMobPattern(mobName, pattern)
    return string.match(mobName, pattern) ~= nil
end

local function getMobPriority(mob)
    for _, mobData in ipairs(config.mobTypes) do
        if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
            return mobData.priority
        end
    end
    return 999
end

local function getClosestMob()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local closestMob = nil
    local closestDistance = config.farmDistance
    local highestPriority = 999
    
    for _, child in pairs(Living:GetChildren()) do
        if isValidMob(child) then
            for _, mobData in pairs(config.mobTypes) do
                if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
                    local mobRoot = child:FindFirstChild("HumanoidRootPart")
                    if mobRoot then
                        local distance = (rootPart.Position - mobRoot.Position).Magnitude
                        local priority = getMobPriority(child)
                        
                        if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
                            closestMob = child
                            closestDistance = distance
                            highestPriority = priority
                        end
                    end
                    break
                end
            end
        end
    end
    
    return closestMob
end

-- ═══════════════════════════════════════════════════════════════════════════
-- ROCK DETECTION (FOR MINING) - WITH IGNORED ROCKS CHECK
-- ═══════════════════════════════════════════════════════════════════════════

local function isValidRock(durabilityModel)
    if not durabilityModel:IsA("Model") then return false end
    if not durabilityModel.Parent then return false end
    
    -- Check if this durability model has ANY MeshPart (Rock, 3.001, 13.001, etc)
    local hasMeshPart = durabilityModel:FindFirstChildOfClass("MeshPart") ~= nil
    
    return hasMeshPart
end

-- ✅ NEW: Check if rock is in ignored list
local function isRockIgnored(rock)
    for _, ignoredRock in ipairs(config.ignoredRocks) do
        if ignoredRock == rock then
            return true
        end
    end
    return false
end

local function getRockPriority(rockTypeName)
    for _, rockData in ipairs(config.rockTypes) do
        if rockData.enabled and rockTypeName == rockData.name then
            return rockData.priority
        end
    end
    return 999
end

local function getRockPosition(durabilityModel)
    -- Try to find a part named "Rock" first (for Volcanic Rock)
    local rockPart = durabilityModel:FindFirstChild("Rock")
    if rockPart and rockPart:IsA("BasePart") then
        return rockPart
    end
    
    -- Otherwise, use the Hitbox from the parent rock type model
    local rockTypeModel = durabilityModel.Parent
    if rockTypeModel then
        local hitbox = rockTypeModel:FindFirstChild("Hitbox")
        if hitbox and hitbox:IsA("BasePart") then
            return hitbox
        end
    end
    
    -- Fallback: use any MeshPart in the durability model
    local meshPart = durabilityModel:FindFirstChildOfClass("MeshPart")
    if meshPart then
        return meshPart
    end
    
    return nil
end

-- ✅ NEW: Get rock durability (the model name is the durability number)
local function getRockDurability(rock)
    if not rock then return nil end
    return tonumber(rock.Name)
end

local function getClosestRock()
    local character = LocalPlayer.Character
    if not character then 
        return nil 
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then 
        return nil 
    end
    
    local rocksFolder = workspace:FindFirstChild("Rocks")
    if not rocksFolder then
        return nil
    end
    
    local closestRock = nil
    local closestDistance = config.farmDistance
    local highestPriority = 999
    
    -- Loop through all island folders
    for _, islandFolder in pairs(rocksFolder:GetChildren()) do
        if islandFolder:IsA("Folder") then
            -- ✅ Skip Goblin Cave if toggle is enabled
            if config.ignoreGoblinCave and islandFolder.Name == "Island2GoblinCave" then
                continue
            end
            
            -- Loop through all SpawnLocation parts
            for _, spawnPart in pairs(islandFolder:GetChildren()) do
                if spawnPart:IsA("Part") and spawnPart.Name == "SpawnLocation" then
                    -- Check if this SpawnLocation has spawned rock models as children
                    for _, rockTypeModel in pairs(spawnPart:GetChildren()) do
                        if rockTypeModel:IsA("Model") then
                            local rockTypeName = rockTypeModel.Name
                            local priority = getRockPriority(rockTypeName)
                            
                            if priority < 999 then -- Rock type is enabled
                                -- Look for durability models inside (100, 80, 60, etc)
                                for _, durabilityModel in pairs(rockTypeModel:GetChildren()) do
                                    if durabilityModel:IsA("Model") and tonumber(durabilityModel.Name) then
                                        -- ✅ NEW: Skip ignored rocks
                                        if not isRockIgnored(durabilityModel) and isValidRock(durabilityModel) then
                                            local positionPart = getRockPosition(durabilityModel)
                                            if positionPart then
                                                local distance = (rootPart.Position - positionPart.Position).Magnitude
                                                
                                                if distance <= config.farmDistance then
                                                    if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
                                                        closestRock = durabilityModel
                                                        closestDistance = distance
                                                        highestPriority = priority
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    return closestRock
end

local function makeRockTransparent(rock)
    if not rock then return end
    
    -- Make all parts in the rock transparent
    for _, descendant in pairs(rock:GetDescendants()) do
        if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
            descendant.Transparency = 0.7
        end
    end
    
    -- Also make parent rock type model transparent
    local rockTypeModel = rock.Parent
    if rockTypeModel then
        for _, descendant in pairs(rockTypeModel:GetDescendants()) do
            if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
                descendant.Transparency = 0.7
            end
        end
    end
end

-- Store functions globally
_G.FarmFunctions = {
    startNoclip = startNoclip,
    stopNoclip = stopNoclip,
    getClosestMob = getClosestMob,
    getClosestRock = getClosestRock,
    isValidMob = isValidMob,
    isValidRock = isValidRock,
    getRockPosition = getRockPosition,
    getRockDurability = getRockDurability,  -- ✅ NEW
    isRockIgnored = isRockIgnored,  -- ✅ NEW
    makeRockTransparent = makeRockTransparent,
}

-- ═══════════════════════════════════════════════════════════════════════════
-- PART 3: WEAPON SYSTEM & PHYSICS MOVEMENT (FIXED - MINING ATTACK SYSTEM)
-- ═══════════════════════════════════════════════════════════════════════════

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig

-- ═══════════════════════════════════════════════════════════════════════════
-- WEAPON & TOOL SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════

local function autoEquipWeapon()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    local weaponInChar = character:FindFirstChild("Weapon")
    if weaponInChar and weaponInChar:IsA("Tool") then
        return true
    end
    
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local weapon = backpack:FindFirstChild("Weapon")
        if weapon and weapon:IsA("Tool") then
            humanoid:EquipTool(weapon)
            task.wait(0.2)
            return true
        end
    end
    
    return false
end

local function autoEquipPickaxe()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    -- ✅ Check if pickaxe is already equipped
    local pickaxeInChar = character:FindFirstChild("Pickaxe")
    if pickaxeInChar and pickaxeInChar:IsA("Tool") then
        return true
    end
    
    -- ✅ Try to equip from backpack
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local pickaxe = backpack:FindFirstChild("Pickaxe")
        if pickaxe and pickaxe:IsA("Tool") then
            humanoid:EquipTool(pickaxe)
            task.wait(0.2)
            return true
        end
    end
    
    return false
end

local function clickMouse()
    local success = pcall(function()
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        task.wait(0.01)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    end)
    return success
end

local function performAttack()
    if not config.isLockedOn or not config.currentMob or config.hoverSequenceActive then
        return
    end
    
    local currentTime = tick()
    if currentTime - config.lastAttackTime < config.attackCooldown then
        return
    end
    
    config.lastAttackTime = currentTime
    clickMouse()
end

-- ✅ NEW: Mining function that works like farming (no distance check, just mine when locked)
local function performMine()
    if not config.currentRock then return end
    if not config.miningEnabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    -- ✅ Make sure pickaxe is equipped before mining
    local pickaxe = character:FindFirstChild("Pickaxe")
    if not pickaxe then
        autoEquipPickaxe()
        return
    end
    
    local currentTime = tick()
    if currentTime - config.lastMineTime < config.miningCooldown then
        return
    end
    
    config.lastMineTime = currentTime
    clickMouse()
end

-- ═══════════════════════════════════════════════════════════════════════════
-- PHYSICS MOVEMENT
-- ═══════════════════════════════════════════════════════════════════════════

local function setupPhysicsMovement()
    local character = LocalPlayer.Character
    if not character then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    if config.bodyVelocity then
        config.bodyVelocity:Destroy()
    end
    if config.bodyGyro then
        config.bodyGyro:Destroy()
    end
    
    local bv = Instance.new("BodyVelocity")
    bv.Name = "FarmVelocity"
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.P = 1250
    bv.Parent = rootPart
    config.bodyVelocity = bv
    
    local bg = Instance.new("BodyGyro")
    bg.Name = "FarmGyro"
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.P = 30000
    bg.D = 1000
    bg.Parent = rootPart
    config.bodyGyro = bg
    
    rootPart.Anchored = false
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end
    
    return true
end

local function cleanupPhysicsMovement()
    if config.bodyVelocity then
        config.bodyVelocity:Destroy()
        config.bodyVelocity = nil
    end
    if config.bodyGyro then
        config.bodyGyro:Destroy()
        config.bodyGyro = nil
    end
    
    local character = LocalPlayer.Character
    if character then
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.Anchored = false
            rootPart.Velocity = Vector3.new(0, 0, 0)
        end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            task.wait(0.1)
            humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
        end
    end
    
    config.isLockedOn = false
end

-- Store functions globally
_G.FarmFunctions.autoEquipWeapon = autoEquipWeapon
_G.FarmFunctions.autoEquipPickaxe = autoEquipPickaxe
_G.FarmFunctions.performAttack = performAttack
_G.FarmFunctions.performMine = performMine
_G.FarmFunctions.setupPhysicsMovement = setupPhysicsMovement
_G.FarmFunctions.cleanupPhysicsMovement = cleanupPhysicsMovement

-- ═══════════════════════════════════════════════════════════════════════════
-- PART 4: MOVEMENT LOGIC & HOVERING (WITH CONFIGURABLE MINING ANGLE)
-- ═══════════════════════════════════════════════════════════════════════════

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- ═══════════════════════════════════════════════════════════════════════════
-- POSITION CALCULATION
-- ═══════════════════════════════════════════════════════════════════════════

local function getLockPosition(mob)
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    if not mobRoot then return nil end
    
    local distance = config.behindDistance
    local verticalDist = config.verticalDistance
    local mobPos = mobRoot.Position
    local targetPos
    
    if config.lockPosition == "Back" then
        local behindOffset = -mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + behindOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    elseif config.lockPosition == "Front" then
        local frontOffset = mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + frontOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    elseif config.lockPosition == "Above" then
        targetPos = mobPos + Vector3.new(0, verticalDist, 0)
    elseif config.lockPosition == "Below" then
        targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
    else
        local behindOffset = -mobRoot.CFrame.LookVector * distance
        targetPos = mobPos + behindOffset
        targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
    end
    
    return targetPos
end

local function getMiningPosition(rock)
    if not rock then return nil end
    
    local positionPart = _G.FarmFunctions.getRockPosition(rock)
    if not positionPart then 
        return nil 
    end
    
    local rockPos = positionPart.Position
    local targetPos = rockPos + Vector3.new(0, -config.miningVerticalDistance, 0)
    
    return targetPos
end

-- ═══════════════════════════════════════════════════════════════════════════
-- HOVER MOVEMENT
-- ═══════════════════════════════════════════════════════════════════════════

local function hoverToPosition(targetPos, lookAtPos)
    local character = LocalPlayer.Character
    if not character then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not config.bodyVelocity or not config.bodyGyro then
        return false
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    if distance < config.hoverReachedThreshold then
        config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        return true
    end
    
    local speedMultiplier = math.min(distance / 10, 1)
    local targetSpeed = config.hoverSpeed * speedMultiplier
    
    local desiredVelocity = direction.Unit * targetSpeed
    local currentVelocity = config.bodyVelocity.Velocity
    local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
    
    config.bodyVelocity.Velocity = newVelocity
    
    if lookAtPos then
        local lookCFrame = CFrame.new(currentPos, lookAtPos)
        config.bodyGyro.CFrame = lookCFrame
    end
    
    return false
end

local function hoverToMob(targetPos, mob)
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
        return
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    config.isLockedOn = distance < 3
    
    if (config.lockPosition == "Above" or config.lockPosition == "Below") and distance < 3 then
        config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        
        if config.lockPosition == "Above" then
            local angle = math.rad(config.aboveAngle)
            local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
            config.bodyGyro.CFrame = downCFrame
        else
            local angle = math.rad(config.belowAngle)
            local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
            config.bodyGyro.CFrame = upCFrame
        end
        return
    end
    
    local speedMultiplier = math.min(distance / 10, 1)
    local targetSpeed = config.hoverSpeed * speedMultiplier
    local desiredVelocity = direction.Unit * targetSpeed
    local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.3)
    
    config.bodyVelocity.Velocity = newVelocity
    
    local lookCFrame = CFrame.new(currentPos, mobRoot.Position)
    config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.3)
end

local function hoverToRock(targetPos, rock)
    if not targetPos then 
        return 
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not rootPart or not config.bodyVelocity or not config.bodyGyro then
        return
    end
    
    local currentPos = rootPart.Position
    local direction = (targetPos - currentPos)
    local distance = direction.Magnitude
    
    if distance < 3 then
        config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        
        -- ✅ USE CONFIGURABLE MINING ANGLE (0-360 degrees)
        local angle = math.rad(config.miningAngle)
        local lookCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
        config.bodyGyro.CFrame = lookCFrame
        config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        config.bodyGyro.P = 50000
        return
    end
    
    local speedMultiplier = math.min(distance / 10, 1)
    local targetSpeed = config.hoverSpeed * speedMultiplier
    local desiredVelocity = direction.Unit * targetSpeed
    local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.5)
    
    config.bodyVelocity.Velocity = newVelocity
    
    -- Get position part for looking at rock while moving
    local positionPart = _G.FarmFunctions.getRockPosition(rock)
    if positionPart then
        local lookCFrame = CFrame.new(currentPos, positionPart.Position)
        config.bodyGyro.CFrame = lookCFrame
        config.bodyGyro.P = 10000
    end
end

-- Store functions globally
_G.FarmFunctions.getLockPosition = getLockPosition
_G.FarmFunctions.getMiningPosition = getMiningPosition
_G.FarmFunctions.hoverToPosition = hoverToPosition
_G.FarmFunctions.hoverToMob = hoverToMob
_G.FarmFunctions.hoverToRock = hoverToRock

-- ═══════════════════════════════════════════════════════════════════════════
-- PART 5: RAYFIELD GUI & MAIN LOOPS (FIXED RESPAWN & TOGGLE)
-- ═══════════════════════════════════════════════════════════════════════════

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- ═══════════════════════════════════════════════════════════════════════════
-- LOAD RAYFIELD
-- ═══════════════════════════════════════════════════════════════════════════

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Rafso's Autofarm",
   LoadingTitle = "Loading",
   LoadingSubtitle = "by Rafso",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "FarmScript",
      FileName = "FarmConfig"
   },
   KeySystem = false,
})

-- ═══════════════════════════════════════════════════════════════════════════
-- AUTO-LOOPS
-- ═══════════════════════════════════════════════════════════════════════════

local attackLoop = nil
local mineLoop = nil
local weaponCheckLoop = nil
local pickaxeCheckLoop = nil

local function startAutoAttack()
    if attackLoop then return end
    
    task.spawn(function()
        task.wait(0.5)
        funcs.autoEquipWeapon()
    end)
    
    attackLoop = RunService.Heartbeat:Connect(function()
        if not config.enabled then return end
        funcs.performAttack()
    end)
    
    if not weaponCheckLoop then
        weaponCheckLoop = RunService.Heartbeat:Connect(function()
            if not config.enabled then return end
            local currentTime = tick()
            if currentTime - config.lastWeaponCheckTime >= config.weaponCheckInterval then
                config.lastWeaponCheckTime = currentTime
                funcs.autoEquipWeapon()
            end
        end)
    end
end

local function stopAutoAttack()
    if attackLoop then
        attackLoop:Disconnect()
        attackLoop = nil
    end
    if weaponCheckLoop then
        weaponCheckLoop:Disconnect()
        weaponCheckLoop = nil
    end
end

local function startAutoMine()
    if mineLoop then return end
    
    task.spawn(function()
        task.wait(0.3)
        funcs.autoEquipPickaxe()
    end)
    
    mineLoop = RunService.Heartbeat:Connect(function()
        if not config.miningEnabled then return end
        funcs.performMine()
    end)
    
    if not pickaxeCheckLoop then
        pickaxeCheckLoop = RunService.Heartbeat:Connect(function()
            if not config.miningEnabled then return end
            local currentTime = tick()
            if currentTime - config.lastPickaxeCheckTime >= config.pickaxeCheckInterval then
                config.lastPickaxeCheckTime = currentTime
                funcs.autoEquipPickaxe()
            end
        end)
    end
end

local function stopAutoMine()
    if mineLoop then
        mineLoop:Disconnect()
        mineLoop = nil
    end
    if pickaxeCheckLoop then
        pickaxeCheckLoop:Disconnect()
        pickaxeCheckLoop = nil
    end
end

-- ═══════════════════════════════════════════════════════════════════════════
-- FARMING TAB
-- ═══════════════════════════════════════════════════════════════════════════

local FarmTab = Window:CreateTab("Farming", 4483362458)

local FarmToggle = FarmTab:CreateToggle({
   Name = "Enable Mob Farming (F1)",
   CurrentValue = false,
   Flag = "FarmToggle",
   Callback = function(Value)
      config.enabled = Value
      
      if config.enabled then
         local character = LocalPlayer.Character
         if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
               config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
               config.hoverSequenceActive = true
               config.currentHoverTarget = 1
            end
         end
         
         funcs.setupPhysicsMovement()
         funcs.startNoclip()
         startAutoAttack()
      else
         config.hoverSequenceActive = false
         config.currentMob = nil
         stopAutoAttack()
         funcs.stopNoclip()
         funcs.cleanupPhysicsMovement()
      end
   end,
})

FarmTab:CreateSection("Lock Position")

local LockPositionDropdown = FarmTab:CreateDropdown({
   Name = "Lock Position",
   Options = {"Back", "Front", "Above", "Below"},
   CurrentOption = {"Below"},
   MultipleOptions = false,
   Flag = "LockPosition",
   Callback = function(Option)
      config.lockPosition = Option[1]
   end,
})

FarmTab:CreateSection("Mob Selection")

-- Create dropdown options for mobs
local mobOptions = {}
for i, mobData in ipairs(config.mobTypes) do
   table.insert(mobOptions, mobData.name)
end

local MobDropdown = FarmTab:CreateDropdown({
   Name = "Select Mobs to Farm",
   Options = mobOptions,
   CurrentOption = {},
   MultipleOptions = true,
   Flag = "MobDropdown",
   Callback = function(Options)
      -- Disable all mobs first
      for i, mobData in ipairs(config.mobTypes) do
         config.mobTypes[i].enabled = false
      end
      
      -- Enable selected mobs
      for _, selectedMob in ipairs(Options) do
         for i, mobData in ipairs(config.mobTypes) do
            if mobData.name == selectedMob then
               config.mobTypes[i].enabled = true
               break
            end
         end
      end
   end,
})



-- ═══════════════════════════════════════════════════════════════════════════
-- MINING TAB
-- ═══════════════════════════════════════════════════════════════════════════

local MineTab = Window:CreateTab("Mining", 4483362458)

local MineToggle = MineTab:CreateToggle({
   Name = "Enable Mining (F2)",
   CurrentValue = false,
   Flag = "MineToggle",
   Callback = function(Value)
      config.miningEnabled = Value
      
      if config.miningEnabled then
         -- ✅ Reset ignored rocks list
         config.ignoredRocks = {}
         config.lastRockDurability = nil
         config.rockDurabilityCheck = tick()
         config.currentRock = nil
         
         -- ✅ Start hover sequence for mining
         local character = LocalPlayer.Character
         if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
               config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
               config.hoverSequenceActive = true
               config.currentHoverTarget = 1
            end
         end
         
         funcs.setupPhysicsMovement()
         funcs.startNoclip()
         startAutoMine()
      else
         -- ✅ CRITICAL FIX: Stop hover sequence and reset ALL state
         config.hoverSequenceActive = false
         config.currentHoverTarget = 1
         config.currentRock = nil
         config.ignoredRocks = {}
         config.lastRockDurability = nil
         config.isLockedOn = false
         
         -- ✅ Stop all systems in correct order
         stopAutoMine()
         funcs.stopNoclip()
         funcs.cleanupPhysicsMovement()
         
         -- ✅ Force stop all movement immediately
         local character = LocalPlayer.Character
         if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
               rootPart.Velocity = Vector3.new(0, 0, 0)
               rootPart.Anchored = false
            end
         end
      end
   end,
})

MineTab:CreateSection("Rock Selection")

-- Create dropdown options for rocks
local rockOptions = {}
for i, rockData in ipairs(config.rockTypes) do
   table.insert(rockOptions, rockData.name)
end

local RockDropdown = MineTab:CreateDropdown({
   Name = "Select Rocks to Mine",
   Options = rockOptions,
   CurrentOption = {},
   MultipleOptions = true,
   Flag = "RockDropdown",
   Callback = function(Options)
      -- Disable all rocks first
      for i, rockData in ipairs(config.rockTypes) do
         config.rockTypes[i].enabled = false
      end
      
      -- Enable selected rocks
      for _, selectedRock in ipairs(Options) do
         for i, rockData in ipairs(config.rockTypes) do
            if rockData.name == selectedRock then
               config.rockTypes[i].enabled = true
               break
            end
         end
      end
   end,
})

-- ═══════════════════════════════════════════════════════════════════════════
-- SETTINGS TAB
-- ═══════════════════════════════════════════════════════════════════════════

local SettingsTab = Window:CreateTab("Settings", 4483362458)

SettingsTab:CreateSection("General Settings")

SettingsTab:CreateSlider({
   Name = "Hover Speed",
   Range = {20, 150},
   Increment = 5,
   CurrentValue = 80,
   Flag = "HoverSpeed",
   Callback = function(Value)
      config.hoverSpeed = Value
   end,
})

SettingsTab:CreateSection("Farm Settings")

SettingsTab:CreateSlider({
   Name = "Vertical Distance",
   Range = {1, 20},
   Increment = 1,
   CurrentValue = 8,
   Flag = "VerticalDistance",
   Callback = function(Value)
      config.verticalDistance = Value
   end,
})

SettingsTab:CreateSection("Mining Settings")

SettingsTab:CreateSlider({
   Name = "Mining Vertical Distance",
   Range = {1, 15},
   Increment = 1,
   CurrentValue = 6,
   Flag = "MiningVerticalDistance",
   Callback = function(Value)
      config.miningVerticalDistance = Value
   end,
})

-- ✅ Goblin Cave Toggle
SettingsTab:CreateToggle({
   Name = "Ignore Goblin Cave Rocks",
   CurrentValue = true,
   Flag = "IgnoreGoblinCave",
   Callback = function(Value)
      config.ignoreGoblinCave = Value
   end,
})

SettingsTab:CreateSection("Script Control")

SettingsTab:CreateButton({
   Name = "Destroy GUI",
   Callback = function()
      -- Stop all loops
      if farmLoop then farmLoop:Disconnect() end
      if miningLoop then miningLoop:Disconnect() end
      stopAutoAttack()
      stopAutoMine()
      
      -- Disconnect keybinds
      if keybindConnection then
         keybindConnection:Disconnect()
         keybindConnection = nil
      end
      
      -- Stop noclip
      funcs.stopNoclip()
      
      -- Cleanup physics
      funcs.cleanupPhysicsMovement()
      
      -- Disable farming and mining
      config.enabled = false
      config.miningEnabled = false
      
      -- Clear globals
      _G.MobFarmConfig = nil
      _G.FarmFunctions = nil
      
      -- Destroy Rayfield
      Rayfield:Destroy()
      
   end,
})

-- ═══════════════════════════════════════════════════════════════════════════
-- KEYBIND SYSTEM (F1/F2)
-- ═══════════════════════════════════════════════════════════════════════════

local keybindConnection = nil

keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Check if script is destroyed
    if not _G.MobFarmConfig or not _G.FarmFunctions then
        return
    end
    
    if input.KeyCode == Enum.KeyCode.F1 then
        config.enabled = not config.enabled
        
        -- Update toggle in UI if it exists
        if FarmToggle then
            FarmToggle:Set(config.enabled)
        end
        
        if config.enabled then
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
                    config.hoverSequenceActive = true
                    config.currentHoverTarget = 1
                end
            end
            
            funcs.setupPhysicsMovement()
            funcs.startNoclip()
            startAutoAttack()
        else
            config.hoverSequenceActive = false
            config.currentMob = nil
            stopAutoAttack()
            funcs.stopNoclip()
            funcs.cleanupPhysicsMovement()
        end
        
    elseif input.KeyCode == Enum.KeyCode.F2 then
        config.miningEnabled = not config.miningEnabled
        
        -- Update toggle in UI if it exists
        if MineToggle then
            MineToggle:Set(config.miningEnabled)
        end
        
        if config.miningEnabled then
            -- ✅ Reset ignored rocks list
            config.ignoredRocks = {}
            config.lastRockDurability = nil
            config.rockDurabilityCheck = tick()
            config.currentRock = nil
            
            -- ✅ Start hover sequence for mining
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
                    config.hoverSequenceActive = true
                    config.currentHoverTarget = 1
                end
            end
            
            funcs.setupPhysicsMovement()
            funcs.startNoclip()
            startAutoMine()
        else
            -- ✅ CRITICAL FIX: Stop hover sequence and reset ALL state
            config.hoverSequenceActive = false
            config.currentHoverTarget = 1
            config.currentRock = nil
            config.ignoredRocks = {}
            config.lastRockDurability = nil
            config.isLockedOn = false
            
            -- ✅ Stop all systems in correct order
            stopAutoMine()
            funcs.stopNoclip()
            funcs.cleanupPhysicsMovement()
            
            -- ✅ Force stop all movement immediately
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Velocity = Vector3.new(0, 0, 0)
                    rootPart.Anchored = false
                end
            end
        end
    end
end)

-- ═══════════════════════════════════════════════════════════════════════════
-- MAIN LOOPS
-- ═══════════════════════════════════════════════════════════════════════════

local farmLoop = RunService.Heartbeat:Connect(function()
    if not config.enabled or config.isRespawning then return end
    
    if not config.bodyVelocity or not config.bodyGyro then
        funcs.setupPhysicsMovement()
        return
    end
    
    if config.hoverSequenceActive then
        if config.currentHoverTarget == 1 then
            if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
                config.currentHoverTarget = 2
            end
        elseif config.currentHoverTarget == 2 then
            if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
                config.currentHoverTarget = 3
                config.hoverSequenceActive = false
            end
        end
        return
    end
    
    if not config.currentMob or not config.currentMob.Parent or not funcs.isValidMob(config.currentMob) then
        config.currentMob = funcs.getClosestMob()
        return
    end
    
    if config.currentMob then
        local lockPos = funcs.getLockPosition(config.currentMob)
        if lockPos then
            funcs.hoverToMob(lockPos, config.currentMob)
        end
    end
end)

local miningLoop = RunService.Heartbeat:Connect(function()
    if not config.miningEnabled or config.isRespawning then return end
    
    if not config.bodyVelocity or not config.bodyGyro then
        funcs.setupPhysicsMovement()
        return
    end
    
    -- ✅ Handle hover sequence first (same as farming)
    if config.hoverSequenceActive then
        if config.currentHoverTarget == 1 then
            if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
                config.currentHoverTarget = 2
            end
        elseif config.currentHoverTarget == 2 then
            if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
                config.currentHoverTarget = 3
                config.hoverSequenceActive = false
            end
        end
        return
    end
    
    -- ✅ Check if current rock is destroyed
    if config.currentRock and (not config.currentRock.Parent or not funcs.isValidRock(config.currentRock)) then
        config.currentRock = nil
        config.lastRockDurability = nil
    end
    
    -- ✅ Check if rock is taking damage
    if config.currentRock then
        local currentTime = tick()
        
        -- Check durability every few seconds
        if currentTime - config.rockDurabilityCheck >= config.rockDurabilityCheckInterval then
            config.rockDurabilityCheck = currentTime
            
            local currentDurability = funcs.getRockDurability(config.currentRock)
            
            if config.lastRockDurability then
                -- If durability hasn't changed, rock is being mined by someone else
                if currentDurability == config.lastRockDurability then
                    -- Add to ignored list
                    table.insert(config.ignoredRocks, config.currentRock)
                    
                    -- Reset and find new rock
                    config.currentRock = nil
                    config.lastRockDurability = nil
                    return
                end
            end
            
            -- Update last known durability
            config.lastRockDurability = currentDurability
        end
    end
    
    -- ✅ Find new rock if we don't have one
    if not config.currentRock then
        config.currentRock = funcs.getClosestRock()
        
        if config.currentRock then
            -- Reset durability tracking for new rock
            config.lastRockDurability = funcs.getRockDurability(config.currentRock)
            config.rockDurabilityCheck = tick()
            
            -- Make it transparent
            funcs.makeRockTransparent(config.currentRock)
        end
        return
    end
    
    if config.currentRock then
        local rockPos = funcs.getMiningPosition(config.currentRock)
        if rockPos then
            funcs.hoverToRock(rockPos, config.currentRock)
        end
    end
end)

-- ═══════════════════════════════════════════════════════════════════════════
-- CHARACTER RESPAWN HANDLER (FIXED - 3 SECOND DELAY FOR BOTH)
-- ═══════════════════════════════════════════════════════════════════════════

LocalPlayer.CharacterAdded:Connect(function(character)
    -- ✅ Immediately stop everything
    config.currentMob = nil
    config.currentRock = nil
    config.isLockedOn = false
    config.isRespawning = true
    config.hoverSequenceActive = false
    funcs.cleanupPhysicsMovement()
    funcs.stopNoclip()
    
    -- ✅ Only resume if farming or mining was enabled
    local wasFarming = config.enabled
    local wasMining = config.miningEnabled
    
    if wasFarming or wasMining then
        -- ✅ CRITICAL: Wait for character to fully load, THEN wait 3 seconds
        character:WaitForChild("HumanoidRootPart", 10)
        task.wait(3)  -- This was not actually waiting before
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            -- ✅ Setup hover sequence
            config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
            config.hoverSequenceActive = true
            config.currentHoverTarget = 1
            
            funcs.setupPhysicsMovement()
            funcs.startNoclip()
            
            if wasFarming then 
                funcs.autoEquipWeapon()
            end
            if wasMining then 
                funcs.autoEquipPickaxe()
                -- Reset mining state
                config.ignoredRocks = {}
                config.lastRockDurability = nil
                config.rockDurabilityCheck = tick()
            end
        end
        
        config.isRespawning = false
    else
        config.isRespawning = false
    end
end)

-- ═══════════════════════════════════════════════════════════════════════════
-- FINISH
-- ═══════════════════════════════════════════════════════════════════════════
