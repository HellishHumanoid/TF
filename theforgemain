-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RAFSO'S SCRIPT - PART 1: CORE SETUP & CONFIG (WITH LAVA CHECK + WANTED ORES + DEFENSE FIX)
-- THE FORGE - WORLD DETECTION + AUTO-REJOIN + ANTI-AFK SYSTEM
-- Automatically detects which world you're in and loads the correct script
-- Created by Rafso [literalh]
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER POSITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- OCCUPIED ORE DETECTION CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local OCCUPIED_CHECK_DISTANCE = 15 -- Distance to check for other players
local TELEPORT_UP_DISTANCE = 10 -- Studs to teleport up when disabling features

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498

local originalPosition = nil

-- Remote for selling
local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ITEMS BY RARITY (FOR AUTOSELL)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ItemsByRarity = {
	Common = {
		"Stone",
		"Sand Stone",
		"Copper",
		"Iron",
		"Cardboardite"
	},
	Uncommon = {
		"Cobalt",
		"Titanium",
		"Lapis Lazuli",
		"Tin",
		"Silver",
		"Gold",
		"Bananite"
	},
	Rare = {
		"Volcanic Rock",
		"Quartz",
		"Amethyst",
		"Boneite",
		"Dark Boneite",
		"Topaz",
		"Diamond",
		"Sapphire",
		"Mushroomite",
		"Platinum"
	},
	Epic = {
		"Aite",
		"Slimite",
		"Poopite",
		"Cuprite",
		"Obsidian",
		"Emerald",
		"Ruby",
		"Rivalite"
	},
	Legendary = {
		"Uranium",
		"Mythril",
		"Eye Ore",
		"Fireite",
		"Magmaite",
		"Lightite",
		"Rainbow Crystal"
	},
	Mythical = {
		"Demonite",
		"Darkryte",
		"Arcane Crystal"
	},
	Rune = {
		"Frost Speck",
		"Venom Crumb",
		"Blast Chip",
		"Miner Shard",
		"Flame Spark",
		"Drain Edge",
		"Briar Notch",
		"Ward Patch",
		"Rot Stich",
		"Chill Dust",
		"Rage Mark"
	},
	Essence = {
		"Tiny Essence",
		"Small Essence",
		"Medium Essence",
		"Large Essence",
		"Greater Essence",
		"Epic Essence",
		"Superior Essence"
	}
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFIG SAVE/LOAD SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local CONFIG_FOLDER = "RafsoHubConfigs"
local CONFIG_LIST_FILE = CONFIG_FOLDER .. "/ConfigList.json"
local AUTOLOAD_FILE = CONFIG_FOLDER .. "/AutoLoad.txt"

local configLog = ""

local function addToLog(message)
	configLog = configLog .. message .. "\n"
end

local function clearLog()
	configLog = ""
end

if not isfolder(CONFIG_FOLDER) then
	makefolder(CONFIG_FOLDER)
end

local function saveConfig(configName)
	clearLog()
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	addToLog("ğŸ’¾ SAVING CONFIG: " .. configName)
	addToLog("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	local configData = {
		enabled = _G.MobFarmConfig.enabled,
		behindDistance = _G.MobFarmConfig.behindDistance,
		verticalDistance = _G.MobFarmConfig.verticalDistance,
		farmDistance = _G.MobFarmConfig.farmDistance,
		hoverSpeed = _G.MobFarmConfig.hoverSpeed,
		lockPosition = _G.MobFarmConfig.lockPosition,
		aboveAngle = _G.MobFarmConfig.aboveAngle,
		belowAngle = _G.MobFarmConfig.belowAngle,
		mobTypes = {},
		oreFilterEnabled = _G.MobFarmConfig.oreFilterEnabled,
		selectedOres = _G.MobFarmConfig.selectedOres,
		miningEnabled = _G.MobFarmConfig.miningEnabled,
		miningVerticalDistance = _G.MobFarmConfig.miningVerticalDistance,
		miningAngle = _G.MobFarmConfig.miningAngle,
		ignoreGoblinCave = _G.MobFarmConfig.ignoreGoblinCave,
		rockTypes = {},
		autoSellEnabled = _G.MobFarmConfig.autoSellEnabled,
		selectedItems = _G.MobFarmConfig.selectedItems,
		lavaCheckEnabled = _G.MobFarmConfig.lavaCheckEnabled,
		avoidOccupied = _G.MobFarmConfig.avoidOccupied,
		defenseLockPosition = _G.MobFarmConfig.defenseLockPosition,  -- âœ… NEW
		miningDefenseVerticalDistance = _G.MobFarmConfig.miningDefenseVerticalDistance,  -- âœ… NEW
	}
	
	addToLog("ğŸ“Š Settings:")
	addToLog("  Avoid Occupied: " .. tostring(configData.avoidOccupied))
	addToLog("  Defense Position: " .. tostring(configData.defenseLockPosition))  -- âœ… NEW
	
	for _, mobData in ipairs(_G.MobFarmConfig.mobTypes) do
		table.insert(configData.mobTypes, {
			name = mobData.name,
			enabled = mobData.enabled,
			priority = mobData.priority
		})
	end
	
	for _, rockData in ipairs(_G.MobFarmConfig.rockTypes) do
		table.insert(configData.rockTypes, {
			name = rockData.name,
			enabled = rockData.enabled,
			priority = rockData.priority
		})
	end
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	local success, err = pcall(function()
		local jsonData = game:GetService("HttpService"):JSONEncode(configData)
		writefile(configPath, jsonData)
	end)
	
	if not success then
		addToLog("âŒ Failed: " .. tostring(err))
		setclipboard(configLog)
		return false
	end
	
	local configList = {}
	if isfile(CONFIG_LIST_FILE) then
		local listSuccess, listData = pcall(function()
			return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
		end)
		if listSuccess then configList = listData end
	end
	
	if not table.find(configList, configName) then
		table.insert(configList, configName)
		writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
	end
	
	addToLog("âœ… CONFIG SAVED")
	setclipboard(configLog)
	return true
end

local function loadConfig(configName)
	clearLog()
	addToLog("ğŸ“‚ LOADING CONFIG: " .. configName)
	
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	
	if not isfile(configPath) then
		addToLog("âŒ Config not found")
		setclipboard(configLog)
		return false
	end
	
	local success, configData = pcall(function()
		return game:GetService("HttpService"):JSONDecode(readfile(configPath))
	end)
	
	if not success then
		addToLog("âŒ Failed to parse")
		setclipboard(configLog)
		return false
	end
	
	_G.MobFarmConfig.enabled = configData.enabled or false
	_G.MobFarmConfig.miningEnabled = configData.miningEnabled or false
	_G.MobFarmConfig.autoSellEnabled = configData.autoSellEnabled or false
	_G.MobFarmConfig.behindDistance = configData.behindDistance or 8
	_G.MobFarmConfig.verticalDistance = configData.verticalDistance or 8
	_G.MobFarmConfig.farmDistance = configData.farmDistance or 1000
	_G.MobFarmConfig.hoverSpeed = configData.hoverSpeed or 80
	_G.MobFarmConfig.lockPosition = configData.lockPosition or "Below"
	_G.MobFarmConfig.aboveAngle = configData.aboveAngle or 90
	_G.MobFarmConfig.belowAngle = configData.belowAngle or 240
	_G.MobFarmConfig.lavaCheckEnabled = configData.lavaCheckEnabled ~= false
	_G.MobFarmConfig.avoidOccupied = configData.avoidOccupied ~= false
	
	-- âœ… NEW: Load defense settings
	_G.MobFarmConfig.defenseLockPosition = configData.defenseLockPosition or "Below"
	_G.MobFarmConfig.miningDefenseVerticalDistance = configData.miningDefenseVerticalDistance or 6
	-- âœ… NEW: Load ore filter settings
	_G.MobFarmConfig.oreFilterEnabled = configData.oreFilterEnabled or false
	_G.MobFarmConfig.selectedOres = configData.selectedOres or {}
		
	if configData.mobTypes then
		for i, savedMob in ipairs(configData.mobTypes) do
			if _G.MobFarmConfig.mobTypes[i] then
				_G.MobFarmConfig.mobTypes[i].enabled = savedMob.enabled
			end
		end
	end
	
	_G.MobFarmConfig.miningVerticalDistance = configData.miningVerticalDistance or 6
	_G.MobFarmConfig.miningAngle = configData.miningAngle or 270
	_G.MobFarmConfig.ignoreGoblinCave = configData.ignoreGoblinCave ~= false
	
	if configData.rockTypes then
		for i, savedRock in ipairs(configData.rockTypes) do
			if _G.MobFarmConfig.rockTypes[i] then
				_G.MobFarmConfig.rockTypes[i].enabled = savedRock.enabled
			end
		end
	end
	
	if configData.selectedItems then
		_G.MobFarmConfig.selectedItems = configData.selectedItems
	end
	
	addToLog("âœ… CONFIG LOADED")
	setclipboard(configLog)
	return true
end

local function getConfigList()
	if not isfile(CONFIG_LIST_FILE) then return {} end
	local success, configList = pcall(function()
		return game:GetService("HttpService"):JSONDecode(readfile(CONFIG_LIST_FILE))
	end)
	return success and configList or {}
end

local function deleteConfig(configName)
	local configPath = CONFIG_FOLDER .. "/" .. configName .. ".json"
	if isfile(configPath) then delfile(configPath) end
	
	local configList = getConfigList()
	for i, name in ipairs(configList) do
		if name == configName then
			table.remove(configList, i)
			writefile(CONFIG_LIST_FILE, game:GetService("HttpService"):JSONEncode(configList))
			break
		end
	end
	
	if isfile(AUTOLOAD_FILE) and readfile(AUTOLOAD_FILE) == configName then
		delfile(AUTOLOAD_FILE)
	end
	return true
end

local function setAutoload(configName)
	writefile(AUTOLOAD_FILE, configName)
end

local function getAutoload()
	if isfile(AUTOLOAD_FILE) then return readfile(AUTOLOAD_FILE) end
	return nil
end

_G.ConfigFunctions = {
	saveConfig = saveConfig,
	loadConfig = loadConfig,
	getConfigList = getConfigList,
	deleteConfig = deleteConfig,
	setAutoload = setAutoload,
	getAutoload = getAutoload,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GLOBAL CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
_G.MobFarmConfig = {
	enabled = false,
	behindDistance = 8,
	verticalDistance = 8,
	farmDistance = 1000,
	hoverSpeed = 80,
	lockPosition = "Below",
	aboveAngle = 90,
	belowAngle = 240,
	
	avoidOccupied = true,

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- âœ… NEW: ORE FILTER CONFIG
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	oreFilterEnabled = false,
	selectedOres = {},  -- Table of selected ore names like {"Diamond", "Titanium"}
	lastOreCheckTime = 0,
	oreCheckInterval = 0.1,  -- Check every 0.2 seconds

	-- All available ores in the game
	availableOres = {
		"Cobalt",
		"Titanium",
		"Lapis Lazuli",
		"Volcanic Rock",
		"Quartz",
		"Amethyst",
		"Boneite",
		"Dark Boneite",
		"Topaz",
		"Diamond",
		"Sapphire",
		"Magenta Crystal",
		"Crimson Crystal",
		"Blue Crystal",
		"Orange Crystal",
		"Green Crystal",
		"Obsidian",
		"Emerald",
		"Ruby",
		"Rivalite",
		"Uranium",
		"Mythril",
		"Eye Ore",
		"Fireite",
		"Magmaite",
		"Lightite",
		"Rainbow Crystal",
		"Demonite",
		"Darkryte",
		"Arcane Crystal"
	},
	
	lavaCheckEnabled = true,
	farmingLastHealth = nil,
	inLavaMode = false,
	savedLockPosition = nil,
	lavaCheckCooldown = false,
	lavaCooldownTime = 1,
	
	hoverSequenceActive = false,
	currentHoverTarget = 1,
	hoverReachedThreshold = 3,
	hoverPosition1 = nil,
	
	weaponRemote = nil,
	lastAttackTime = 0,
	attackCooldown = 0.25,
	lastWeaponCheckTime = 0,
	weaponCheckInterval = 0.5,
	lastToolEquipTime = 0,
    toolEquipCooldown = 0.5,
    lastDefenseCheckTime = 0,
    defenseCheckInterval = 0.5,
	
	currentMob = nil,
	isLockedOn = false,
	bodyVelocity = nil,
	bodyGyro = nil,
	noclipLoop = nil,
	isRespawning = false,
	
	mobTypes = {
		{name = "Reaper", pattern = "^Reaper%d+$", enabled = false, priority = 1},
		{name = "Elite Deathaxe Skeleton", pattern = "^Elite Deathaxe Skeleton%d+$", enabled = false, priority = 2},
		{name = "Deathaxe Skeleton", pattern = "^Deathaxe Skeleton%d+$", enabled = false, priority = 3},
		{name = "Elite Rogue Skeleton", pattern = "^Elite Rogue Skeleton%d+$", enabled = false, priority = 4},
		{name = "Blazing Slime", pattern = "^Blazing Slime%d+$", enabled = false, priority = 5},
        {name = "Blight Pyromancer", pattern = "^Blight Pyromancer%d+$", enabled = false, priority = 7},
		{name = "Axe Skeleton", pattern = "^Axe Skeleton%d+$", enabled = false, priority = 7},
		{name = "Skeleton Rogue", pattern = "^Skeleton Rogue%d+$", enabled = false, priority = 8},
		{name = "Bomber", pattern = "^Bomber%d+$", enabled = false, priority = 9},
		{name = "Slime", pattern = "^Slime%d+$", enabled = false, priority = 10},
	},
	
	miningEnabled = false,
	miningVerticalDistance = 6,
	miningAngle = 270,
	currentRock = nil,
	lastMineTime = 0,
	miningCooldown = 0.1,
	lastPickaxeCheckTime = 0,
	pickaxeCheckInterval = 0.5,
	miningBodyVelocity = nil,
	miningBodyGyro = nil,
	ignoreGoblinCave = true,
	
	rockDurabilityCheck = 0,
	rockDurabilityCheckInterval = 3,
	lastRockDurability = nil,
	ignoredRocks = {},
	
	rockTypes = {
		{name = "Volcanic Rock", enabled = false, priority = 1},
		{name = "Earth Crystal", enabled = false, priority = 2},
		{name = "Violet Crystal", enabled = false, priority = 3},
		{name = "Crimson Crystal", enabled = false, priority = 4},
		{name = "Light Crystal", enabled = false, priority = 5},
		{name = "Cyan Crystal", enabled = false, priority = 6},
		{name = "Basalt Vein", enabled = false, priority = 7},
		{name = "Basalt Core", enabled = false, priority = 8},
		{name = "Basalt Rock", enabled = false, priority = 9},
	},
	
	autoSellEnabled = false,
	sellCooldown = 1.5,
	lastSellTime = 0,
	autoClickerActive = false,
	autoClickerLoop = nil,
	selectedItems = {
		Common = {},
		Uncommon = {},
		Rare = {},
		Epic = {},
		Legendary = {},
		Mythical = {},
		Rune = {},
		Essence = {}
	},

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- âœ… NEW: DEFENSE SYSTEM CONFIG
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	miningDefenseEnabled = true,
	miningDefenseDistance = 10,  -- Detection range (10 studs)
	miningDefenseVerticalDistance = 6,  -- Vertical distance from mob
	defenseLockPosition = "Below",  -- Default to Below position
	defendingAgainstMob = nil,
	savedMiningRock = nil,
	weaponEquipped = false,
	lastDefenseAttackTime = 0,
	defenseAttackCooldown = 0.1,
}

local config = _G.MobFarmConfig

print("âœ… Part 1 loaded with DEFENSE SYSTEM CONFIG!")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 2: NOCLIP & MOB/ROCK DETECTION (FIXED OCCUPIED CHECK)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")
local config = _G.MobFarmConfig

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startNoclip()
	if config.noclipLoop then return end
	
	config.noclipLoop = RunService.Stepped:Connect(function()
		local isTeleporting = _G.teleportHoverActive == true
		
		if not config.enabled and not config.miningEnabled and not isTeleporting then 
			return 
		end
		
		local character = LocalPlayer.Character
		if not character then return end
		
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end)
end

local function stopNoclip()
	if config.noclipLoop then
		config.noclipLoop:Disconnect()
		config.noclipLoop = nil
		
		local character = LocalPlayer.Character
		if character then
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					part.CanCollide = true
				end
			end
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOB DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidMob(mob)
	local humanoid = mob:FindFirstChildOfClass("Humanoid")
	local rootPart = mob:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not rootPart then return false end
	if humanoid.Health <= 0 then return false end
	if Players:GetPlayerFromCharacter(mob) then return false end
	
	return true
end

local function matchesMobPattern(mobName, pattern)
	return string.match(mobName, pattern) ~= nil
end

local function getMobPriority(mob)
	for _, mobData in ipairs(config.mobTypes) do
		if mobData.enabled and matchesMobPattern(mob.Name, mobData.pattern) then
			return mobData.priority
		end
	end
	return 999
end

local function getClosestMob()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return nil end
	
	local closestMob = nil
	local closestDistance = config.farmDistance
	local highestPriority = 999
	
	for _, child in pairs(Living:GetChildren()) do
		if isValidMob(child) then
			for _, mobData in pairs(config.mobTypes) do
				if mobData.enabled and matchesMobPattern(child.Name, mobData.pattern) then
					local mobRoot = child:FindFirstChild("HumanoidRootPart")
					if mobRoot then
						local distance = (rootPart.Position - mobRoot.Position).Magnitude
						local priority = getMobPriority(child)
						
						if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
							closestMob = child
							closestDistance = distance
							highestPriority = priority
						end
					end
					break
				end
			end
		end
	end
	
	return closestMob
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… FIXED: IMPROVED OCCUPIED CHECK
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local OCCUPIED_CHECK_DISTANCE = 15

local function isOreOccupied(rock)
	-- âœ… Early exit if feature disabled
	if not config.avoidOccupied then return false end
	if not rock then return false end
	
	-- âœ… Get rock position
	local positionPart = _G.FarmFunctions.getRockPosition(rock)
	if not positionPart then return false end
	
	local rockPos = positionPart.Position
	
	-- âœ… Get our character
	local character = LocalPlayer.Character
	if not character then return false end
	
	local myRootPart = character:FindFirstChild("HumanoidRootPart")
	if not myRootPart then return false end
	
	-- âœ… CHECK ALL PLAYERS IN REAL-TIME
	for _, player in pairs(Players:GetPlayers()) do
		-- Skip ourselves
		if player == LocalPlayer then continue end
		
		local otherChar = player.Character
		if otherChar then
			local otherRoot = otherChar:FindFirstChild("HumanoidRootPart")
			if otherRoot then
				-- âœ… Calculate distance from other player to rock
				local distance = (otherRoot.Position - rockPos).Magnitude
				
				-- âœ… If player is within range of the rock
				if distance <= OCCUPIED_CHECK_DISTANCE then
					-- âœ… Check if they have pickaxe equipped OR in their backpack
					local hasPickaxeEquipped = otherChar:FindFirstChild("Pickaxe")
					
					if hasPickaxeEquipped then
						print("âš ï¸ Rock occupied by: " .. player.Name .. " (Distance: " .. math.floor(distance) .. " studs)")
						return true
					end
					
					-- âœ… Also check their backpack (they might be switching tools)
					local otherBackpack = player:FindFirstChild("Backpack")
					if otherBackpack then
						local hasPickaxeInBackpack = otherBackpack:FindFirstChild("Pickaxe")
						if hasPickaxeInBackpack then
							print("âš ï¸ Rock potentially occupied by: " .. player.Name .. " (Has pickaxe in backpack)")
							return true
						end
					end
				end
			end
		end
	end
	
	return false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ROCK DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValidRock(durabilityModel)
	if not durabilityModel:IsA("Model") then return false end
	if not durabilityModel.Parent then return false end
	
	local hasMeshPart = durabilityModel:FindFirstChildOfClass("MeshPart") ~= nil
	
	return hasMeshPart
end

local function isRockIgnored(rock)
	for _, ignoredRock in ipairs(config.ignoredRocks) do
		if ignoredRock == rock then
			return true
		end
	end
	return false
end

local function getRockPriority(rockTypeName)
	for _, rockData in ipairs(config.rockTypes) do
		if rockData.enabled and rockTypeName == rockData.name then
			return rockData.priority
		end
	end
	return 999
end

local function getRockPosition(durabilityModel)
	local rockPart = durabilityModel:FindFirstChild("Rock")
	if rockPart and rockPart:IsA("BasePart") then
		return rockPart
	end
	
	local rockTypeModel = durabilityModel.Parent
	if rockTypeModel then
		local hitbox = rockTypeModel:FindFirstChild("Hitbox")
		if hitbox and hitbox:IsA("BasePart") then
			return hitbox
		end
	end
	
	local meshPart = durabilityModel:FindFirstChildOfClass("MeshPart")
	if meshPart then
		return meshPart
	end
	
	return nil
end

local function getRockDurability(rock)
	if not rock then return nil end
	return tonumber(rock.Name)
end

local function getClosestRock()
	local character = LocalPlayer.Character
	if not character then 
		return nil 
	end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then 
		return nil 
	end
	
	local rocksFolder = workspace:FindFirstChild("Rocks")
	if not rocksFolder then
		return nil
	end
	
	local closestRock = nil
	local closestDistance = config.farmDistance
	local highestPriority = 999
	
	for _, islandFolder in pairs(rocksFolder:GetChildren()) do
		if islandFolder:IsA("Folder") then
			if config.ignoreGoblinCave and islandFolder.Name == "Island2GoblinCave" then
				continue
			end
			
			for _, spawnPart in pairs(islandFolder:GetChildren()) do
				if spawnPart:IsA("Part") and spawnPart.Name == "SpawnLocation" then
					for _, rockTypeModel in pairs(spawnPart:GetChildren()) do
						if rockTypeModel:IsA("Model") then
							local rockTypeName = rockTypeModel.Name
							local priority = getRockPriority(rockTypeName)
							
							if priority < 999 then
								for _, durabilityModel in pairs(rockTypeModel:GetChildren()) do
									if durabilityModel:IsA("Model") and tonumber(durabilityModel.Name) then
										if not isRockIgnored(durabilityModel) and isValidRock(durabilityModel) then
											local positionPart = getRockPosition(durabilityModel)
											if positionPart then
												local distance = (rootPart.Position - positionPart.Position).Magnitude
												
												if distance <= config.farmDistance then
													-- âœ… Real-time occupied check BEFORE considering this rock
													if not isOreOccupied(durabilityModel) then
														if priority < highestPriority or (priority == highestPriority and distance < closestDistance) then
															closestRock = durabilityModel
															closestDistance = distance
															highestPriority = priority
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	
	return closestRock
end

local function makeRockTransparent(rock)
	if not rock then return end
	
	for _, descendant in pairs(rock:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			descendant.Transparency = 0.7
		end
	end
	
	local rockTypeModel = rock.Parent
	if rockTypeModel then
		for _, descendant in pairs(rockTypeModel:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				descendant.Transparency = 0.7
			end
		end
	end
end

-- Store functions globally
_G.FarmFunctions = _G.FarmFunctions or {}
_G.FarmFunctions.startNoclip = startNoclip
_G.FarmFunctions.stopNoclip = stopNoclip
_G.FarmFunctions.getClosestMob = getClosestMob
_G.FarmFunctions.getClosestRock = getClosestRock
_G.FarmFunctions.isValidMob = isValidMob
_G.FarmFunctions.isValidRock = isValidRock
_G.FarmFunctions.getRockPosition = getRockPosition
_G.FarmFunctions.getRockDurability = getRockDurability
_G.FarmFunctions.isRockIgnored = isRockIgnored
_G.FarmFunctions.makeRockTransparent = makeRockTransparent
_G.FarmFunctions.isOreOccupied = isOreOccupied

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NEW: ORE DETECTION SYSTEM (FIXED - Now uses _G.FarmFunctions)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_G.FarmFunctions.getOresInRock = function(rock)
	if not rock or not rock.Parent then return {} end
	
	local rockTypeModel = rock.Parent  -- This is "Basalt Core" etc.
	if not rockTypeModel then return {} end
	
	local oresFound = {}
	
	-- Search through all children of the rock type model
	for _, child in pairs(rockTypeModel:GetChildren()) do
		-- Check if it has an "Ore" attribute
		local oreAttribute = child:GetAttribute("Ore")
		if oreAttribute then
			print("ğŸª¨ Found ore: " .. tostring(oreAttribute))
			table.insert(oresFound, tostring(oreAttribute))
		end
	end
	
	return oresFound
end

_G.FarmFunctions.hasDesiredOre = function(rock)
	local config = _G.MobFarmConfig
	
	-- If ore filter is disabled, allow all rocks
	if not config.oreFilterEnabled then return true end
	
	-- If no ores selected, allow all rocks
	if #config.selectedOres == 0 then return true end
	
	-- Get ores in this rock
	local oresInRock = _G.FarmFunctions.getOresInRock(rock)
	
	-- If no ores found yet, allow mining (might spawn later)
	if #oresInRock == 0 then return true end
	
	-- Check if any of the found ores match our filter
	for _, foundOre in ipairs(oresInRock) do
		for _, desiredOre in ipairs(config.selectedOres) do
			if foundOre == desiredOre then
				print("âœ… Found desired ore: " .. foundOre)
				return true
			end
		end
	end
	
	-- No matching ores found
	print("âŒ No desired ores found. Skipping rock.")
	return false
end

_G.FarmFunctions.shouldContinueMining = function(rock)
	local config = _G.MobFarmConfig
	
	if not rock then return false end
	if not config.oreFilterEnabled then return true end
	if #config.selectedOres == 0 then return true end
	
	-- Get current rock HP percentage
	local rockTypeModel = rock.Parent
	if not rockTypeModel then return true end
	
	local infoFrame = rockTypeModel:FindFirstChild("infoFrame")
	if not infoFrame then return true end
	
	local frame = infoFrame:FindFirstChild("Frame")
	if not frame then return true end
	
	local rockHP = frame:FindFirstChild("rockHP")
	if not rockHP or not rockHP:IsA("TextBox") then return true end
	
	local hpText = rockHP.Text
	-- Parse "150 / 750" format
	local current, max = hpText:match("(%d+)%s*/%s*(%d+)")
	if not current or not max then return true end
	
	local hpPercentage = (tonumber(current) / tonumber(max)) * 100
	
	-- Only check for ores when HP is at 40% or below
	if hpPercentage <= 40 then
		return _G.FarmFunctions.hasDesiredOre(rock)
	end
	
	return true  -- Keep mining if above 40% HP
end

print("âœ… Ore Detection System loaded!")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 3: WEAPON SYSTEM, AUTOSELL & PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WEAPON & TOOL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function autoEquipWeapon()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local weaponInChar = character:FindFirstChild("Weapon")
	if weaponInChar and weaponInChar:IsA("Tool") then
		return true
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local weapon = backpack:FindFirstChild("Weapon")
		if weapon and weapon:IsA("Tool") then
			humanoid:EquipTool(weapon)
			task.wait(0.2)
			return true
		end
	end
	
	return false
end

local function autoEquipPickaxe()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local pickaxeInChar = character:FindFirstChild("Pickaxe")
	if pickaxeInChar and pickaxeInChar:IsA("Tool") then
		return true
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local pickaxe = backpack:FindFirstChild("Pickaxe")
		if pickaxe and pickaxe:IsA("Tool") then
			humanoid:EquipTool(pickaxe)
			task.wait(0.2)
			return true
		end
	end
	
	return false
end

local function clickMouse()
	local success = pcall(function()
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		task.wait(0.01)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end)
	return success
end

local function performAttack()
	if not config.isLockedOn or not config.currentMob or config.hoverSequenceActive then
		return
	end
	
	local currentTime = tick()
	if currentTime - config.lastAttackTime < config.attackCooldown then
		return
	end
	
	config.lastAttackTime = currentTime
	clickMouse()
end

local function performMine()
	if config.defendingAgainstMob then return end  -- âœ… ADD THIS LINE
	if not config.currentRock then return end
	if not config.miningEnabled then return end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local pickaxe = character:FindFirstChild("Pickaxe")
	if not pickaxe then
		autoEquipPickaxe()
		return
	end
	
	local currentTime = tick()
	if currentTime - config.lastMineTime < config.miningCooldown then
		return
	end
	
	config.lastMineTime = currentTime
	clickMouse()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NEW: TELEPORT UP FUNCTION (10 STUDS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function teleportUp(distance)
	distance = distance or 10
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end
	
	local currentPos = rootPart.Position
	rootPart.CFrame = CFrame.new(currentPos + Vector3.new(0, distance, 0))
	print("â¬†ï¸ Teleported up " .. distance .. " studs")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
local SELLER_PROXIMITY = workspace.Proximity["Greedy Cey"].ProximityPrompt
local NO_BUTTON_X = 1200
local NO_BUTTON_Y = 498
local originalPosition = nil

local RunCommand = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)

local function startAutoClickerAt(x, y, duration)
	if config.autoClickerActive then return end
	
	config.autoClickerActive = true
	print("ğŸ–±ï¸ AutoClicker started at: X=" .. x .. ", Y=" .. y .. " for " .. duration .. " seconds")
	
	config.autoClickerLoop = task.spawn(function()
		local startTime = tick()
		local clicks = 0
		while config.autoClickerActive and (tick() - startTime) < duration do
			VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
			task.wait(0.01)
			VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
			clicks = clicks + 1
			task.wait(0.05)
		end
		config.autoClickerActive = false
		print("ğŸ›‘ AutoClicker stopped after " .. clicks .. " clicks")
	end)
end

local function stopAutoClicker()
	config.autoClickerActive = false
	if config.autoClickerLoop then
		task.cancel(config.autoClickerLoop)
		config.autoClickerLoop = nil
	end
end

local function closeChat()
	task.wait(0.3)
	print("ğŸ”˜ Starting autoclicker at No button position: X=" .. NO_BUTTON_X .. ", Y=" .. NO_BUTTON_Y)
	startAutoClickerAt(NO_BUTTON_X, NO_BUTTON_Y, 3)
	task.wait(0.3)
	stopAutoClicker()
	print("âœ… Dialogue close attempt complete")
end

local function talkToSeller()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	originalPosition = rootPart.CFrame
	print("ğŸ’¾ Saved original position: " .. tostring(originalPosition.Position))
	
	rootPart.CFrame = CFrame.new(SELLER_POSITION)
	task.wait(0.5)
	
	if SELLER_PROXIMITY then
		fireproximityprompt(SELLER_PROXIMITY)
		task.wait(0.5)
		closeChat()
		task.wait(0)
		
		if originalPosition then
			rootPart.CFrame = originalPosition
			print("ğŸ”™ Teleported back to original position")
		end
		
		return true
	end
	
	return false
end

local function getItemQuantity(itemName)
	local success, quantity = pcall(function()
		local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
		if not playerGui then return 0 end
		
		local menu = playerGui:FindFirstChild("Menu")
		if not menu then return 0 end
		
		local stash = menu:FindFirstChild("Frame", true)
		if stash then
			stash = stash:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Menus", true)
				if stash then
					stash = stash:FindFirstChild("Stash", true)
					if stash then
						stash = stash:FindFirstChild("Background", true)
						if stash then
							for _, itemFolder in pairs(stash:GetChildren()) do
								if itemFolder:IsA("Folder") or itemFolder:IsA("Frame") then
									local main = itemFolder:FindFirstChild("Main")
									if main then
										if itemFolder.Name == itemName then
											local quantityLabel = main:FindFirstChild("Quantity")
											if quantityLabel and quantityLabel:IsA("TextLabel") then
												local quantityText = quantityLabel.Text
												local number = tonumber(string.match(quantityText, "%d+"))
												return number or 0
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		
		return 0
	end)
	
	if success then
		return quantity
	else
		return 0
	end
end

local function sellItems()
	if not config.autoSellEnabled then return end
	
	local currentTime = tick()
	if currentTime - config.lastSellTime < config.sellCooldown then
		return
	end
	
	local itemsToSell = {}
	
	for rarity, items in pairs(config.selectedItems) do
		if rarity ~= "Rune" then
			for _, itemName in ipairs(items) do
				local quantity = getItemQuantity(itemName)
				
				if quantity > 0 then
					itemsToSell[itemName] = quantity
					print(string.format("ğŸ“¦ %s: %d", itemName, quantity))
				end
			end
		end
	end
	
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
	if playerGui then
		local menu = playerGui:FindFirstChild("Menu")
		if menu then
			local stash = menu:FindFirstChild("Frame", true)
			if stash then
				stash = stash:FindFirstChild("Frame", true)
				if stash then
					stash = stash:FindFirstChild("Menus", true)
					if stash then
						stash = stash:FindFirstChild("Stash", true)
						if stash then
							stash = stash:FindFirstChild("Background", true)
							if stash then
								for _, itemFolder in pairs(stash:GetChildren()) do
									local main = itemFolder:FindFirstChild("Main")
									if main then
										local itemNameLabel = main:FindFirstChild("ItemName")
										if itemNameLabel and itemNameLabel:IsA("TextLabel") then
											local itemName = itemNameLabel.Text
											
											for _, selectedRuneName in ipairs(config.selectedItems.Rune) do
												if itemName == selectedRuneName then
													itemsToSell[itemFolder.Name] = 1
													print(string.format("ğŸ”® %s (UUID: %s): 1", itemName, itemFolder.Name))
													break
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	
	if next(itemsToSell) == nil then
		return
	end
	
	local success, err = pcall(function()
		RunCommand:InvokeServer("SellConfirm", {Basket = itemsToSell})
	end)
	
	if success then
		config.lastSellTime = currentTime
		print("âœ… Sold items successfully")
	else
		print("âŒ Error selling: " .. tostring(err))
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PHYSICS MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function setupPhysicsMovement()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	if config.bodyVelocity then
		config.bodyVelocity:Destroy()
	end
	if config.bodyGyro then
		config.bodyGyro:Destroy()
	end
	
	local bv = Instance.new("BodyVelocity")
	bv.Name = "FarmVelocity"
	bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	bv.Velocity = Vector3.new(0, 0, 0)
	bv.P = 1250
	bv.Parent = rootPart
	config.bodyVelocity = bv
	
	local bg = Instance.new("BodyGyro")
	bg.Name = "FarmGyro"
	bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
	bg.P = 30000
	bg.D = 1000
	bg.Parent = rootPart
	config.bodyGyro = bg
	
	rootPart.Anchored = false
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	end
	
	return true
end

local function cleanupPhysicsMovement()
	if config.bodyVelocity then
		config.bodyVelocity:Destroy()
		config.bodyVelocity = nil
	end
	if config.bodyGyro then
		config.bodyGyro:Destroy()
		config.bodyGyro = nil
	end
	
	local character = LocalPlayer.Character
	if character then
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if rootPart then
			rootPart.Anchored = false
			rootPart.Velocity = Vector3.new(0, 0, 0)
		end
		
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
			task.wait(0.1)
			humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
		end
	end
	
	config.isLockedOn = false
end

-- Add to global functions
funcs.autoEquipWeapon = autoEquipWeapon
funcs.autoEquipPickaxe = autoEquipPickaxe
funcs.performAttack = performAttack
funcs.performMine = performMine
funcs.setupPhysicsMovement = setupPhysicsMovement
funcs.cleanupPhysicsMovement = cleanupPhysicsMovement
funcs.talkToSeller = talkToSeller
funcs.sellItems = sellItems
funcs.teleportUp = teleportUp  -- âœ… NEW

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 4: MOVEMENT LOGIC & HOVERING (IMPROVED STABLE TRACKING + GROUND FIX)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- POSITION CALCULATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getLockPosition(mob)
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	if not mobRoot then return nil end
	
	local distance = config.behindDistance
	local verticalDist = config.verticalDistance
	local mobPos = mobRoot.Position
	local targetPos
	
	if config.lockPosition == "Back" then
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	elseif config.lockPosition == "Front" then
		local frontOffset = mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + frontOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	elseif config.lockPosition == "Above" then
		targetPos = mobPos + Vector3.new(0, verticalDist, 0)
	elseif config.lockPosition == "Below" then
		targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
	else
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
	end
	
	return targetPos
end

-- âœ… UPDATED: Support both above and below positioning for mining
local function getMiningPosition(rock)
	if not rock then return nil end
	
	local positionPart = funcs.getRockPosition(rock)
	if not positionPart then 
		return nil 
	end
	
	local rockPos = positionPart.Position
	
	-- âœ… NEW: Check if we're in lava mode (above positioning)
	if config.inLavaMode or config.miningAngle < 180 then
		-- Position ABOVE the rock
		local targetPos = rockPos + Vector3.new(0, config.miningVerticalDistance, 0)
		return targetPos
	else
		-- Position BELOW the rock (normal)
		local targetPos = rockPos + Vector3.new(0, -config.miningVerticalDistance, 0)
		return targetPos
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOVER MOVEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function hoverToPosition(targetPos, lookAtPos)
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return false
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < config.hoverReachedThreshold then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		return true
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	
	local desiredVelocity = direction.Unit * targetSpeed
	local currentVelocity = config.bodyVelocity.Velocity
	local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	if lookAtPos then
		local lookCFrame = CFrame.new(currentPos, lookAtPos)
		config.bodyGyro.CFrame = lookCFrame
	end
	
	return false
end

local function hoverToMob(targetPos, mob)
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
		return
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	config.isLockedOn = distance < 8
	
	if (config.lockPosition == "Above" or config.lockPosition == "Below") and distance < 3 then
		if distance < 1.5 then
			config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		else
			local followSpeed = 8
			local desiredVelocity = direction.Unit * followSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.1)
		end
		
		if config.lockPosition == "Above" then
			local angle = math.rad(config.aboveAngle)
			local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(downCFrame, 0.6)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 50000
		else
			local angle = math.rad(config.belowAngle)
			local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(upCFrame, 0.6)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 50000
		end
		return
	end
	
	local targetSpeed
	if distance < 2 then
		targetSpeed = 5
	elseif distance < 5 then
		targetSpeed = 15
	else
		targetSpeed = config.hoverSpeed * math.min(distance / 10, 1)
	end
	
	local desiredVelocity = direction.Unit * targetSpeed
	
	local lerpSpeed
	if distance < 2 then
		lerpSpeed = 0.2
	elseif distance < 5 then
		lerpSpeed = 0.35
	else
		lerpSpeed = 0.25
	end
	
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, lerpSpeed)
	config.bodyVelocity.Velocity = newVelocity
	
	local lookCFrame = CFrame.new(currentPos, mobRoot.Position)
	if distance < 5 then
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.7)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 60000
		config.bodyGyro.D = 1500
	else
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.4)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 30000
		config.bodyGyro.D = 1000
	end
end

-- âœ… FIXED: Improved mining hover with ground collision ignore
local function hoverToRock(targetPos, rock)
	if not targetPos then 
		return 
	end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return
	end
	
	-- âœ… FIX: Force upward position to avoid ground collision
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	-- âœ… FIX: Add upward force if getting stuck on ground
	local rockPositionPart = funcs.getRockPosition(rock)
	if rockPositionPart then
		local groundCheckRay = workspace:Raycast(
			rootPart.Position,
			Vector3.new(0, -2, 0),
			RaycastParams.new()
		)
		
		-- If we detect ground below and we're trying to mine below the rock
		if groundCheckRay and config.miningAngle > 180 then
			-- Add extra upward velocity to lift off ground
			local upwardBoost = Vector3.new(0, 15, 0)
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity + upwardBoost
		end
	end
	
	if distance < 3 then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		config.isLockedOn = true  -- âœ… ADD THIS LINE
		
		-- âœ… UPDATED: Use current mining angle (supports both above and below)
		local angle = math.rad(config.miningAngle)
		local lookCFrame
		
		if config.miningAngle < 180 then
			-- Above position - look down
			lookCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
		else
			-- Below position - look up
			lookCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
		end
		
		config.bodyGyro.CFrame = lookCFrame
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 50000
		return
	end
	
	-- âœ… FIX: Stronger force to overcome ground resistance
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = math.max(config.hoverSpeed * speedMultiplier, 30) -- Minimum 30 speed
	local desiredVelocity = direction.Unit * targetSpeed
	
	-- âœ… FIX: More aggressive lerp to overcome ground collision
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.7)
	
	config.bodyVelocity.Velocity = newVelocity
	
	local positionPart = funcs.getRockPosition(rock)
	if positionPart then
		local lookCFrame = CFrame.new(currentPos, positionPart.Position)
		config.bodyGyro.CFrame = lookCFrame
		config.bodyGyro.P = 15000 -- âœ… Increased from 10000
	end
end

-- Add to global functions
funcs.getLockPosition = getLockPosition
funcs.getMiningPosition = getMiningPosition
funcs.hoverToPosition = hoverToPosition
funcs.hoverToMob = hoverToMob
funcs.hoverToRock = hoverToRock

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 5: LINORIA UI & AUTO-LOOPS (WITH WANTED ORES DROPDOWN)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Living = workspace:WaitForChild("Living")

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)
local TELEPORT_UP_DISTANCE = 10

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ENSURE TOGGLES/OPTIONS ARE GLOBALLY ACCESSIBLE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

getgenv().Toggles = Toggles
getgenv().Options = Options

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NEW: TELEPORT UP FUNCTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function teleportUp(distance)
	distance = distance or TELEPORT_UP_DISTANCE
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end
	
	local currentPos = rootPart.Position
	rootPart.CFrame = CFrame.new(currentPos + Vector3.new(0, distance, 0))
	print("â¬†ï¸ Teleported up " .. distance .. " studs")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT POSITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local teleportAreas = {
	["Spawn"] = Vector3.new(-208.25, 20.64, -47.41),
	["Pickaxes"] = Vector3.new(-155.57, 22.04, -106.88),
	["Potions"] = Vector3.new(-97.65, 21.16, -45.95),
	["Forge"] = Vector3.new(10.03, 24.01, -69.16),
	["Camp"] = Vector3.new(56.15, 74.22, -44.13),
	["Cave 1"] = Vector3.new(184.79, 74.83, -53.13),
	["Cave 2"] = Vector3.new(471.46, 56.90, -57.97),
	["Cave 3"] = Vector3.new(452.92, 35.34, -318.90),
	["Cave 4"] = Vector3.new(391.43, 87.56, 75.71),
	["Cave 5"] = Vector3.new(388.29, 65.55, 72.86),
	["Goblin Cave"] = Vector3.new(82.91, 20.55, -237.12),
	["Magma Pickaxe $150.000"] = Vector3.new(376.50, 87.54, 106.98),
	["Demonic Pickaxe $500.000"] = Vector3.new(645.36, 53.54, 268.87),
}

local teleportNPCs = {
	["Buyer"] = Vector3.new(-141.54, 21.24, -26.52),
	["Equipment Buyer"] = Vector3.new(-116.19, 21.41, -89.88),
	["Sensei Moro"] = Vector3.new(7.53, 23.77, -59.61),
	["Barakkulf"] = Vector3.new(16.53, 23.82, -37.62),
	["Enhancer"] = Vector3.new(19.12, 21.56, -126.99),
	["Runemaker"] = Vector3.new(-51.44, 21.46, -139.54),
	["Fisher"] = Vector3.new(-16.32, 20.81, -445.35),
	["Goblin King"] = Vector3.new(73.56, 20.64, -335.58),
	["Masked Stranger"] = Vector3.new(85.55, 74.90, -25.40),
	["Isaac"] = Vector3.new(24.13, 74.19, -26.35),
	["Henry"] = Vector3.new(10.37, 74.22, -39.45),
	["Captain Rowan"] = Vector3.new(23.79, 74.68, -64.36),
	["Wizard"] = Vector3.new(104.79, 47.44, 138.17),
	["Aida"] = Vector3.new(101.42, 47.32, 154.71),
	["Line"] = Vector3.new(-164.69, 33.65, 59.51),
	["Walter"] = Vector3.new(24.41, 74.60, -70.52),
	["Malik"] = Vector3.new(36.07, 74.44, -56.70),
	["Amber"] = Vector3.new(372.30, 87.54, 107.06),
	["Monke"] = Vector3.new(-415.39, 33.49, -247.29),
	["Tomo Cat"] = Vector3.new(292.36, 19.82, -82.34),
	["Ratheus (Useless)"] = Vector3.new(288.06, 134.02, -168.88),
}

local selectedArea = nil
local selectedNPC = nil

_G.teleportHoverActive = false
local teleportHoverTarget = nil
local teleportHoverLoop = nil
local teleportNoclipEnabled = false

local function hoverToTeleportPosition(targetPos)
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not config.bodyVelocity or not config.bodyGyro then
		return false
	end
	
	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	if distance < 3 then
		config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		return true
	end
	
	local speedMultiplier = math.min(distance / 10, 1)
	local targetSpeed = config.hoverSpeed * speedMultiplier
	
	local desiredVelocity = direction.Unit * targetSpeed
	local currentVelocity = config.bodyVelocity.Velocity
	local newVelocity = currentVelocity:Lerp(desiredVelocity, 0.5)
	
	config.bodyVelocity.Velocity = newVelocity
	
	local lookCFrame = CFrame.new(currentPos, targetPos)
	config.bodyGyro.CFrame = lookCFrame
	
	return false
end

local function startTeleportHover(position, locationName)
	if _G.teleportHoverActive then
		Library:Notify("Already traveling to a location!", 2)
		return
	end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		task.wait(0.1)
	end
	
	_G.teleportHoverActive = true
	
	if not config.noclipLoop then
		funcs.startNoclip()
		teleportNoclipEnabled = true
	end
	
	teleportHoverTarget = position
	
	Library:Notify("Traveling to " .. locationName .. "...", 2)
	
	teleportHoverLoop = RunService.Heartbeat:Connect(function()
		if not _G.teleportHoverActive then
			if teleportHoverLoop then
				teleportHoverLoop:Disconnect()
				teleportHoverLoop = nil
			end
			return
		end
		
		local reached = hoverToTeleportPosition(teleportHoverTarget)
		
		if reached then
			_G.teleportHoverActive = false
			
			if teleportHoverLoop then
				teleportHoverLoop:Disconnect()
				teleportHoverLoop = nil
			end
			
			Library:Notify("Arrived at " .. locationName .. "!", 2)
			
			if not config.enabled and not config.miningEnabled then
				task.wait(0.5)
				
				if teleportNoclipEnabled then
					funcs.stopNoclip()
					teleportNoclipEnabled = false
				end
				
				funcs.cleanupPhysicsMovement()
			end
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- LOAD LINORIA UI LIBRARY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CREATE WINDOW
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Window = Library:CreateWindow({
	Title = "The Forge by Rafso [literalh] | Forgotten Kingdom v1.3.2",
	Center = true,
	AutoShow = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STORE UI REFERENCES GLOBALLY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_G.UIReferences = {
	Window = Window,
	Library = Library,
	Tabs = {},
	Toggles = {},
	Options = {},
}

local Tabs = _G.UIReferences.Tabs
local Toggles = Toggles or {}
local Options = Options or {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOOPS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local attackLoop = nil
local mineLoop = nil
local weaponCheckLoop = nil
local pickaxeCheckLoop = nil
local sellLoop = nil

local function startAutoAttack()
	if attackLoop then return end
	
	task.spawn(function()
		task.wait(0.5)
		funcs.autoEquipWeapon()
	end)
	
	attackLoop = RunService.Heartbeat:Connect(function()
		if not config.enabled then return end
		funcs.performAttack()
	end)
	
	if not weaponCheckLoop then
		weaponCheckLoop = RunService.Heartbeat:Connect(function()
			if not config.enabled then return end
			local currentTime = tick()
			if currentTime - config.lastWeaponCheckTime >= config.weaponCheckInterval then
				config.lastWeaponCheckTime = currentTime
				funcs.autoEquipWeapon()
			end
		end)
	end
end

local function stopAutoAttack()
	if attackLoop then
		attackLoop:Disconnect()
		attackLoop = nil
	end
	if weaponCheckLoop then
		weaponCheckLoop:Disconnect()
		weaponCheckLoop = nil
	end
end

local function startAutoMine()
	if mineLoop then return end
	
	task.spawn(function()
		task.wait(0.3)
		funcs.autoEquipPickaxe()
	end)
	
mineLoop = RunService.Heartbeat:Connect(function()
	if not config.miningEnabled then return end
	if config.defendingAgainstMob then return end  -- âœ… ADD THIS LINE
	funcs.performMine()
end)
	
	if not pickaxeCheckLoop then
		pickaxeCheckLoop = RunService.Heartbeat:Connect(function()
			if not config.miningEnabled then return end
			if config.defendingAgainstMob then return end  -- âœ… ADD THIS LINE
			local currentTime = tick()
			if currentTime - config.lastPickaxeCheckTime >= config.pickaxeCheckInterval then
				config.lastPickaxeCheckTime = currentTime
				funcs.autoEquipPickaxe()
			end
		end)
	end
end

local function stopAutoMine()
	if mineLoop then
		mineLoop:Disconnect()
		mineLoop = nil
	end
	if pickaxeCheckLoop then
		pickaxeCheckLoop:Disconnect()
		pickaxeCheckLoop = nil
	end
end

local function startAutoSell()
	if sellLoop then return end
	
	sellLoop = RunService.Heartbeat:Connect(function()
		if not config.autoSellEnabled then return end
		funcs.sellItems()
	end)
end

local function stopAutoSell()
	if sellLoop then
		sellLoop:Disconnect()
		sellLoop = nil
	end
end

_G.AutoLoopFunctions = {
	startAutoAttack = startAutoAttack,
	stopAutoAttack = stopAutoAttack,
	startAutoMine = startAutoMine,
	stopAutoMine = stopAutoMine,
	startAutoSell = startAutoSell,
	stopAutoSell = stopAutoSell,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CREATE TABS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Tabs.Info = Window:AddTab('Info')
Tabs.Farming = Window:AddTab('Mobs')
Tabs.Mining = Window:AddTab('Mine')
Tabs.AutoSell = Window:AddTab('Sell')
Tabs.Teleport = Window:AddTab('Teleport')
Tabs.Settings = Window:AddTab('Settings')
Tabs.Configs = Window:AddTab('Config')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INFO TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local InfoLeftBox = Tabs.Info:AddLeftGroupbox('Script Information')

InfoLeftBox:AddLabel('World 2: Forgotten Kingdom')
InfoLeftBox:AddLabel('Tested on Xeno')
InfoLeftBox:AddLabel('Created by Rafso [literalh]')
InfoLeftBox:AddDivider()

InfoLeftBox:AddLabel('Script Features:')
InfoLeftBox:AddLabel('â€¢ Auto-Farm ')
InfoLeftBox:AddLabel('â€¢ Auto-Mine')
InfoLeftBox:AddLabel('â€¢ Auto-Sell')
InfoLeftBox:AddLabel('â€¢ Teleports')
InfoLeftBox:AddLabel('â€¢ Config System')

local InfoRightBox = Tabs.Info:AddRightGroupbox('Tips')

InfoRightBox:AddLabel('â€¢ [Lifesteal] needed if')
InfoRightBox:AddLabel('  Lava Check')
InfoRightBox:AddLabel('â€¢ Manually press Talk to Buyer')
InfoRightBox:AddLabel('  if not automatically done')
InfoRightBox:AddLabel('â€¢ This Script is in BETA')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FARMING TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FarmingGroupBox = Tabs.Farming:AddLeftGroupbox('Mob Farming')

FarmingGroupBox:AddToggle('FarmToggle', {
	Text = 'Enable Mob Farming (F1)',
	Default = false,
	Tooltip = 'Toggle mob farming on/off',
	Callback = function(Value)
		config.enabled = Value
		
		if config.enabled then
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
					config.hoverSequenceActive = true
					config.currentHoverTarget = 1
				end
			end
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			startAutoAttack()
		else
			-- âœ… NEW: Teleport up when disabling
			teleportUp(TELEPORT_UP_DISTANCE)
			task.wait(0.1)
			
			config.hoverSequenceActive = false
			config.currentMob = nil
			stopAutoAttack()
			funcs.stopNoclip()
			funcs.cleanupPhysicsMovement()
		end
	end
})

FarmingGroupBox:AddDivider()

FarmingGroupBox:AddDropdown('LockPosition', {
	Values = {'Back', 'Front', 'Above', 'Below'},
	Default = 1,
	Multi = false,
	Text = 'Lock Position',
	Tooltip = 'Choose where to position yourself relative to the mob',
	Callback = function(Value)
		config.lockPosition = Value
	end
})

FarmingGroupBox:AddDivider()

local mobOptions = {}
for i, mobData in ipairs(config.mobTypes) do
	table.insert(mobOptions, mobData.name)
end

FarmingGroupBox:AddLabel('Select Mobs to Farm:')

FarmingGroupBox:AddDropdown('MobSelection', {
	Values = mobOptions,
	Default = 1,
	Multi = true,
	Tooltip = 'Choose which mobs to farm',
	Callback = function(Value)
		for i, mobData in ipairs(config.mobTypes) do
			config.mobTypes[i].enabled = false
		end
		
		for mobName, isEnabled in pairs(Value) do
			if isEnabled then
				for i, mobData in ipairs(config.mobTypes) do
					if mobData.name == mobName then
						config.mobTypes[i].enabled = true
						break
					end
				end
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING TAB (WITH WANTED ORES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MiningGroupBox = Tabs.Mining:AddLeftGroupbox('Mining')

MiningGroupBox:AddToggle('MineToggle', {
	Text = 'Enable Mining (F2)',
	Default = false,
	Tooltip = 'Toggle mining on/off',
	Callback = function(Value)
		config.miningEnabled = Value
		
		if config.miningEnabled then
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.rockDurabilityCheck = tick()
			config.currentRock = nil
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
					config.hoverSequenceActive = true
					config.currentHoverTarget = 1
				end
			end
			
			funcs.setupPhysicsMovement()
			funcs.startNoclip()
			startAutoMine()
		else
			-- âœ… NEW: Teleport up when disabling
			teleportUp(TELEPORT_UP_DISTANCE)
			task.wait(0.1)
			
			config.hoverSequenceActive = false
			config.currentHoverTarget = 1
			config.currentRock = nil
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.isLockedOn = false
			config.idleHoverActive = false
			config.idleHoverTimer = 0
			config.idleHoverDelay = 3
			
			stopAutoMine()
			funcs.stopNoclip()
			funcs.cleanupPhysicsMovement()
			
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					rootPart.Velocity = Vector3.new(0, 0, 0)
					rootPart.Anchored = false
				end
			end
		end
	end
})

MiningGroupBox:AddDivider()

local rockOptions = {}
for i, rockData in ipairs(config.rockTypes) do
	table.insert(rockOptions, rockData.name)
end

MiningGroupBox:AddLabel('Select Rocks to Mine:')

MiningGroupBox:AddDropdown('RockSelection', {
	Values = rockOptions,
	Default = 1,
	Multi = true,
	Tooltip = 'Choose which rocks to mine',
	Callback = function(Value)
		for i, rockData in ipairs(config.rockTypes) do
			config.rockTypes[i].enabled = false
		end
		
		for rockName, isEnabled in pairs(Value) do
			if isEnabled then
				for i, rockData in ipairs(config.rockTypes) do
					if rockData.name == rockName then
						config.rockTypes[i].enabled = true
						break
					end
				end
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NEW: ORE FILTER UI
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MiningGroupBox:AddDivider()

MiningGroupBox:AddToggle('OreFilterToggle', {
	Text = 'Enable Ore Filter',
	Default = false,
	Tooltip = 'Only mine rocks that contain selected ores',
	Callback = function(Value)
		config.oreFilterEnabled = Value
		
		if Value then
			Library:Notify("Ore Filter ON - Mining only selected ores", 3)
		else
			Library:Notify("Ore Filter OFF - Mining all rocks", 3)
		end
	end
})

MiningGroupBox:AddDropdown('OreSelection', {
	Values = config.availableOres,
	Default = 1,
	Multi = true,
	Text = 'Wanted Ores',
	Tooltip = 'Choose which ores you want to mine for',
	Callback = function(Value)
		config.selectedOres = {}
		
		for oreName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedOres, oreName)
			end
		end
		
		print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		print("ğŸ¯ Selected Ores:")
		for _, ore in ipairs(config.selectedOres) do
			print("   â€¢ " .. ore)
		end
		print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	end
})

_G.UIReferences.mobOptions = mobOptions
_G.UIReferences.rockOptions = rockOptions

-- Store teleportUp globally
funcs.teleportUp = teleportUp

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 6: AUTOSELL, TELEPORT (HOVER), SETTINGS & CONFIG (FIXED KEYBINDS + DEFENSE)
-- âœ… FIXED: Mining Vertical Distance slider + Defense Lock Position controls
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions
local configFuncs = _G.ConfigFunctions
local autoLoopFuncs = _G.AutoLoopFunctions

local uiRefs = _G.UIReferences
local Window = uiRefs.Window
local Library = uiRefs.Library
local Tabs = uiRefs.Tabs

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTOSELL TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AutoSellGroupBox = Tabs.AutoSell:AddLeftGroupbox('Auto Sell')

AutoSellGroupBox:AddToggle('AutoSellToggle', {
	Text = 'Enable Auto Sell',
	Default = false,
	Tooltip = 'Automatically sell selected items',
	Callback = function(Value)
		config.autoSellEnabled = Value
		
		if config.autoSellEnabled then
			autoLoopFuncs.startAutoSell()
		else
			autoLoopFuncs.stopAutoSell()
		end
	end
})

AutoSellGroupBox:AddDivider()

AutoSellGroupBox:AddButton({
	Text = 'Talk to Buyer',
	Func = function()
		local success = funcs.talkToSeller()
		
		if success then
			Library:Notify("Successfully talked to buyer!", 3)
		else
			Library:Notify("Failed to talk to buyer!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Teleport to buyer and open dialogue'
})

local ItemSelectionGroupBox = Tabs.AutoSell:AddRightGroupbox('Item Selection')

ItemSelectionGroupBox:AddLabel('Select Items to Auto Sell:')

ItemSelectionGroupBox:AddDropdown('CommonItems', {
	Values = ItemsByRarity.Common,
	Default = 1,
	Multi = true,
	Text = 'Common Items',
	Tooltip = 'Select common items to sell',
	Callback = function(Value)
		config.selectedItems.Common = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Common, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('UncommonItems', {
	Values = ItemsByRarity.Uncommon,
	Default = 1,
	Multi = true,
	Text = 'Uncommon Items',
	Tooltip = 'Select uncommon items to sell',
	Callback = function(Value)
		config.selectedItems.Uncommon = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Uncommon, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('RareItems', {
	Values = ItemsByRarity.Rare,
	Default = 1,
	Multi = true,
	Text = 'Rare Items',
	Tooltip = 'Select rare items to sell',
	Callback = function(Value)
		config.selectedItems.Rare = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Rare, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('EpicItems', {
	Values = ItemsByRarity.Epic,
	Default = 1,
	Multi = true,
	Text = 'Epic Items',
	Tooltip = 'Select epic items to sell',
	Callback = function(Value)
		config.selectedItems.Epic = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Epic, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('LegendaryItems', {
	Values = ItemsByRarity.Legendary,
	Default = 1,
	Multi = true,
	Text = 'Legendary Items',
	Tooltip = 'Select legendary items to sell',
	Callback = function(Value)
		config.selectedItems.Legendary = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Legendary, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('MythicalItems', {
	Values = ItemsByRarity.Mythical,
	Default = 1,
	Multi = true,
	Text = 'Mythical Items',
	Tooltip = 'Select mythical items to sell',
	Callback = function(Value)
		config.selectedItems.Mythical = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Mythical, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('RuneItems', {
	Values = ItemsByRarity.Rune,
	Default = 1,
	Multi = true,
	Text = 'Rune Items',
	Tooltip = 'Select rune items to sell',
	Callback = function(Value)
		config.selectedItems.Rune = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Rune, itemName)
			end
		end
	end
})

ItemSelectionGroupBox:AddDropdown('EssenceItems', {
	Values = ItemsByRarity.Essence,
	Default = 1,
	Multi = true,
	Text = 'Essence Items',
	Tooltip = 'Select essence items to sell',
	Callback = function(Value)
		config.selectedItems.Essence = {}
		for itemName, isEnabled in pairs(Value) do
			if isEnabled then
				table.insert(config.selectedItems.Essence, itemName)
			end
		end
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT TAB (USING HOVER SYSTEM)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TeleportAreasBox = Tabs.Teleport:AddLeftGroupbox('Areas')

local areaOptions = {}
for areaName, _ in pairs(teleportAreas) do
	table.insert(areaOptions, areaName)
end
table.sort(areaOptions)

TeleportAreasBox:AddLabel('Select an Area:')

TeleportAreasBox:AddDropdown('AreaSelection', {
	Values = areaOptions,
	Default = 1,
	Multi = false,
	Tooltip = 'Choose an area to teleport to',
	Callback = function(Value)
		selectedArea = Value
	end
})

TeleportAreasBox:AddDivider()

TeleportAreasBox:AddButton({
	Text = 'Travel to Area',
	Func = function()
		if not selectedArea or selectedArea == "" then
			Library:Notify("Please select an area first!", 3)
			return
		end
		
		local position = teleportAreas[selectedArea]
		if position then
			startTeleportHover(position, selectedArea)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Hover travel to the selected area'
})

local TeleportNPCsBox = Tabs.Teleport:AddRightGroupbox('NPCs')

local npcOptions = {}
for npcName, _ in pairs(teleportNPCs) do
	table.insert(npcOptions, npcName)
end
table.sort(npcOptions)

TeleportNPCsBox:AddLabel('Select a NPC:')

TeleportNPCsBox:AddDropdown('NPCSelection', {
	Values = npcOptions,
	Default = 1,
	Multi = false,
	Tooltip = 'Choose a NPC to teleport to',
	Callback = function(Value)
		selectedNPC = Value
	end
})

TeleportNPCsBox:AddDivider()

TeleportNPCsBox:AddButton({
	Text = 'Travel to NPC',
	Func = function()
		if not selectedNPC or selectedNPC == "" then
			Library:Notify("Please select an NPC first!", 3)
			return
		end
		
		local position = teleportNPCs[selectedNPC]
		if position then
			startTeleportHover(position, selectedNPC)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Hover travel to the selected NPC'
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'K', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

MenuGroup:AddDivider()

MenuGroup:AddButton({
	Text = 'Destroy GUI',
	Func = function()
		if Toggles.FarmToggle then Toggles.FarmToggle:SetValue(false) end
		if Toggles.MineToggle then Toggles.MineToggle:SetValue(false) end
		if Toggles.AutoSellToggle then Toggles.AutoSellToggle:SetValue(false) end
		
		task.wait(0.5)
		
		if _G.KeybindConnection then
			_G.KeybindConnection:Disconnect()
			_G.KeybindConnection = nil
		end
		
		autoLoopFuncs.stopAutoAttack()
		autoLoopFuncs.stopAutoMine()
		autoLoopFuncs.stopAutoSell()
		funcs.stopNoclip()
		funcs.cleanupPhysicsMovement()
		
		_G.MobFarmConfig = nil
		_G.FarmFunctions = nil
		_G.AutoLoopFunctions = nil
		_G.ConfigFunctions = nil
		_G.UIReferences = nil
		
		Library:Unload()
		print("âœ… GUI Destroyed - All systems stopped")
	end,
	DoubleClick = false,
	Tooltip = 'Close and destroy the GUI'
})

local GeneralSettingsBox = Tabs.Settings:AddRightGroupbox('General Settings')

GeneralSettingsBox:AddSlider('HoverSpeed', {
	Text = 'Hover Speed',
	Default = 80,
	Min = 20,
	Max = 140,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.hoverSpeed = Value
	end
})

local FarmSettingsBox = Tabs.Settings:AddRightGroupbox('Farm Settings')

FarmSettingsBox:AddSlider('VerticalDistance', {
	Text = 'Vertical Distance',
	Default = 8,
	Min = 1,
	Max = 20,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.verticalDistance = Value
	end
})

FarmSettingsBox:AddToggle('LavaCheck', {
	Text = 'Lava Check',
	Default = true,
	Tooltip = 'Auto-switch to Above position when taking lava damage (Below position only)',
	Callback = function(Value)
		config.lavaCheckEnabled = Value
		
		if not Value then
			if config.savedLockPosition == "Below" then
				print("ğŸ”„ Lava Check disabled - Resetting to Below")
				config.lockPosition = "Below"
				config.savedLockPosition = nil
				config.inLavaMode = false
				config.farmingLastHealth = nil
			else
				config.inLavaMode = false
				config.farmingLastHealth = nil
				config.savedLockPosition = nil
			end
		end
	end
})

local MiningSettingsBox = Tabs.Settings:AddRightGroupbox('Mining Settings')

-- âœ… FIXED: Mining Vertical Distance slider now updates base value
MiningSettingsBox:AddSlider('MiningVerticalDistance', {
	Text = 'Mining Vertical Distance',
	Default = 6,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.miningVerticalDistance = Value
		config.normalMiningDistance = Value  -- âœ… FIX: Update the base value too
		print("âš™ï¸ Mining Vertical Distance set to: " .. Value)
	end
})

MiningSettingsBox:AddToggle('IgnoreGoblinCave', {
	Text = 'Ignore Goblin Cave Rocks',
	Default = true,
	Tooltip = 'Skip rocks in the goblin cave',
	Callback = function(Value)
		config.ignoreGoblinCave = Value
	end
})

MiningSettingsBox:AddToggle('AvoidOccupied', {
	Text = 'Avoid Occupied Rocks',
	Default = true,
	Tooltip = 'Skip rocks that other players are mining',
	Callback = function(Value)
		config.avoidOccupied = Value
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NEW: DEFENSE SYSTEM CONTROLS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MiningSettingsBox:AddDivider()
MiningSettingsBox:AddLabel('Defense Settings:')

MiningSettingsBox:AddDropdown('DefenseLockPosition', {
	Values = {'Back', 'Front', 'Above', 'Below'},
	Default = 4,  -- Default to "Below"
	Multi = false,
	Text = 'Defense Lock Position',
	Tooltip = 'Position relative to mob when defending while mining',
	Callback = function(Value)
		config.defenseLockPosition = Value
		print("ğŸ›¡ï¸ Defense Lock Position: " .. Value)
	end
})

MiningSettingsBox:AddSlider('DefenseVerticalDistance', {
	Text = 'Defense Vertical Distance',
	Default = 6,
	Min = 1,
	Max = 10,
	Rounding = 0,
	Compact = false,
	Callback = function(Value)
		config.miningDefenseVerticalDistance = Value
		print("ğŸ›¡ï¸ Defense Vertical Distance: " .. Value)
	end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFIG MANAGEMENT & KEYBIND SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ConfigManagementBox = Tabs.Configs:AddLeftGroupbox('Config Management')

local selectedConfig = nil

ConfigManagementBox:AddInput('ConfigName', {
	Default = '',
	Numeric = false,
	Finished = false,
	Text = 'Config Name',
	Tooltip = 'Enter a name for your config',
	Placeholder = 'Enter config name...',
})

ConfigManagementBox:AddDropdown('ConfigSelector', {
	Values = configFuncs.getConfigList(),
	Default = 1,
	Multi = false,
	Text = 'Select Config',
	Tooltip = 'Choose a config to load/delete',
	Callback = function(Value)
		selectedConfig = Value
	end
})

ConfigManagementBox:AddDivider()

ConfigManagementBox:AddButton({
	Text = 'Refresh Configs',
	Func = function()
		local configList = configFuncs.getConfigList()
		Options.ConfigSelector:SetValues(configList)
		Library:Notify("Found " .. #configList .. " config(s)", 2)
	end,
	DoubleClick = false,
	Tooltip = 'Refresh the config list'
})

ConfigManagementBox:AddButton({
	Text = 'Create Config',
	Func = function()
		local configName = Options.ConfigName.Value
		
		if configName == "" or configName == nil then
			Library:Notify("Please enter a config name!", 3)
			return
		end
		
		configName = configName:gsub("%s+", "_")
		
		local success = configFuncs.saveConfig(configName)
		
		if success then
			Library:Notify("Config '" .. configName .. "' created!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			Options.ConfigSelector:SetValue(configName)
			selectedConfig = configName
			
			Options.ConfigName:SetValue("")
		else
			Library:Notify("Failed to create config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Create a new config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Load Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.loadConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' loaded!", 3)
			
			task.wait(0.2)
			
			Toggles.FarmToggle:SetValue(config.enabled)
			Toggles.MineToggle:SetValue(config.miningEnabled)
			Toggles.AutoSellToggle:SetValue(config.autoSellEnabled)
			Toggles.LavaCheck:SetValue(config.lavaCheckEnabled)
			Toggles.AvoidOccupied:SetValue(config.avoidOccupied)
			Options.HoverSpeed:SetValue(config.hoverSpeed)
			Options.VerticalDistance:SetValue(config.verticalDistance)
			Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
			
			-- âœ… NEW: Load defense settings
			Options.DefenseLockPosition:SetValue(config.defenseLockPosition)
			Options.DefenseVerticalDistance:SetValue(config.miningDefenseVerticalDistance)
			
			Toggles.IgnoreGoblinCave:SetValue(config.ignoreGoblinCave)
			
			-- âœ… NEW: Load ore filter settings
			Toggles.OreFilterToggle:SetValue(config.oreFilterEnabled)
			
			local selectedOresDict = {}
			for _, oreName in ipairs(config.selectedOres) do
				selectedOresDict[oreName] = true
			end
			Options.OreSelection:SetValue(selectedOresDict)
			
			Options.LockPosition:SetValue(config.lockPosition)
			
			local enabledMobs = {}
			for _, mobData in ipairs(config.mobTypes) do
				if mobData.enabled then
					enabledMobs[mobData.name] = true
				end
			end
			Options.MobSelection:SetValue(enabledMobs)
			
			local enabledRocks = {}
			for _, rockData in ipairs(config.rockTypes) do
				if rockData.enabled then
					enabledRocks[rockData.name] = true
				end
			end
			Options.RockSelection:SetValue(enabledRocks)
			
			local commonItems = {}
			for _, item in ipairs(config.selectedItems.Common or {}) do
				commonItems[item] = true
			end
			Options.CommonItems:SetValue(commonItems)
			
			local uncommonItems = {}
			for _, item in ipairs(config.selectedItems.Uncommon or {}) do
				uncommonItems[item] = true
			end
			Options.UncommonItems:SetValue(uncommonItems)
			
			local rareItems = {}
			for _, item in ipairs(config.selectedItems.Rare or {}) do
				rareItems[item] = true
			end
			Options.RareItems:SetValue(rareItems)
			
			local epicItems = {}
			for _, item in ipairs(config.selectedItems.Epic or {}) do
				epicItems[item] = true
			end
			Options.EpicItems:SetValue(epicItems)
			
			local legendaryItems = {}
			for _, item in ipairs(config.selectedItems.Legendary or {}) do
				legendaryItems[item] = true
			end
			Options.LegendaryItems:SetValue(legendaryItems)
			
			local mythicalItems = {}
			for _, item in ipairs(config.selectedItems.Mythical or {}) do
				mythicalItems[item] = true
			end
			Options.MythicalItems:SetValue(mythicalItems)
			
			local runeItems = {}
			for _, item in ipairs(config.selectedItems.Rune or {}) do
				runeItems[item] = true
			end
			Options.RuneItems:SetValue(runeItems)

			local essenceItems = {}
			for _, item in ipairs(config.selectedItems.Essence or {}) do
				essenceItems[item] = true
			end
			Options.EssenceItems:SetValue(essenceitems)
		else
			Library:Notify("Failed to load config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Load the selected config'
})

ConfigManagementBox:AddButton({
	Text = 'Overwrite Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local success = configFuncs.saveConfig(selectedConfig)
		
		if success then
			Library:Notify("Config '" .. selectedConfig .. "' overwritten!", 3)
		else
			Library:Notify("Failed to overwrite config!", 3)
		end
	end,
	DoubleClick = false,
	Tooltip = 'Overwrite selected config with current settings'
})

ConfigManagementBox:AddButton({
	Text = 'Set as Autoload',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		configFuncs.setAutoload(selectedConfig)
		Library:Notify("Config '" .. selectedConfig .. "' set as autoload!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'This config will load automatically on startup'
})

ConfigManagementBox:AddButton({
	Text = 'Destroy Config',
	Func = function()
		if not selectedConfig or selectedConfig == "" then
			Library:Notify("Please select a config first!", 3)
			return
		end
		
		local configToDelete = selectedConfig
		local success = configFuncs.deleteConfig(configToDelete)
		
		if success then
			Library:Notify("Config '" .. configToDelete .. "' deleted!", 3)
			
			local configList = configFuncs.getConfigList()
			Options.ConfigSelector:SetValues(configList)
			selectedConfig = nil
		else
			Library:Notify("Failed to delete config!", 3)
		end
	end,
	DoubleClick = true,
	Tooltip = 'Double-click to delete the selected config'
})

local DebugBox = Tabs.Configs:AddRightGroupbox('Config')

DebugBox:AddButton({
	Text = 'Print Current Config',
	Func = function()
		configFuncs.debugCurrentConfig()
		Library:Notify("Config info copied to clipboard!", 3)
	end,
	DoubleClick = false,
	Tooltip = 'Copy current config state to clipboard'
})

local autoloadConfig = configFuncs.getAutoload()
if autoloadConfig then
	DebugBox:AddLabel('Autoload: ' .. autoloadConfig)
else
	DebugBox:AddLabel('Autoload: None')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOAD CONFIG ON STARTUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(3)
	
	local autoloadName = configFuncs.getAutoload()
	if autoloadName then
		local success = configFuncs.loadConfig(autoloadName)
		
		if success then
			task.wait(0.5)
			
			Toggles.FarmToggle:SetValue(config.enabled)
			Toggles.MineToggle:SetValue(config.miningEnabled)
			Toggles.AutoSellToggle:SetValue(config.autoSellEnabled)
			Toggles.LavaCheck:SetValue(config.lavaCheckEnabled)
			Toggles.AvoidOccupied:SetValue(config.avoidOccupied)
			
			Options.HoverSpeed:SetValue(config.hoverSpeed)
			Options.VerticalDistance:SetValue(config.verticalDistance)
			Options.MiningVerticalDistance:SetValue(config.miningVerticalDistance)
			
			-- âœ… NEW: Load defense settings
			Options.DefenseLockPosition:SetValue(config.defenseLockPosition)
			Options.DefenseVerticalDistance:SetValue(config.miningDefenseVerticalDistance)
			
			Toggles.IgnoreGoblinCave:SetValue(config.ignoreGoblinCave)
			
			-- âœ… NEW: Load ore filter settings
			Toggles.OreFilterToggle:SetValue(config.oreFilterEnabled)
			
			local selectedOresDict = {}
			for _, oreName in ipairs(config.selectedOres) do
				selectedOresDict[oreName] = true
			end
			Options.OreSelection:SetValue(selectedOresDict)

			Options.LockPosition:SetValue(config.lockPosition)
			
			local enabledMobs = {}
			for _, mobData in ipairs(config.mobTypes) do
				if mobData.enabled then
					enabledMobs[mobData.name] = true
				end
			end
			Options.MobSelection:SetValue(enabledMobs)
			
			local enabledRocks = {}
			for _, rockData in ipairs(config.rockTypes) do
				if rockData.enabled then
					enabledRocks[rockData.name] = true
				end
			end
			Options.RockSelection:SetValue(enabledRocks)
			
			local commonItems = {}
			for _, item in ipairs(config.selectedItems.Common or {}) do
				commonItems[item] = true
			end
			Options.CommonItems:SetValue(commonItems)
			
			local uncommonItems = {}
			for _, item in ipairs(config.selectedItems.Uncommon or {}) do
				uncommonItems[item] = true
			end
			Options.UncommonItems:SetValue(uncommonItems)
			
			local rareItems = {}
			for _, item in ipairs(config.selectedItems.Rare or {}) do
				rareItems[item] = true
			end
			Options.RareItems:SetValue(rareItems)
			
			local epicItems = {}
			for _, item in ipairs(config.selectedItems.Epic or {}) do
				epicItems[item] = true
			end
			Options.EpicItems:SetValue(epicItems)
			
			local legendaryItems = {}
			for _, item in ipairs(config.selectedItems.Legendary or {}) do
				legendaryItems[item] = true
			end
			Options.LegendaryItems:SetValue(legendaryItems)
			
			local mythicalItems = {}
			for _, item in ipairs(config.selectedItems.Mythical or {}) do
				mythicalItems[item] = true
			end
			Options.MythicalItems:SetValue(mythicalItems)
			
			local runeItems = {}
			for _, item in ipairs(config.selectedItems.Rune or {}) do
				runeItems[item] = true
			end
			Options.RuneItems:SetValue(runeItems)
			
			local essenceItems = {}
			for _, item in ipairs(config.selectedItems.Essence or {}) do
				essenceItems[item] = true
			end
			Options.EssenceItems:SetValue(essenceItems)
			
			Library:Notify("Autoload config '" .. autoloadName .. "' loaded!", 4)
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FIXED KEYBIND SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Library:OnUnload(function()
	Library.Unloaded = true
	
	if _G.KeybindConnection then
		_G.KeybindConnection:Disconnect()
		_G.KeybindConnection = nil
	end
end)

local UserInputService = game:GetService("UserInputService")

local function setupKeybinds()
    if _G.KeybindConnection then
        _G.KeybindConnection:Disconnect()
    end
    
    _G.KeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        -- âœ… SAFER: Wait for UI to fully load
        if not getgenv().Toggles then 
            warn("âš ï¸ Toggles not loaded yet!")
            return 
        end
        
        -- âœ… SAFER: Check if config exists
        if not _G.MobFarmConfig then 
            return 
        end
        
        -- Get toggles safely
        local farmToggle = getgenv().Toggles.FarmToggle
        local mineToggle = getgenv().Toggles.MineToggle
        
        -- F1 - Toggle Farming
        if input.KeyCode == Enum.KeyCode.F1 then
            if farmToggle then
                local newValue = not config.enabled
                farmToggle:SetValue(newValue)
                if Library then
                    Library:Notify("Farming: " .. (newValue and "ON" or "OFF"), 2)
                end
            else
                warn("âš ï¸ FarmToggle not found!")
            end
            
        -- F2 - Toggle Mining
        elseif input.KeyCode == Enum.KeyCode.F2 then
            if mineToggle then
                local newValue = not config.miningEnabled
                mineToggle:SetValue(newValue)
                if Library then
                    Library:Notify("Mining: " .. (newValue and "ON" or "OFF"), 2)
                end
            else
                warn("âš ï¸ MineToggle not found!")
            end
        end
    end)
    
    print("âœ… Keybinds initialized: F1 = Farming | F2 = Mining")
end

-- âœ… Wait even longer for full UI initialization
task.spawn(function()
    task.wait(5)  -- Increased from 3 to 5 seconds
    
    -- Verify UI is loaded
    if not getgenv().Toggles or not getgenv().Toggles.FarmToggle then
        warn("âš ï¸ Waiting for UI to fully load...")
        repeat task.wait(0.5) until getgenv().Toggles and getgenv().Toggles.FarmToggle
        task.wait(1)
    end
    
    setupKeybinds()
    print("âœ… Keybinds ready!")
end)

local ThemeManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/addons/ThemeManager.lua'))()
ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder('RafsoHub')
ThemeManager:ApplyToTab(Tabs.Settings)

print("âœ… Part 6 loaded with Mining Distance FIX + Defense Controls!")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 7A: LAVA CHECK + 0 HP ROCK CHECK (NO WANTED ORES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)
local SKIP_HOVER_DISTANCE = 150

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NEW: SIMPLE 0 HP CHECK (CHECKS EVERY 0.2 SECONDS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

config.lastRockHPCheckTime = 0
config.rockHPCheckInterval = 0.1  -- Check every 0.2 seconds

local function isRockAtZeroHP(rock)
	if not rock or not rock.Parent then return false end
	
	local rockTypeModel = rock.Parent
	if not rockTypeModel then return false end
	
	local infoFrame = rockTypeModel:FindFirstChild("infoFrame")
	if not infoFrame then return false end
	
	local frame = infoFrame:FindFirstChild("Frame")
	if not frame then return false end
	
	local rockHP = frame:FindFirstChild("rockHP")
	if not rockHP or not rockHP:IsA("TextBox") then return false end
	
	local hpText = rockHP.Text
	if not hpText or hpText == "" then return false end
	
	print("ğŸ” Checking HP text: '" .. hpText .. "'")  -- Debug
	
	-- Check if it contains "0 HP" or starts with "0"
	if hpText == "0 HP" or hpText == "0" or hpText:find("^0%s") or hpText:find("^0/") then
		print("âœ… MATCH FOUND - Rock is at 0 HP!")
		return true
	end
	
	return false
end

local function checkCurrentRockHP()
	if not config.miningEnabled then return end
	if not config.currentRock then return end
	if config.defendingAgainstMob then return end
	
	local currentTime = tick()
	if currentTime - config.lastRockHPCheckTime < config.rockHPCheckInterval then
		return
	end
	
	config.lastRockHPCheckTime = currentTime
	
	-- Get HP
	local rockTypeModel = config.currentRock.Parent
	if rockTypeModel then
		local infoFrame = rockTypeModel:FindFirstChild("infoFrame")
		if infoFrame then
			local frame = infoFrame:FindFirstChild("Frame")
			if frame then
				local rockHP = frame:FindFirstChild("rockHP")
				if rockHP and rockHP.Text == "0 HP" then
					print("ğŸ’€ ROCK AT 0 HP - CLEARING!")
					
					-- âœ… Add to ignored list so we don't pick it again
					table.insert(config.ignoredRocks, config.currentRock)
					
					config.currentRock = nil
					config.currentRockModel = nil
					config.currentRockId = nil
					config.lastRockDurability = nil
					config.isLockedOn = false
				end
			end
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING DEFENSE CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

config.miningDefenseEnabled = true
config.miningDefenseDistance = 15
config.miningDefenseVerticalDistance = 6
config.defendingAgainstMob = nil
config.savedMiningRock = nil
config.weaponEquipped = false
config.lastDefenseAttackTime = 0
config.defenseAttackCooldown = 0.1

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… UNIFIED LAVA CHECK CONFIG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

config.lavaCheckEnabled = true
config.lastHealth = nil
config.farmingLastHealth = nil
config.inLavaMode = false
config.farmingInLavaMode = false
config.currentRockModel = nil
config.lavaCheckCooldown = false
config.lavaCooldownTime = 0.5

config.normalMiningDistance = 6
config.normalMiningAngle = 270
config.lavaMiningDistance = 6
config.lavaMiningAngle = 90

config.normalFarmingPosition = "Below"
config.savedFarmingPosition = nil

config.currentRockId = nil
config.currentMobId = nil

config.lastTrackedMob = nil

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- LAVA CHECK FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function resetMiningLavaMode()
	if config.inLavaMode then
		config.inLavaMode = false
		config.miningVerticalDistance = config.normalMiningDistance
		config.miningAngle = config.normalMiningAngle
		
		print("ğŸ”„ Mining lava mode RESET - Back to BELOW")
		
		local character = LocalPlayer.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then 
				config.lastHealth = humanoid.Health 
			end
		end
	end
end

local function resetFarmingLavaMode()
	if config.farmingInLavaMode and config.savedFarmingPosition then
		config.farmingInLavaMode = false
		config.lockPosition = config.savedFarmingPosition
		config.savedFarmingPosition = nil
		
		print("ğŸ”„ Farming lava mode RESET - Back to " .. config.lockPosition)
		
		local character = LocalPlayer.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then 
				config.farmingLastHealth = humanoid.Health 
			end
		end
	end
end

local function checkFarmingLavaDamage()
	if not config.enabled then return end
	if not config.lavaCheckEnabled then return end
	if config.hoverSequenceActive then return end
	if config.lavaCheckCooldown then return end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	
	local currentHealth = humanoid.Health
	
	if not config.farmingLastHealth then
		config.farmingLastHealth = currentHealth
		return
	end
	
	local healthDiff = config.farmingLastHealth - currentHealth
	
	if healthDiff > 0 and not config.farmingInLavaMode then
		config.farmingInLavaMode = true
		
		if not config.savedFarmingPosition then
			config.savedFarmingPosition = config.lockPosition
		end
		
		config.lockPosition = "Above"
		
		config.lavaCheckCooldown = true
		task.delay(config.lavaCooldownTime, function() 
			config.lavaCheckCooldown = false 
		end)
	end
	
	config.farmingLastHealth = currentHealth
end

local function checkLavaDamage()
	if not config.miningEnabled then return end
	if not config.lavaCheckEnabled then return end
	if config.defendingAgainstMob then return end
	if config.lavaCheckCooldown then return end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	
	local currentHealth = humanoid.Health
	
	if not config.lastHealth then
		config.lastHealth = currentHealth
		return
	end
	
	local healthDiff = config.lastHealth - currentHealth
	
	if healthDiff > 0 and not config.inLavaMode then
		config.inLavaMode = true
		
		config.miningVerticalDistance = config.lavaMiningDistance
		config.miningAngle = config.lavaMiningAngle
		
		if config.currentRock then 
			config.currentRockModel = config.currentRock.Parent 
		end
		
		config.lavaCheckCooldown = true
		task.delay(config.lavaCooldownTime, function() 
			config.lavaCheckCooldown = false 
		end)
	end
	
	config.lastHealth = currentHealth
end

local function checkProximityToTarget()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return false end
	
	local currentPos = rootPart.Position
	
	if config.enabled then
		local closestMob = funcs.getClosestMob()
		if closestMob then
			local mobRoot = closestMob:FindFirstChild("HumanoidRootPart")
			if mobRoot and (currentPos - mobRoot.Position).Magnitude <= SKIP_HOVER_DISTANCE then
				return true
			end
		end
	end
	
	if config.miningEnabled then
		local closestRock = funcs.getClosestRock()
		if closestRock then
			local positionPart = funcs.getRockPosition(closestRock)
			if positionPart and (currentPos - positionPart.Position).Magnitude <= SKIP_HOVER_DISTANCE then
				return true
			end
		end
	end
	
	return false
end

local function clickMouseForDefense()
	pcall(function()
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		task.wait(0.01)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MESSAGE DETECTION SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local lastMessageTime = 0
local MESSAGE_COOLDOWN = 0.5

local function switchToNewRock(reason)
	if config.currentRock and config.miningEnabled and not config.defendingAgainstMob then
		table.insert(config.ignoredRocks, config.currentRock)
		config.currentRock = nil
		config.currentRockModel = nil
		config.currentRockId = nil
		config.lastRockDurability = nil
		config.isLockedOn = false
		
		if config.bodyVelocity then 
			config.bodyVelocity.Velocity = Vector3.new(0, 0, 0) 
		end
	end
end

local function setupTextLabelMonitoring()
	local playerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
	if not playerGui then return end
	
	local function monitorTextLabel(textLabel)
		if not textLabel:IsA("TextLabel") then return end
		
		textLabel:GetPropertyChangedSignal("Text"):Connect(function()
			if (tick() - lastMessageTime) < MESSAGE_COOLDOWN then return end
			
			local text = textLabel.Text:lower()
			if text:find("someone else") or text:find("being mined") or text:find("another player") then
				lastMessageTime = tick()
				switchToNewRock("Another player mining")
			end
		end)
	end
	
	for _, gui in pairs(playerGui:GetDescendants()) do monitorTextLabel(gui) end
	playerGui.DescendantAdded:Connect(function(d) task.wait(0.05) monitorTextLabel(d) end)
end

local function setupStarterGuiMonitoring()
	local starterGui = game:GetService("StarterGui")
	local oldSetCore = starterGui.SetCore
	starterGui.SetCore = function(self, ...)
		local args = {...}
		if args[1] == "ChatMakeSystemMessage" or args[1] == "SendNotification" then
			local message = type(args[2]) == "table" and tostring(args[2].Text or ""):lower() or tostring(args[2] or ""):lower()
			if message:find("already mining") or message:find("someone else") or message:find("being mined") then
				switchToNewRock("Notification")
			end
		end
		return oldSetCore(self, ...)
	end
end

task.spawn(function()
	task.wait(1)
	setupTextLabelMonitoring()
	setupStarterGuiMonitoring()
end)

-- Store functions globally for Part 7B
_G.Part7AFunctions = {
	resetMiningLavaMode = resetMiningLavaMode,
	resetFarmingLavaMode = resetFarmingLavaMode,
	checkFarmingLavaDamage = checkFarmingLavaDamage,
	checkLavaDamage = checkLavaDamage,
	checkProximityToTarget = checkProximityToTarget,
	clickMouseForDefense = clickMouseForDefense,
	checkCurrentRockHP = checkCurrentRockHP,  -- âœ… NEW
	isRockAtZeroHP = isRockAtZeroHP,  -- âœ… NEW
}

print("âœ… Part 7A loaded - Simple 0 HP check every 0.2 seconds!")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PART 7B: IMPROVED DEFENSE + LAVA CHECK (FIXED LOCAL VARIABLES)
-- âœ… FIXED: Uses config table instead of local variables to avoid register limit
-- âœ… FIXED: Defense system uses proper lock position from UI dropdown
-- âœ… FIXED: Defense respects vertical distance slider
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local config = _G.MobFarmConfig
local funcs = _G.FarmFunctions
local part7a = _G.Part7AFunctions

local HOVER_HEIGHT = 85
local HOVER_POSITION_2 = Vector3.new(415.61, 86.93, -63.19)

local Living = workspace:WaitForChild("Living")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEFENSE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local defenseAttackLoop = nil

local function performDefenseAttack()
	if not config.defendingAgainstMob then return end
	
	local currentTime = tick()
	-- âœ… ONLY ACTIVATE DEFENSE WHEN LOCKED ONTO ROCK
	if not config.defendingAgainstMob and config.currentRock and config.isLockedOn and (currentTime - config.lastDefenseCheckTime >= config.defenseCheckInterval) then
		return
	end
	
	config.lastDefenseAttackTime = currentTime
	part7a.clickMouseForDefense()
end

local function startDefenseAttack()
	if defenseAttackLoop then return end
	
	print("ğŸ¯ Starting defense attack loop")
	
	defenseAttackLoop = RunService.Heartbeat:Connect(function()
		if not config.defendingAgainstMob or not config.miningEnabled then
			if defenseAttackLoop then
				defenseAttackLoop:Disconnect()
				defenseAttackLoop = nil
			end
			return
		end
		
		performDefenseAttack()
	end)
end

local function stopDefenseAttack()
	if defenseAttackLoop then
		defenseAttackLoop:Disconnect()
		defenseAttackLoop = nil
		print("ğŸ›‘ Stopped defense attack loop")
	end
end
local GuiService = game:GetService("GuiService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = Players.LocalPlayer

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… FIXED: GET DEFENSE LOCK POSITION (NOW USES CONFIG VALUES)
-- NOTIFICATION SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getDefenseLockPosition(mob)
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	if not mobRoot then return nil end
	
	-- âœ… Use config values instead of hardcoded
	local distance = 8  -- Behind/Front distance
	local verticalDist = config.miningDefenseVerticalDistance  -- âœ… USE SLIDER VALUE
	local mobPos = mobRoot.Position
	local targetPos
	
	if config.defenseLockPosition == "Back" then
		local behindOffset = -mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + behindOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
		
	elseif config.defenseLockPosition == "Front" then
		local frontOffset = mobRoot.CFrame.LookVector * distance
		targetPos = mobPos + frontOffset
		targetPos = Vector3.new(targetPos.X, mobPos.Y, targetPos.Z)
		
	elseif config.defenseLockPosition == "Above" then
		targetPos = mobPos + Vector3.new(0, verticalDist, 0)
		
	elseif config.defenseLockPosition == "Below" then
		targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
		
	else
		-- Default to Below
		targetPos = mobPos + Vector3.new(0, -verticalDist, 0)
	end
	
	return targetPos
local function sendNotification(title, text, duration)
	pcall(function()
		game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = title;
			Text = text;
			Duration = duration or 5;
		})
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… HOVER TO MOB FOR DEFENSE (USING FARMING LOCK SYSTEM)
-- AUTO-REJOIN SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function hoverToMobDefense(targetPos, mob)
	local character = LocalPlayer.Character
	if not character then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local mobRoot = mob:FindFirstChild("HumanoidRootPart")
	
	if not rootPart or not mobRoot or not config.bodyVelocity or not config.bodyGyro then
		return
	end
local function setupAutoRejoin()
	sendNotification("Auto-Rejoin", "Auto-Rejoin system enabled!", 3)

	local currentPos = rootPart.Position
	local direction = (targetPos - currentPos)
	local distance = direction.Magnitude
	
	-- âœ… Check if we're locked on
	config.isLockedOn = distance < 8
	
	-- âœ… Special handling for Above/Below positions
	if (config.defenseLockPosition == "Above" or config.defenseLockPosition == "Below") and distance < 3 then
		if distance < 1.5 then
			config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		else
			local followSpeed = 8
			local desiredVelocity = direction.Unit * followSpeed
			config.bodyVelocity.Velocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, 0.1)
		end
		
		if config.defenseLockPosition == "Above" then
			local angle = math.rad(90)  -- Look down
			local downCFrame = CFrame.new(currentPos) * CFrame.Angles(-angle, 0, 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(downCFrame, 0.6)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 50000
		else
			local angle = math.rad(240)  -- Look up (same as farming default)
			local upCFrame = CFrame.new(currentPos) * CFrame.Angles(angle, math.rad(180), 0)
			config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(upCFrame, 0.6)
			config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
			config.bodyGyro.P = 50000
	local function onErrorMessageChanged(errorMessage)
		if errorMessage and errorMessage ~= "" then
			print("Error detected: " .. errorMessage)
			sendNotification("Auto-Rejoin", "Error detected! Rejoining...", 3)
			
			if LocalPlayer then
				wait()
				TeleportService:Teleport(game.PlaceId, LocalPlayer)
			end
end
		return
end

	-- âœ… Dynamic speed based on distance
	local targetSpeed
	if distance < 2 then
		targetSpeed = 5
	elseif distance < 5 then
		targetSpeed = 15
	else
		targetSpeed = config.hoverSpeed * math.min(distance / 10, 1)
	end
	
	local desiredVelocity = direction.Unit * targetSpeed
	
	-- âœ… Dynamic lerp speed
	local lerpSpeed
	if distance < 2 then
		lerpSpeed = 0.2
	elseif distance < 5 then
		lerpSpeed = 0.35
	else
		lerpSpeed = 0.25
	end
	
	local newVelocity = config.bodyVelocity.Velocity:Lerp(desiredVelocity, lerpSpeed)
	config.bodyVelocity.Velocity = newVelocity
	
	-- âœ… Dynamic gyro settings
	local lookCFrame = CFrame.new(currentPos, mobRoot.Position)
	if distance < 5 then
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.7)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 60000
		config.bodyGyro.D = 1500
	else
		config.bodyGyro.CFrame = config.bodyGyro.CFrame:Lerp(lookCFrame, 0.4)
		config.bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
		config.bodyGyro.P = 30000
		config.bodyGyro.D = 1000
	end
	GuiService.ErrorMessageChanged:Connect(onErrorMessageChanged)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WEAPON/PICKAXE MANAGEMENT (WITH COOLDOWN)
-- ANTI-AFK SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

config.lastWeaponSwitchTime = 0
config.weaponSwitchCooldown = 1.0  -- 1 second cooldown between switches

local function forceEquipWeapon()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return false end
	
	local weaponInChar = character:FindFirstChild("Weapon")
	if weaponInChar and weaponInChar:IsA("Tool") then
		return true
	end
	
	-- âœ… Check cooldown before switching
	local currentTime = tick()
	if currentTime - config.lastWeaponSwitchTime < config.weaponSwitchCooldown then
		return false
	end
	
	humanoid:UnequipTools()
	task.wait(0.25)
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local weapon = backpack:FindFirstChild("Weapon")
		if weapon and weapon:IsA("Tool") then
			humanoid:EquipTool(weapon)
			task.wait(0.3)
			config.lastWeaponSwitchTime = tick()  -- âœ… Update cooldown
			print("âš”ï¸ WEAPON EQUIPPED")
			return true
		end
	end
	
	return false
end

local function forceEquipPickaxe()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return false end
local function setupAntiAFK()
	sendNotification("Anti-AFK", "Anti-AFK system enabled!", 3)

	local pickaxeInChar = character:FindFirstChild("Pickaxe")
	if pickaxeInChar and pickaxeInChar:IsA("Tool") then
		return true
	end
	
	-- âœ… Check cooldown before switching
	local currentTime = tick()
	if currentTime - config.lastWeaponSwitchTime < config.weaponSwitchCooldown then
		return false
	end
	
	humanoid:UnequipTools()
	task.wait(0.25)
	-- Connection to prevent AFK kick
	LocalPlayer.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
		print("Anti-AFK: Prevented idle kick")
	end)

	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		local pickaxe = backpack:FindFirstChild("Pickaxe")
		if pickaxe and pickaxe:IsA("Tool") then
			humanoid:EquipTool(pickaxe)
			task.wait(0.3)
			config.lastWeaponSwitchTime = tick()  -- âœ… Update cooldown
			print("â›ï¸ PICKAXE EQUIPPED")
			return true
	-- Additional anti-AFK measures
	task.spawn(function()
		while true do
			task.wait(300) -- Every 5 minutes
			
			pcall(function()
				VirtualUser:CaptureController()
				VirtualUser:ClickButton2(Vector2.new())
			end)
			
			print("Anti-AFK: Activity simulated")
end
	end
	
	return false
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN FARMING LOOP
-- WORLD DETECTION LOGIC
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local farmLoop = RunService.Heartbeat:Connect(function()
	if not config.enabled or config.isRespawning then return end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		return
	end
local function detectWorld()
	sendNotification("The Forge", "Detecting world...", 3)

	-- âœ… LAVA CHECK FOR FARMING
	part7a.checkFarmingLavaDamage()
	-- Wait for workspace to load
	local workspace = game:GetService("Workspace")
	local proximity = workspace:WaitForChild("Proximity", 10)

	if config.hoverSequenceActive and config.currentHoverTarget == 1 then
		if part7a.checkProximityToTarget() then
			config.hoverSequenceActive = false
			config.currentHoverTarget = 3
			return
		end
	if not proximity then
		sendNotification("Detection Failed", "Could not find Proximity folder!", 5)
		return nil
end

	if config.hoverSequenceActive then
		if config.currentHoverTarget == 1 then
			if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
				config.currentHoverTarget = 2
			end
		elseif config.currentHoverTarget == 2 then
			if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
				config.currentHoverTarget = 3
				config.hoverSequenceActive = false
			end
		end
		return
	-- Check for World 1: Stonewake's Cross (Arcane Pickaxe)
	local arcanePickaxe = proximity:FindFirstChild("Arcane Pickaxe")
	if arcanePickaxe then
		sendNotification("World Detected", "Stonewake's Cross (World 1)", 4)
		return "World1"
end

	local needNewMob = not config.currentMob or not config.currentMob.Parent or not funcs.isValidMob(config.currentMob)
	
	if needNewMob then
		-- âœ… RESET LAVA MODE WHEN MOB DIES/DISAPPEARS
		if config.farmingInLavaMode and config.savedFarmingPosition then
			print("ğŸ”„ MOB DIED/LOST - Resetting to " .. config.savedFarmingPosition)
			config.lockPosition = config.savedFarmingPosition
			config.savedFarmingPosition = nil
			config.farmingInLavaMode = false
			
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					config.farmingLastHealth = humanoid.Health
					print("ğŸ’š Reset farming health: " .. math.floor(config.farmingLastHealth))
				end
			end
		end
		
		local newMob = funcs.getClosestMob()
		
local newMob = funcs.getClosestMob()
		
		if newMob then
			-- âœ… RESET WHEN SWITCHING TO DIFFERENT MOB
			if newMob ~= config.lastTrackedMob then
				print("ğŸ”„ NEW MOB DETECTED: " .. newMob.Name)
				
				if config.farmingInLavaMode and config.savedFarmingPosition then
					print("ğŸ”„ Different mob - Resetting to " .. config.savedFarmingPosition)
					config.lockPosition = config.savedFarmingPosition
					config.savedFarmingPosition = nil
					config.farmingInLavaMode = false
					
					local character = LocalPlayer.Character
					if character then
						local humanoid = character:FindFirstChildOfClass("Humanoid")
						if humanoid then
							config.farmingLastHealth = humanoid.Health
						end
					end
				end
				
				config.lastTrackedMob = newMob
			end
			
			-- âœ… NEW: Reset idle hover timer when mob found
			config.idleHoverActive = false
			config.idleHoverTimer = 0
		else
			-- âœ… NEW: No mob found - Start idle hover timer
			if not config.idleHoverActive then
				local currentTime = tick()
				
				if config.idleHoverTimer == 0 then
					config.idleHoverTimer = currentTime
					print("â° No mobs found - Starting idle timer...")
				end
				
				if (currentTime - config.idleHoverTimer) >= config.idleHoverDelay then
					print("ğŸš No mobs for " .. config.idleHoverDelay .. " seconds - Hovering to Position 2...")
					config.idleHoverActive = true
				end
			end
		end
		
		config.currentMob = newMob
		
		-- âœ… NEW: If idle hover is active and no mob, hover to position 2
		if config.idleHoverActive and not config.currentMob then
			local character = LocalPlayer.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					local distance = (rootPart.Position - HOVER_POSITION_2).Magnitude
					
					if distance > 10 then
						funcs.hoverToPosition(HOVER_POSITION_2, nil)
						return
					else
						if config.bodyVelocity then
							config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
						end
						return
					end
				end
			end
		end
		
		return
	-- Check for World 2: Forgotten Kingdom (Demonic Pickaxe)
	local demonicPickaxe = proximity:FindFirstChild("Demonic Pickaxe")
	if demonicPickaxe then
		sendNotification("World Detected", "Forgotten Kingdom (World 2)", 4)
		return "World2"
end

	if config.currentMob then
		local lockPos = funcs.getLockPosition(config.currentMob)
		if lockPos then
			funcs.hoverToMob(lockPos, config.currentMob)
		end
	end
end)
	-- Unknown world
	sendNotification("Detection Failed", "Unknown world or pickaxes not found!", 5)
	return nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MINING LOOP WITH IMPROVED DEFENSE SYSTEM (15 STUD DETECTION)
-- SCRIPT LOADER WITH ENHANCED ERROR HANDLING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local miningLoop = RunService.Heartbeat:Connect(function()
	if not config.miningEnabled or config.isRespawning then 
		if config.currentRock then
			config.currentRock = nil
			config.currentRockModel = nil
			config.currentRockId = nil
			config.lastRockDurability = nil
			config.isLockedOn = false
		end
		if config.defendingAgainstMob then
			stopDefenseAttack()
			config.defendingAgainstMob = nil
			config.savedMiningRock = nil
			config.weaponEquipped = false
		end
		config.lastHealth = nil
		config.inLavaMode = false
		config.miningVerticalDistance = config.normalMiningDistance
		config.miningAngle = config.normalMiningAngle
		config.lavaCheckCooldown = false
		return 
	end

	-- âœ… ADD THIS DEBUG CHECK RIGHT HERE
	if config.currentRock then
		local currentTime = tick()
		if (currentTime - (config.lastDebugTime or 0)) >= 1 then -- Print every 1 second
			config.lastDebugTime = currentTime
			print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
			print("ğŸ” [DEBUG] Mining loop running")
			print("   Current Rock: " .. tostring(config.currentRock.Name))
			print("   Ore Filter Enabled: " .. tostring(config.oreFilterEnabled))
			print("   Selected Ores Count: " .. #config.selectedOres)
			print("   Defending: " .. tostring(config.defendingAgainstMob ~= nil))
			print("   Last Ore Check Time: " .. tostring(config.lastOreCheckTime))
			print("   Ore Check Interval: " .. tostring(config.oreCheckInterval))
			if #config.selectedOres > 0 then
				print("   Selected Ores:")
				for _, ore in ipairs(config.selectedOres) do
					print("      â€¢ " .. ore)
				end
			end
			print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		end
	end
	
	if not config.bodyVelocity or not config.bodyGyro then
		funcs.setupPhysicsMovement()
		return
	end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end
	
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end
	
-- âœ… LAVA CHECK FOR MINING (only when not defending)
if not config.defendingAgainstMob then
	part7a.checkLavaDamage()
	part7a.checkCurrentRockHP()
end
	
-- âœ… ORE FILTER CHECK (reads HP from Attributes, no spam, detects HP regen)
if config.oreFilterEnabled and #config.selectedOres > 0 and config.currentRock and not config.defendingAgainstMob then
	local currentTime = tick()
	if (currentTime - config.lastOreCheckTime) >= config.oreCheckInterval then
		config.lastOreCheckTime = currentTime
local function loadWorldScript(world)
	if world == "World1" then
		sendNotification("Loading Script", "Stonewake's Cross loading...", 3)
		
		-- Wait a bit for world to fully load
		task.wait(2)

		local rockTypeModel = config.currentRock.Parent -- This is "Basalt Core", etc.
		if rockTypeModel then
			-- âœ… READ HP FROM ATTRIBUTES
			local currentHP = rockTypeModel:GetAttribute("Health")
			local maxHP = rockTypeModel:GetAttribute("MaxHealth")
		local success, result = pcall(function()
			local scriptContent = game:HttpGet('https://raw.githubusercontent.com/HellishHumanoid/TF/refs/heads/main/theforgestonewakescross')

			if currentHP and maxHP then
				local hpPercentage = (currentHP / maxHP) * 100
				
				-- âœ… NEW: Check if rock regenerated to full HP
				if hpPercentage >= 95 then
					-- Rock has regenerated - remove from ignored list
					for i, ignoredRock in ipairs(config.ignoredRocks) do
						if ignoredRock == config.currentRock then
							table.remove(config.ignoredRocks, i)
							print("ğŸ”„ [ORE CHECK] Rock regenerated to " .. math.floor(hpPercentage) .. "% HP - Removed from ignored list")
							break
						end
					end
				end
			-- Check if content was retrieved
			if scriptContent and scriptContent ~= "" then
				local loadFunc, loadErr = loadstring(scriptContent)

				print("ğŸ”¬ [ORE CHECK] Rock: " .. rockTypeModel.Name .. " | HP: " .. math.floor(hpPercentage) .. "% (" .. currentHP .. "/" .. maxHP .. ")")
				
				-- Check for ores when HP is at 60% or below
				if hpPercentage <= 60 then
					print("â¬‡ï¸ [ORE CHECK] HP below 60% - Checking for ores...")
					
					-- Get ores in rock
					local oresFound = _G.FarmFunctions.getOresInRock(config.currentRock)
					
					if #oresFound == 0 then
						print("â³ [ORE CHECK] No ores spawned yet")
					else
						-- Check if any match our filter
						local hasWantedOre = false
						for _, foundOre in ipairs(oresFound) do
							for _, desiredOre in ipairs(config.selectedOres) do
								if foundOre == desiredOre then
									hasWantedOre = true
									break
								end
							end
							if hasWantedOre then break end
						end
						
						if not hasWantedOre then
							-- âœ… NEW: Only print detailed message ONCE per rock
							local rockId = tostring(config.currentRock)
							if not config.rocksRejectedForOres then
								config.rocksRejectedForOres = {}
							end
							
							if not config.rocksRejectedForOres[rockId] then
								config.rocksRejectedForOres[rockId] = true
								
								print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
								print("âŒ [ORE CHECK] NO WANTED ORES - ABANDONING ROCK!")
								print("ğŸª¨ Ores detected:")
								for _, ore in ipairs(oresFound) do
									print("   â€¢ " .. ore)
								end
								print("ğŸ¯ Your wanted ores:")
								for _, ore in ipairs(config.selectedOres) do
									print("   âœ“ " .. ore)
								end
								print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
							end
							
							-- Add to ignored list
							table.insert(config.ignoredRocks, config.currentRock)
							
							-- Clear current rock
							config.currentRock = nil
							config.currentRockModel = nil
							config.currentRockId = nil
							config.lastRockDurability = nil
							config.isLockedOn = false
							
							-- Stop movement
							if config.bodyVelocity then
								config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
							end
							
							-- âœ… NEW: Only notify once (removed spam)
							if Library and not config.lastOreNotifyTime or (currentTime - config.lastOreNotifyTime) > 3 then
								config.lastOreNotifyTime = currentTime
								Library:Notify("âŒ No wanted ores - Finding new rock", 2)
							end
							
							return -- Exit immediately to find new rock
						else
							print("âœ… [ORE CHECK] CONTINUING MINING - Has wanted ore!")
						end
					end
				if loadFunc then
					loadFunc()
					return true
				else
					error("Failed to compile script: " .. tostring(loadErr))
end
else
				print("âŒ [ORE CHECK] Could not read Health attributes from: " .. rockTypeModel.Name)
				error("Failed to retrieve script from GitHub")
end
		end
	end
end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- âœ… DEFENSE SYSTEM - CHECK FOR THREATS NEAR ROCK (15 STUDS)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	local currentTime = tick()
	-- âœ… FIXED: Using config values instead of local variables
	if not config.defendingAgainstMob and config.currentRock and (currentTime - config.lastDefenseCheckTime >= config.defenseCheckInterval) then
		config.lastDefenseCheckTime = currentTime
		
		local rockPositionPart = funcs.getRockPosition(config.currentRock)
		end)

		if rockPositionPart then
			local rockPos = rockPositionPart.Position
			local closestThreat = nil
			local closestDistance = math.huge
		if success then
			sendNotification("Success!", "Stonewake's Cross loaded!", 4)
		else
			sendNotification("Load Failed", "Please check console for details", 5)
			warn("Stonewake's Cross Load Error: " .. tostring(result))

			-- Check all mobs in Living
			for _, child in pairs(Living:GetChildren()) do
				if funcs.isValidMob(child) then
					local mobRoot = child:FindFirstChild("HumanoidRootPart")
					if mobRoot then
						-- âœ… Distance from MOB to ROCK (15 STUDS)
						local distance = (rockPos - mobRoot.Position).Magnitude
						
						if distance <= config.miningDefenseDistance then  -- âœ… NOW 15 STUDS
							if not closestThreat or distance < closestDistance then
								closestThreat = child
								closestDistance = distance
							end
						end
					end
				end
			end
			-- Retry after 5 seconds
			task.wait(5)
			sendNotification("Retry", "Attempting to reload script...", 3)

			if closestThreat then
				print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
				print("âš”ï¸ THREAT DETECTED! Activating defense mode!")
				print("   Mob: " .. closestThreat.Name)
				print("   Distance from rock: " .. math.floor(closestDistance) .. " studs")
				print("   Detection range: " .. config.miningDefenseDistance .. " studs")
				print("   Defense Position: " .. config.defenseLockPosition)
				print("   Defense Vertical Distance: " .. config.miningDefenseVerticalDistance)
				print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
				
				-- Save current rock
				config.savedMiningRock = config.currentRock
				config.savedMiningRockPosition = rockPos
				
				-- Unlock from rock
				config.currentRock = nil
				config.currentRockModel = nil
				config.currentRockId = nil
				config.isLockedOn = false
				
				-- Enter defense mode
				config.defendingAgainstMob = closestThreat
				config.weaponEquipped = false
				
				-- Switch to weapon
				print("ğŸ”„ Switching to weapon...")
				humanoid:UnequipTools()
				task.wait(0.2)
				
				if forceEquipWeapon() then
					config.weaponEquipped = true
					print("âœ… Weapon equipped!")
				else
					print("âŒ Failed to equip weapon!")
				end
				
				startDefenseAttack()
				
				if Library then
					Library:Notify("âš”ï¸ Defending: " .. closestThreat.Name, 2)
				end
			end
			pcall(function()
				loadstring(game:HttpGet('https://raw.githubusercontent.com/HellishHumanoid/TF/refs/heads/main/theforgestonewake\'scross'))()
			end)
end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- âœ… IMPROVED DEFENSE MODE - USING FARMING LOCK SYSTEM
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
if config.defendingAgainstMob then
	-- âœ… Ensure weapon is equipped, unequip pickaxe if present
	local pickaxe = character:FindFirstChild("Pickaxe")
	local weaponInChar = character:FindFirstChild("Weapon")
	
	if pickaxe and not weaponInChar then
		humanoid:UnequipTools()
		task.wait(0.15)
		forceEquipWeapon()
		task.wait(0.1)  -- âœ… Wait for weapon to fully equip
	elseif not pickaxe and not weaponInChar then
		forceEquipWeapon()
		task.wait(0.1)
	end

-- Check if mob is still alive
		local mobStillAlive = config.defendingAgainstMob.Parent and funcs.isValidMob(config.defendingAgainstMob)
	elseif world == "World2" then
		sendNotification("Loading Script", "Forgotten Kingdom loading...", 3)

		if not mobStillAlive then
			-- âœ… DOUBLE CHECK: Make sure NO other mobs are nearby before switching back
			local safeToSwitchBack = true
			
			-- Check if any other threats are within range
			for _, child in pairs(Living:GetChildren()) do
				if funcs.isValidMob(child) then
					local mobRoot = child:FindFirstChild("HumanoidRootPart")
					if mobRoot and rootPart then
						local distance = (rootPart.Position - mobRoot.Position).Magnitude
						if distance <= (config.miningDefenseDistance + 5) then  -- Extra 5 studs safety margin
							safeToSwitchBack = false
							print("âš ï¸ Another threat nearby - staying in defense mode!")
							
							-- Lock onto this new threat
							config.defendingAgainstMob = child
							return
						end
					end
				end
			end
		-- Wait a bit for world to fully load
		task.wait(2)
		
		local success, result = pcall(function()
			local scriptContent = game:HttpGet('https://raw.githubusercontent.com/HellishHumanoid/TF/refs/heads/main/theforgeforgottenkingdom')

			-- Only switch back if it's truly safe
			if safeToSwitchBack then
				print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
				print("âœ… THREAT ELIMINATED! Area is clear - returning to mining...")
				print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
				
				stopDefenseAttack()
				
				config.defendingAgainstMob = nil
				config.weaponEquipped = false
				
				-- Stop movement
				if config.bodyVelocity then
					config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
				end
				
				-- Switch back to pickaxe ONLY when safe
				print("ğŸ”„ Switching back to pickaxe...")
				humanoid:UnequipTools()
				task.wait(0.3)
			-- Check if content was retrieved
			if scriptContent and scriptContent ~= "" then
				local loadFunc, loadErr = loadstring(scriptContent)

				local pickaxeSuccess = forceEquipPickaxe()
				if pickaxeSuccess then
					print("âœ… Pickaxe equipped - resuming mining")
				else
					print("â³ Pickaxe switch on cooldown - will retry...")
				end
			end
			
			-- Restore saved rock (only if we actually switched back)
			if safeToSwitchBack and config.savedMiningRock then
				if config.savedMiningRock.Parent and funcs.isValidRock(config.savedMiningRock) then
					config.currentRock = config.savedMiningRock
					config.currentRockModel = config.currentRock.Parent
					config.currentRockId = tostring(config.currentRock)
					print("ğŸ¯ Re-locked onto saved rock")
					
					funcs.makeRockTransparent(config.currentRock)
				if loadFunc then
					loadFunc()
					return true
else
					print("âš ï¸ Saved rock no longer valid - will find new rock")
					error("Failed to compile script: " .. tostring(loadErr))
end
				
				config.savedMiningRock = nil
				config.savedMiningRockPosition = nil
			end
			
			config.isLockedOn = false
			
			-- Reset health for lava check
			if humanoid then
				config.lastHealth = humanoid.Health
			else
				error("Failed to retrieve script from GitHub")
end
		end)
		
		if success then
			sendNotification("Success!", "Forgotten Kingdom loaded!", 4)
		else
			sendNotification("Load Failed", "Please check console for details", 5)
			warn("Forgotten Kingdom Load Error: " .. tostring(result))

			if Library then
				Library:Notify("âœ… Back to mining", 2)
			end
			-- Retry after 5 seconds
			task.wait(5)
			sendNotification("Retry", "Attempting to reload script...", 3)

			return
			pcall(function()
				loadstring(game:HttpGet('https://raw.githubusercontent.com/HellishHumanoid/TF/refs/heads/main/theforgeforgottenkingdom'))()
			end)
end

-- Ensure weapon is equipped (only check once, not repeatedly)
local weaponInChar = character:FindFirstChild("Weapon")
if not weaponInChar then
	if not config.weaponEquipped then  -- âœ… Only equip once
		print("âš”ï¸ Equipping weapon for defense...")
		humanoid:UnequipTools()
		task.wait(0.1)
		if forceEquipWeapon() then
			config.weaponEquipped = true
		end
	else
		sendNotification("Error", "Invalid world detected!", 5)
end
	return
end

config.weaponEquipped = true  -- âœ… Mark as equipped
		
		-- âœ… NEW: USE FARMING LOCK SYSTEM FOR DEFENSE
		local lockPos = getDefenseLockPosition(config.defendingAgainstMob)
		if lockPos then
			hoverToMobDefense(lockPos, config.defendingAgainstMob)
		end
		
		return
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- NORMAL MINING (when not defending)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Ensure pickaxe equipped
	if not config.defendingAgainstMob then
		local pickaxeEquipped = character:FindFirstChild("Pickaxe") ~= nil
		if not pickaxeEquipped then
			-- âœ… FIXED: Using config values
			if tick() - config.lastToolEquipTime >= config.toolEquipCooldown then
				config.lastToolEquipTime = tick()
				forceEquipPickaxe()
			end
		end
	end
	
	-- Hover sequence
	if config.hoverSequenceActive and config.currentHoverTarget == 1 then
		if part7a.checkProximityToTarget() then
			config.hoverSequenceActive = false
			config.currentHoverTarget = 3
			return
		end
	end
	
	if config.hoverSequenceActive then
		if config.currentHoverTarget == 1 then
			if funcs.hoverToPosition(config.hoverPosition1, HOVER_POSITION_2) then
				config.currentHoverTarget = 2
			end
		elseif config.currentHoverTarget == 2 then
			if funcs.hoverToPosition(HOVER_POSITION_2, nil) then
				config.currentHoverTarget = 3
				config.hoverSequenceActive = false
			end
		end
		return
	end
	
-- Check if current rock is still valid OR at 0 HP
if config.currentRock then
	local rockIsInvalid = not config.currentRock.Parent or not funcs.isValidRock(config.currentRock)
	local rockAtZeroHP = part7a.isRockAtZeroHP(config.currentRock)
	
	if rockIsInvalid or rockAtZeroHP then
		if rockAtZeroHP then
			print("ğŸ’€ Rock at 0 HP - Finding new rock...")
		end
		
		config.currentRock = nil
		config.currentRockModel = nil
		config.currentRockId = nil
		config.lastRockDurability = nil
		config.isLockedOn = false
		
		if config.bodyVelocity then
			config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		end
		return
	end
end
	
	-- Find new rock
if not config.currentRock then
    local potentialRock = funcs.getClosestRock()
    
    if potentialRock then
        local newRockId = tostring(potentialRock)
        
        if config.inLavaMode and newRockId ~= config.currentRockId then
            print("ğŸ”„ NEW ROCK - Resetting lava mode")
            part7a.resetMiningLavaMode()
        end
        
        if funcs.isOreOccupied(potentialRock) then
            table.insert(config.ignoredRocks, potentialRock)
            return
        end
        
        config.currentRock = potentialRock
        config.currentRockModel = config.currentRock.Parent
        config.currentRockId = newRockId
        config.lastRockDurability = funcs.getRockDurability(config.currentRock)
        config.rockDurabilityCheck = tick()
        funcs.makeRockTransparent(config.currentRock)
        
        -- âœ… NEW: Reset idle hover timer when rock found
        config.idleHoverActive = false
        config.idleHoverTimer = 0
        
        print("ğŸ¯ Locked onto new rock")
    else
        -- âœ… NEW: No rock found - Start idle hover timer
        if not config.idleHoverActive then
            local currentTime = tick()
            
            if config.idleHoverTimer == 0 then
                config.idleHoverTimer = currentTime
                print("â° No rocks found - Starting idle timer...")
            end
            
            if (currentTime - config.idleHoverTimer) >= config.idleHoverDelay then
                print("ğŸš No rocks for " .. config.idleHoverDelay .. " seconds - Hovering to Position 2...")
                config.idleHoverActive = true
            end
        end
        
        -- âœ… NEW: If idle hover is active, hover to position 2
        if config.idleHoverActive then
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local distance = (rootPart.Position - HOVER_POSITION_2).Magnitude
                    
                    if distance > 10 then
                        funcs.hoverToPosition(HOVER_POSITION_2, nil)
                        return
                    else
                        if config.bodyVelocity then
                            config.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                        end
                        return
                    end
                end
            end
        end
    end
    return
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN EXECUTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- âœ… NEW: Reset idle hover when we have a valid rock
config.idleHoverActive = false
config.idleHoverTimer = 0
	
	-- Move to rock and mine
	if config.currentRock then
		local rockPos = funcs.getMiningPosition(config.currentRock)
		if rockPos then
			funcs.hoverToRock(rockPos, config.currentRock)
		end
	end
sendNotification("The Forge", "Initializing by Rafso...", 3)

-- Setup Auto-Rejoin System
task.spawn(function()
	task.wait(0.5)
	pcall(setupAutoRejoin)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CHARACTER RESPAWN HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Setup Anti-AFK System
task.spawn(function()
	task.wait(1)
	pcall(setupAntiAFK)
end)

LocalPlayer.CharacterAdded:Connect(function(character)
	config.isRespawning = true
	
	stopDefenseAttack()
	
	config.currentMob = nil
	config.lastTrackedMob = nil
	config.currentRock = nil
	config.currentRockModel = nil
	config.currentRockId = nil
	config.isLockedOn = false
	config.hoverSequenceActive = false
	config.defendingAgainstMob = nil
	config.savedMiningRock = nil
	config.weaponEquipped = false
	
	-- Reset both lava systems
	config.lastHealth = nil
	config.inLavaMode = false
	config.miningVerticalDistance = config.normalMiningDistance
	config.miningAngle = config.normalMiningAngle
	
	config.farmingLastHealth = nil
	config.farmingInLavaMode = false
	config.savedFarmingPosition = nil
	
	config.lavaCheckCooldown = false
	config.rocksCheckedForOre = {}
	config.ignoredRocks = {}
	config.lastToolEquipTime = 0  -- âœ… FIXED: Reset config value
	config.lastOreCheckTime = 0  -- âœ… Reset ore check timer
	
	funcs.cleanupPhysicsMovement()
	funcs.stopNoclip()
	
	local wasFarming = config.enabled
	local wasMining = config.miningEnabled
	
	if wasFarming or wasMining then
		local rootPart = character:WaitForChild("HumanoidRootPart", 10)
		local humanoid = character:WaitForChild("Humanoid", 10)
		
		if not rootPart or not humanoid then
			config.isRespawning = false
			return
		end
		
		task.wait(3)
		
		if humanoid.Health <= 0 then
			config.isRespawning = false
			return
		end
		
		if (wasFarming and not config.enabled) or (wasMining and not config.miningEnabled) then
			config.isRespawning = false
			return
		end
		
		config.hoverPosition1 = Vector3.new(rootPart.Position.X, HOVER_HEIGHT, rootPart.Position.Z)
		config.hoverSequenceActive = true
		config.currentHoverTarget = 1
		
		funcs.setupPhysicsMovement()
		funcs.startNoclip()
		
		task.wait(1)
		config.lastToolEquipTime = 0  -- âœ… FIXED: Reset config value
		
		if wasFarming then 
			funcs.autoEquipWeapon()
			if humanoid then
				config.farmingLastHealth = humanoid.Health
				print("ğŸ’š Farming health initialized: " .. math.floor(config.farmingLastHealth))
			end
		end
		
		if wasMining then 
			forceEquipPickaxe()
			config.ignoredRocks = {}
			config.lastRockDurability = nil
			config.rockDurabilityCheck = tick()
			
			if humanoid then
				config.lastHealth = humanoid.Health
				print("ğŸ’š Mining health initialized: " .. math.floor(config.lastHealth))
			end
		end
-- Wait for character to load
if not LocalPlayer.Character then
	LocalPlayer.CharacterAdded:Wait()
end

-- Small delay to ensure everything is loaded
task.wait(3)

-- Detect world and load appropriate script
local detectedWorld = detectWorld()

if detectedWorld then
	task.wait(1)
	loadWorldScript(detectedWorld)
else
	sendNotification("Manual Selection", "Retrying detection...", 5)
	
	-- Fallback: Try to detect again after 5 seconds
	task.wait(5)
	local retryWorld = detectWorld()
	if retryWorld then
task.wait(1)
		config.isRespawning = false
		loadWorldScript(retryWorld)
else
		config.isRespawning = false
		sendNotification("Failed", "Could not detect world!", 5)
end
end)

print("âœ… Part 7B COMPLETE - Fixed local variables issue!")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO TALK TO SELLER ON SCRIPT LOAD
-- END OF WORLD DETECTION + AUTO-REJOIN + ANTI-AFK SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
	task.wait(0)
	funcs.talkToSeller()
end)
